JavaScript was initially created to “make web pages alive
The program Written are called scripts.That can be written with HTMLand run automatically as page loads

Today, JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.

The browser has an embedded engine sometimes called a “JavaScript virtual machine”.

Different engines have different “codenames”. For example:

V8 – in Chrome, Opera and Edge.
SpiderMonkey – in Firefox.

How do engines work?
Engines are complicated. But the basics are easy.

The engine (embedded if it’s a browser) reads (“parses”) the script.
Then it converts (“compiles”) the script to the machine language.
And then the machine code runs, pretty fast.
The engine applies optimizations at each step of the process. It even watches the compiled script as it runs, analyzes the data that flows through it, and further optimizes the machine code based on that knowledge.
There are at least three great things about JavaScript:
Full integration with HTML/CSS.
Simple things are done simply.
Supported by all major browsers and enabled by default.

Modern Java Script is safe as it does not provide access to low level access to memory or cpu.

JavaScript 

a. Can do in browser
Add new HTML to the page, change the existing content, modify styles.
React to user actions, run on mouse clicks, pointer movements, key presses.
Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
Get and set cookies, ask questions to the visitor, show messages.
Remember the data on the client-side (“local storage”).

b. Cant do in browser
In the interest of user security, JavaScript's capabilities in the browser are constrained. The objective is to stop a malicious webpage from accessing personal data or damaging the user's data.

JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS functions.

Modern browsers allow it to work with files, but the access is limited and only provided if the user does certain actions, like “dropping” a file into a browser window or selecting it via an <input> tag.

There are ways to interact with camera/microphone and other devices, but they require a user’s explicit permission. So a JavaScript-enabled page may not sneakily enable a web-camera, observe the surroundings and send the information to the NSA.

Different tabs/windows generally do not know about each other. Sometimes they do, for example when one window uses JavaScript to open the other one. But even in this case, JavaScript from one page may not access the other if they come from different sites (from a different domain, protocol or port).

This is called the “Same Origin Policy”. To work around that, both pages must agree for data exchange and contain a special JavaScript code that handles it. We’ll cover that in the tutorial.

This limitation is, again, for the user’s safety. A page from http://anysite.com which a user has opened must not be able to access another browser tab with the URL http://gmail.com and steal information from there.

JavaScript can easily communicate over the net to the server where the current page came from. But its ability to receive data from other sites/domains is crippled. Though possible, it requires explicit agreement (expressed in HTTP headers) from the remote side. Once again, that’s a safety limitation.


Specification
The ECMA-262 specification contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.

Developer tools allow us to see errors, run commands, examine variables, and much more.
They can be opened with F12 for most browsers on Windows. Chrome for Mac needs Cmd+Opt+J, Safari: Cmd+Opt+C (need to enable first).


To run javascript code in the browser can write html code with javascript embedded in it.


Code Structure

can use ; after every line to indicate that the line is ended and to make code more readable but it not necessary for case of line breaks exists
 JavaScript interprets the line break as an “implicit” semicolon. This is called an automatic semicolon insertion.
 But it is not always that it runs perfectly wihtout ; so no ; may lead to error in code.
 

 Comments
One-line comments start with two forward slash characters //.
alert('World'); // This comment follows the statement

Multiline comments start with a forward slash and an asterisk /* and end with an asterisk and a forward slash */.
Shrtcut to add 
In most editors, a line of code can be commented out by pressing the Ctrl+/ hotkey for a single-line comment and something like Ctrl+Shift+/ – for multiline comments (select a piece of code and press the hotkey).



## special directive: "use strict".

For a long time, JavaScript evolved without compatibility issues. New features were added to the language while old functionality didn’t change.

That had the benefit of never breaking existing code. But the downside was that any mistake or an imperfect decision made by JavaScript’s creators got stuck in the language forever.

This was the case until 2009 when ECMAScript 5 (ES5) appeared. It added new features to the language and modified some of the existing ones. To keep the old code working, most such modifications are off by default. You need to explicitly enable them with a special directive: "use strict".

The directive looks like a string: "use strict" or 'use strict'. When it is located at the top of a script, the whole script works the “modern” way.

Modern JavaScript supports “classes” and “modules” – advanced language structures (we’ll surely get to them), that enable use strict automatically. So we don’t need to add the "use strict" directive, if we use them.

So, for now "use strict"; is a welcome guest at the top of your scripts. Later, when your code is all in classes and modules, you may omit it.


## Variables

A variable is a “named storage” for data
to create variable have to use let keyword before that have to use var keyword there  is subtle differences between let and var.

let user = 'John'
  , age = 25
  , message = 'Hello';

  can not initialize the same variable twice

let user = 123;
let user = 1222;
will get error

Variable naming
There are two limitations on variable names in JavaScript:

The name must contain only letters, digits, or the symbols $ and _.
The first character must not be a digit.

Constants
To declare a constant (unchanging) variable, use const instead of let.
As the name suggests they are constants. They cannot be reassigned. An attempt to do so would cause an error
There is a widespread practice to use constants as aliases for difficult-to-remember values that are known prior to execution. 
const PI = 3.14;

Name things right
Talking about variables, there’s one more extremely important thing.

A variable name should have a clean, obvious meaning, describing the data that it stores.

Variable naming is one of the most important and complex skills in programming. A quick glance at variable names can reveal which code was written by a beginner versus an experienced developer.

Data types in javascript
There are eight basic data types in JavaScript.
number -  integer and floating point numbers
BigInt  -- for more than number range like entire range of really big integers, e.g. for cryptography   
          or microsecond-precision timestamps.
string -  anything surrounded by quotes
boolean - type has only two values: true and false
null  -  value does not belong to any of the types described above
undefined - is “value is not assigned”.
symbol - for unique identifiers
object -they  are used to store collections of data and more complex entities


The typeof operator returns the type of the argument. It’s useful when we want to process values of different types differently or just want to do a quick check.

typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"


## Interaction: alert, prompt, confirm

=> alert-  It shows a message and waits for the user to press “OK”.

=> prompt - The function prompt accepts two arguments
eg.
result = prompt(title, [default]);
will accept 2 variables -
title -The text to show the visitor.
default - An optional second parameter, the initial value for the input field.


=> confirm shows a modal window with a question and two buttons: OK and Cancel.

but there are two limitations shared by all the methods above:

The exact location of the modal window is determined by the browser. Usually, it’s in the center.
The exact look of the window also depends on the browser. We can’t modify it.

## Type Conversions
operators and functions automatically convert the values given to them to the right type as needed by them 
different types of cenversion are 
String Conversion - Occurs when we output something. Can be performed with String(value). The conversion to string is usually obvious for primitive values.
Numeric Conversion - Occurs in math operations. Can be performed with Number(value).
Boolean Conversion -  Occurs in logical operations. Can be performed with Boolean(value).
for boolean conversion
Value	                        Becomes…
0, null, undefined, NaN, "" 	false
any other value	              true


## Basic operators, maths
 things like addition +, multiplication *, subtraction -, and so on.

 The following math operations are supported:

Addition +,
Subtraction -,
Multiplication *,
Division /,
Remainder %,
Exponentiation **.

Operator precedence
If an expression has more than one operator, the execution order is defined by their precedence, or, in other words, the default priority order of operators

Precedence	Name	Sign
…	…	…
15	unary plus	+
15	unary negation	- =>  unary negation - reverses the sign of a number:
14	exponentiation	**
13	multiplication	*
13	division	/
12	addition	+
12	subtraction	-
…	…	…
2	assignment	=

The unary plus doesn’t do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.


Assignment = returns a value
and there is also Another interesting feature is the ability to chain assignments

can also chain the assignments, 
Modify-in-place(n = n + 5;) also  notation can be shortened using the operators += and *=
Increment ++ increases a variable by 1
Decrement -- decreases a variable by 1
The operators ++ and -- can be placed either before or after a variable.
When the operator goes after the variable, it is in “postfix form”: counter++.
The “prefix form” is when the operator goes before the variable: ++counter


Bitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.
These operators are not JavaScript-specific. They are supported in most programming languages.
The list of operators:
AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )

The comma operator ,  = it’s used to write shorter codes , it has very low precedence

## Comparison
Greater/less than: a > b, a < b.
Greater/less than or equals: a >= b, a <= b.
Equals: a == b, please note the double equality sign == means the equality test, while a single one a = b means an assignment.


All comparison operators return a boolean value:

true – means “yes”, “correct” or “the truth”.
false – means “no”, “wrong” or “not the truth”.

To see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order.
alert( 'Glow' > 'Glee' ); // true

When comparing values of different types, JavaScript converts the values to numbers.
alert( '2' > 1 );

A regular equality check == has a problem. It cannot differentiate 0 from false

Null and undefined are very strange while using coomparision
Treat any comparison with undefined/null except the strict equality === with exceptional care.
Don’t use comparisons >= > < <= with a variable which may be null/undefined, unless you’re really sure of what you’re doing. If a variable can have these values, check for them separately.



## Conditional branching: if, '?'

The “if” statement - The if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of code.

Boolean conversion- The if (…) statement evaluates the expression in its parentheses and converts the result to a boolean.So ->
A number 0, an empty string "", null, undefined, and NaN all become false. Because of that they are called “falsy” values.
Other values become true, so they are called “truthy”

The “else” clause - The if statement may contain an optional “else” block. It executes when the condition is falsy.

Several conditions: “else if” -  Can nest the if else condition . to test several variants of a condition. The else if clause lets us do that. by chaining in else using else if

Conditional operator ‘?’- The operator is represented by a question mark ?. Sometimes it’s called “ternary”, because the operator has three operands
let result = condition ? value1 : value2;

Multiple ‘?’- A sequence of question mark operators ? can return a value that depends on more than one condition. its like switch case
let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';

Non-traditional use of ‘?’ - Sometimes the question mark ? is used as a replacement for if
(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');

## Logical operators

There are four logical operators in JavaScript: || (OR), && (AND), ! (NOT), ?? (Nullish Coalescing)

|| (OR) - If any of its arguments are true, it returns true, otherwise it returns false

OR "||" finds the first truthy value

&& (AND) Evaluates operands from left to right.
For each operand, converts it to boolean. If the result is true, stops and returns the original value of that operand.

AND “&&” finds the first falsy value
 Given multiple AND’ed values:
result = value1 && value2 && value3;
The AND && operator does the following:
Evaluates operands from left to right.
For each operand, converts it to a boolean. If the result is false, stops and returns the original value of that operand.
Incase of alert if the first operand is truthy,AND returns the second operand
and if the first operand is falsy, AND returns it. The second operand is ignored

! (NOT)
The operator accepts a single argument and does the following
Converts the operand to boolean type: true/false.
Returns the inverse value.


## Nullish coalescing operator '??'
The result of a ?? b is:

if a is defined, then a,
if a isn’t defined, then b

it treats null and undefined similarly

result = a ?? b is similiar to result = (a !== null && a !== undefined) ? a : b;

The important difference between ?? and ||:

|| returns the first truthy value.
?? returns the first defined value.

The precedence of the ?? operator is the same as ||. They both equal 4

Due to safety reasons, JavaScript forbids using ?? together with && and || operators, unless the precedence is explicitly specified with parentheses.

## Loops while and for
The “while” loop
while (condition) {
  // code
  // so-called "loop body"
}

The “do…while” loop
do {
  // loop body
} while (condition);

The “for” loop
for (begin; condition; step) {
  // ... loop body ...
}

Breaking the loop
Normally, a loop exits when its condition becomes falsy.
But we can force the exit at any time using the special break directive.

Continue to the next iteration
The continue directive is a “lighter version” of break. It doesn’t stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).

Labels for break/continue
If we want to break from multiple loop have to use the label name to specify so that we can specify specifically from whcih loop we need to break or continue the next operation from.
labelName: for (...) {
  ...
}


## Switch Case

A switch statement can replace multiple if checks.
The switch has one or more case blocks and an optional default.
Breaks are inmoprtant If there is no break then the execution continues with the next case without any checks.
Any expression can be a switch/case argument
Several variants of case which share the same code can be grouped.
Type matters -  The values must be of the same type to match

## Functions

Function Declaration
To create a function we can use a function declaration.
Syntax
function name(parameter1, parameter2, ... parameterN) {
  ...body...
}



Local variables - A variable declared inside a function is only visible inside that function.

Outer variables - A function can access an outer variable as well which are not declared in the function

Parameters - pass arbitrary data to functions using parameters

Default values - If a function is called, but an argument is not provided, then the corresponding value becomes undefined. So while creating function we can give the parameters the value to default to is no value is passed while calling funtion.

Returning a value - A function can return a value back into the calling code as the result.
The directive return can be in any place of the function. When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to result above).
It is possible to use return without a value. That causes the function to exit immediately.

Naming a function -Functions are actions. So their name is usually a verb. 
It should be brief, as accurate as possible and describe what the function does, so that someone reading the code gets an indication of what the function does.

Functions == Comments - Functions should be short and do exactly one thing.
A separate function is not only easier to test and debug – its very existence is a great comment!



## Function expressions
Function is a value
Syntax for creating a function that is called a Function Expression

Callback functions
We can send the funtion as the parameters to another funtion and then that function can be called in that function
Function declared in the calling statement of another function as they have no name, and so are called anonymous.

Function Expression vs Function Declaration
Function Declaration: a function, declared as a separate statement, in the main code flow
Function Expression: a function, created inside an expression or inside another syntax construct. Here, the function is created on the right side of the “assignment expression” =
A Function Expression is created when the execution reaches it and is usable only from that moment.
but A Function Declaration can be called earlier than it is defined

Function Declaration is only visible inside the code block in which it resides
So as to make that function be visible outside then the approach would be to use a Function Expression and assign function to the variable that is declared outside of block and has the proper visibility.


## Arrow functions, the basics
another very simple and concise syntax for creating functions, that’s often better than Function Expressions.It’s called “arrow functions”
Syntax
let func = (arg1, arg2, ..., argN) => expression;
let sum = (a, b) => a + b;

If there are no arguments, parentheses are empty, but they must be present:
let sayHi = () => alert("Hello!");

to dynamically create a function.eg. ->
let welcome = (age < 18) ?
  () => alert('Hello!') :
  () => alert("Greetings!");

Multiline arrow functions
With curly braces: (...args) => { body } – brackets allow us to write multiple statements inside the function, but we need an explicit return to return something.

Debugging in the browser
Debugging is the process of finding and fixing errors within a script.


The “Sources” panel
Turn on developer tools with F12
Select the Sources panel.
The Sources panel has 3 parts:
The File Navigator pane lists HTML, JavaScript, CSS and other files, including images that are attached to the page. Chrome extensions may appear here too.
The Code Editor pane shows the source code.
The JavaScript Debugging pane is for debugging, we’ll explore it soon.

Console- In sources panel If we press Esc, then a console opens below. We can type commands there and press Enter to execute.


Breakpoints - A breakpoint is a point of code where the debugger will automatically pause the JavaScript execution.In the sources click on the line number to create breakpoints.

The command “debugger”
We can also pause the code by using the debugger command in it

Pause and look around- while in the sources pane
Please open the informational dropdowns to the right (labeled with arrows). They allow you to examine the current code state:
Watch – shows current values for any expressions.
You can click the plus + and input an expression. The debugger will show its value, automatically recalculating it in the process of execution.
Call Stack – shows the nested calls chain.
At the current moment the debugger is inside hello() call, called by a script in index.html (no function there, so it’s called “anonymous”).
click on a stack item (e.g. “anonymous”), the debugger jumps to the corresponding code, and all its variables can be examined as well.
Scope – current variables.
Local shows local function variables. You can also see their values highlighted right over the source.
Global has global variables (out of any functions). \


Tracing the execution - After stoppin have to execute the command by “Resume”: continue the execution, hotkey F8.
And If there are no additional breakpoints, then the execution just continues and the debugger loses control.
“Step”: run the next command, hotkey F9.
“Step over”: run the next command, but don’t go into a function, hotkey F10.
“Step into”, hotkey F11. similar to “Step”, but behaves differently in case of asynchronous function calls
“Step out”: continue the execution till the end of the current function, hotkey Shift+F11.


Logging - To output something to console from our code, there’s console.log function.
To see it, either open the Console panel of developer tools or press Esc while in another panel: that opens the console at the bottom


## Coding style




## Comments

comments can be single-line: starting with // and multiline: /* ... */.
Do not  use comments to explain “what is going on in the code”.donot make comment to  tell “how code works” and “what it does”.
Recipe: factor out functions, Sometimes it’s beneficial to replace a code piece with a function

Good Comments
Describe the architecture
Document function parameters and usage
Can explain Why is the task solved this way?
Also, If the code has anything subtle and counter-intuitive, it’s definitely worth commenting.


## Polyfills and transpilers

Transpilers
A transpiler is a special piece of software that translates source code to another source code. 
It can parse (“read and understand”) modern code and rewrite it using older syntax constructs, so that it’ll also work in outdated engines.


Polyfills
If there is only introduction of  new functions, not syntax changes, there’s no need to transpile anything here. We just need to declare the missing function.
A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations.


## Objects
Objects are used to store keyed collections of various data and more complex entities.
An object can be created with figure brackets {…} with an optional list of properties. 
A property is a “key: value” pair, where key is a string (also called a “property name”), and value can be anything.

Square brackets - 
For multiword properties, the dot access doesn’t work
But “square bracket notation” that works with any string
Square brackets also provide a way to obtain the property name as the result of any expression – as opposed to a literal string – like from a variable as follows.
We can use square brackets in an object literal, when creating an object. That’s called computed properties.

Property value shorthand-
In real code, we often use existing variables as values for property names.

Property names limitations
a variable cannot have a name equal to one of the language-reserved words like “for”, “let”, “return” etc.
But for an object property, there’s no such restriction
special property named __proto__. We can’t set it to a non-object value


Property existence test, “in” operator
 it’s possible to access any property. There will be no error if the property doesn’t exist!
 To test whether the property exists and there is a special operator "in" for that

The "for..in" loop-
To walk over all keys of an object, there exists a special form of the loop: for..in. This is a completely different thing from the for(;;)

Ordered like an object
“ordered in a special fashion”: integer properties are sorted, others appear in creation order. The details follow.


##  Object references and copying
One of the fundamental differences of objects versus primitives is that objects are stored and copied “by reference”, whereas primitive values: strings, numbers, booleans, etc – are always copied “as a whole value”.
A variable assigned to an object stores not the object itself, but its “address in memory” – in other words “a reference” to it.
When an object variable is copied, the reference is copied, but the object itself is not duplicated.

Comparison by reference
Two objects are equal only if they are the same object.
And  two independent objects are not equal, even though they look alike (both are empty) and equal

Cloning and merging, Object.assign
We can create a new object and replicate the structure of the existing one, by iterating over its properties and copying them on the primitive level.To this we can also use the method Object.assign.

Nested cloning
There are also the chance of the of having object not only having primitives but can also have object.
use a cloning loop that examines each value of object and, if it’s an object, then replicate its structure as well. That is called a “deep cloning”.
==>We can use recursion to implement it. Or, to not reinvent the wheel, take an existing implementation, for instance _.cloneDeep(obj) from the JavaScript library lodash.

## Grabage Collection
The main concept of memory management in JavaScript is reachability.

Reachability
reachable” values are those that are accessible or usable somehow. They are guaranteed to be stored in memory.
1. There’s a base set of inherently reachable values, that cannot be deleted for obvious reasons.
For instance:
The currently executing function, its local variables and parameters.
Other functions on the current chain of nested calls, their local variables and parameters.
Global variables.
(there are some other, internal ones as well)
These values are called roots.
2. Any other value is considered reachable if it’s reachable from a root by a reference or by a chain of references.
For instance, if there’s an object in a global variable, and that object has a property referencing another object, that object is considered reachable. And those that it references are also reachable. Detailed examples to follow.
There’s a background process in the JavaScript engine that is called garbage collector. It monitors all objects and removes those that have become unreachable.



A simple example

Two references
If 2 variable refrence same object but if delete one  Then the object is still reachable via another global variable, so it must stay in memory. If we overwrite other variable too, then it can be removed.

Interlinked objects
Outgoing references do not matter. Only incoming ones can make an object reachable.

Unreachable island
It is possible that the whole island of interlinked objects becomes unreachable and is removed from the memory.
Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole.

Internal algorithms

The basic garbage collection algorithm is called “mark-and-sweep”.
The following “garbage collection” steps are regularly performed:
The garbage collector takes roots and “marks” (remembers) them.
Then it visits and “marks” all references from them.
Then it visits marked objects and marks their references. All visited objects are remembered, so as not to visit the same object twice in the future.
…And so on until every reachable (from the roots) references are visited.
All objects except marked ones are removed.

JavaScript engines apply many optimizations to make it run faster and not introduce any delays into the code execution.

Some of the optimizations:

Generational collection – objects are split into two sets: “new ones” and “old ones”. 
In typical code, many objects have a short life span: they appear, do their job and die fast, so it makes sense to track new objects and clear the memory from them if that’s the case.
 Those that survive for long enough, become “old” and are examined less often.

Incremental collection – if there are many objects, and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. 
So the engine splits the whole set of existing objects into multiple parts. And then clear these parts one after another. There are many small garbage collections instead of a total one. 
That requires some extra bookkeeping between them to track changes, but we get many tiny delays instead of a big one.

Idle-time collection – the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution.


## Object methods, "this"
A function that is a property of an object is called its method

Method examples- Method Shorthand
There exists a shorter syntax for methods in an object literal

“this” in methods- 
It’s common that an object method needs to access the information stored in the object to do its job.
To access the object, a method can use the this keyword.
 it’s also possible to access the object without this, by referencing it via the outer variable.But such code is unreliable. If we decide to copy object to another variable, e.g. admin = user and overwrite user with something else, then it will access the wrong object.

“this” is not bound
 this can be used in any function, even if it’s not a method of an object.
The value of this is evaluated during the run-time, depending on the context.
Unlike other languages In JavaScript this is “free”, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what object is “before the dot”.

Arrow functions have no “this”
Arrow functions are special: they don’t have their “own” this. If we reference this from such a function, it’s taken from the outer “normal” function.

# Constructor, operator "new":
The regular {...} syntax allows us to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.
That can be done using constructor functions and the "new" operator.

## Constructor function
Constructor functions technically are regular functions. There are two conventions though:
-They are named with capital letter first.
-They should be executed only with "new" operator.

That’s the main purpose of constructors – to implement reusable object creation code.
new function() { … }
If we have many lines of code all about creation of a single complex object, we can wrap them in an immediately called constructor function, like this:
// create a function and immediately call it with new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...other code for user creation
  // maybe complex logic and statements
  // local variables etc
};
This constructor can’t be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse.

 Constructor mode test: new.target:
Inside a function, we can check whether it was called with new or without it, using a special new.target property.

 Return from constructors:
Usually, constructors do not have a return statement. Their task is to write all necessary stuff into this, and it automatically becomes the result.
But if there is a return statement, then the rule is simple:
If return is called with an object, then the object is returned instead of this.
If return is called with a primitive, it’s ignored.
In other words, return with an object returns that object, in all other cases this is returned.

Omitting parentheses
By the way, we can omit parentheses after new, if it has no arguments:
let user = new User; // <-- no parentheses
// same as
let user = new User();
Omitting parentheses here is not considered a “good style”, but the syntax is permitted by specification.

 Methods in constructor
Using constructor functions to create objects gives a great deal of flexibility. The constructor function may have parameters that define how to construct the object, and what to put in it.
Of course, we can add to this not only properties, but methods as well.

Constructor functions or, briefly, constructors, are regular functions, but there’s a common agreement to name them with capital letter first.
Constructor functions should only be called using new. Such a call implies a creation of empty this at the start and returning the populated one at the end.
We can use constructor functions to make multiple similar objects.
JavaScript provides constructor functions for many built-in language objects: like Date for dates, Set for sets and others

##  Symbol is a primitive type for unique identifiers.
Symbols are created with Symbol() call with an optional description (name).
Symbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: 
Symbol.for(key) returns (creates if needed) a global symbol with key as the name. Multiple calls of Symbol.for with the same key return exactly the same symbol.

 System symbols:
There exist many “system” symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.
They are listed in the specification in the Well-known symbols table:
Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
…and so on.
For instance, Symbol.toPrimitive allows us to describe object to primitive conversion.

 Symbols in an object literal
If we want to use a symbol in an object literal {...}, we need square brackets around it.

Like this:
let id = Symbol("id");
let user = {
  name: "John",
  [id]: 123 // not "id": 123
};
That’s because we need the value from the variable id as the key, not the string “id”

Symbols are skipped by for…in
Symbolic properties do not participate in for..in loop.

“Hidden” properties
Symbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.
If another script or a library loops over our object, it won’t unexpectedly access a symbolic property.

Global symbols
As we’ve seen, usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities. 
For instance, different parts of our application want to access symbol "id" meaning exactly the same property.
To achieve that, there exists a global symbol registry. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.
In order to read (create if absent) a symbol from the registry, use Symbol.for(key).
That call checks the global registry, and if there’s a symbol described as key, then returns it, otherwise creates a new symbol Symbol(key) and stores it in the registry by the given key.

Symbol.keyFor -
We have seen that for global symbols, Symbol.for(key) returns a symbol by name. To do the opposite – return a name by global symbol – we can use: Symbol.keyFor(sym):

Symbols have two main use cases:
-“Hidden” object properties.
If we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in for..in, so it won’t be accidentally processed together with other properties. 
Also it won’t be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.
So we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.
-There are many system symbols used by JavaScript which are accessible as Symbol.*. We can use them to alter some built-in behaviors. 

## Optional chaining '?.'
The optional chaining ?. is a safe way to access nested object properties, even if an intermediate property doesn’t exist.

The “non-existing property” problem-
If we try to sccess a property of the object that is not there it will give error but what is preferable is that it is undefined.
In Web development, we can get an object that corresponds to a web page element using a special method call, such as document.querySelector('.elem'), and it returns null when there’s no such element.

> let user = {};
undefined
> let html = document.querySelector('.elem').innerHTML;
Uncaught ReferenceError: document is not defined
> 

either we can use if statement or document.querySelector
AND’ing the whole path to the property ensures that all components exist (if not, the evaluation stops), but also isn’t ideal.

> console.log( user.address && user.address.street && user.address.street.name );
undefined
undefined

property names are still duplicated in the code
That’s why the optional chaining ?. was added to the language


Optional chaining
The optional chaining ?. stops the evaluation if the value before ?. is undefined or null and returns undefined.


value?.prop:
works as value.prop, if value exists,
otherwise (when value is undefined/null) it returns undefined.

> console.log( user?.address?.street );
undefined
undefined

Note- Don’t overuse the optional chaining
We should use ?. only where it’s ok that something doesn’t exist.
For example, if according to our code logic user object must exist, but address is optional, then we should write user.address?.street, but not user?.address?.street.

Also The variable before ?. must be declared.

Short-circuiting
 the ?. immediately stops (“short-circuits”) the evaluation if the left part doesn’t exist.
 So, if there are any further function calls or operations to the right of ?., they won’t be made.


 > let x = 0;
undefined
> user?.sayHi(x++);
Uncaught TypeError: user?.sayHi is not a function


Other variants: ?.(), ?.[]
The optional chaining ?. is not an operator, but a special syntax construct, that also works with functions and square brackets.
?.() is used to call a function that may not exist.

> let userAdmin = {
...   admin() {
.....     console.log("I am admin");
.....   }
... };
undefined
> 
> let userGuest = {};
undefined
> 
> userAdmin.admin?.(); // I am admin
I am admin
undefined
> 
> userGuest.admin?.();
undefined
Here  ?.() checks the left part: if the admin function exists, then it runs (that’s so for userAdmin). Otherwise (for userGuest) the evaluation stops without errors.


The ?.[] syntax also works, if we’d like to use brackets [] to access properties instead of dot .. Similar to previous cases, it allows to safely read a property from an object that may not exist.
> let key = "firstName";
undefined
> 
> let user1 = {
...   firstName: "John"
... };
undefined
> 
> let user2 = null;
undefined
> 
> console.log( user2?.[key] );
undefined
undefined
> console.log( user1?.[key] );
John
undefined


We can use ?. for safe reading and deleting, but not writing
> delete user1?.firstname;
true
> delete user2?.firstname;
true
> delete user2.firstname;
Uncaught TypeError: Cannot convert undefined or null to object
> delete user2?.firstname;
true

The optional chaining ?. has no use on the left side of an assignment.


## Object to primitive conversion
JavaScript doesn’t allow you to customize how operators work on objects.
In case of such operations, objects are auto-converted to primitives, and then the operation is carried out over these primitives and results in a primitive value.

Conversion rules
There’s no conversion to boolean. All objects are true in a boolean context, as simple as that. There exist only numeric and string conversions.
The numeric conversion happens when we subtract objects or apply mathematical functions.
As for the string conversion – it usually happens when we output an object with alert(obj) and in similar contexts.

Hints-
There are three variants of type conversion, that happen in various situations. They’re called “hints”, as described in the specification.

String:-
For an object-to-string conversion, when we’re doing an operation on an object that expects a string

"default"
Occurs in rare cases when the operator is “not sure” what type to expect.
If an object is compared using == with a string, number or a symbol, it’s also unclear which conversion should be done, so the "default" hint is used.

To do the conversion, JavaScript tries to find and call three object methods:

Call obj[Symbol.toPrimitive](hint) – the method with the symbolic key Symbol.toPrimitive (system symbol), if such method exists,
Otherwise if hint is "string"
try calling obj.toString() or obj.valueOf(), whatever exists.
Otherwise if hint is "number" or "default"
try calling obj.valueOf() or obj.toString(), whatever exists.


Symbol.toPrimitive-
There’s a built-in symbol named Symbol.toPrimitive that should be used to name the conversion method
If the method Symbol.toPrimitive exists, it’s used for all hints, and no more methods are needed

A conversion can return any primitive type:
The important thing to know about all primitive-conversion methods is that they do not necessarily return the “hinted” primitive.
There is no control whether toString returns exactly a string, or whether Symbol.toPrimitive method returns a number for the hint "number".
The only mandatory thing: these methods must return a primitive, not an object.
> let user = {
...   name: "John",
...   money: 1000,
... 
...   [Symbol.toPrimitive](hint) {
...     console.log(`hint: ${hint}`);
...     return hint == "string" ? `{name: "${this.name}"}` : this.money;
...   }
... };
undefined
> 
> 
> console.log(user); 
{
  name: 'John',
  money: 1000,
  [Symbol(Symbol.toPrimitive)]: [Function: [Symbol.toPrimitive]]
}
undefined
> console.log(+user); 
hint: number
1000
undefined
> console.log(user + 500); 
hint: default
1500
undefined
> 

toString/valueOf-
If there’s no Symbol.toPrimitive then JavaScript tries to find methods toString and valueOf:

For the "string" hint: call toString method, and if it doesn’t exist, then valueOf (so toString has the priority for string conversions).
For other hints: valueOf, and if it doesn’t exist, then toString (so valueOf has the priority for maths).

These methods must return a primitive value. If toString or valueOf returns an object, then it’s ignored.
By default, a plain object has following toString and valueOf methods:
The toString method returns a string "[object Object]".
The valueOf method returns the object itself.

> let user = {name: "John"};
undefined
> 
> console.log(user); 
{ name: 'John' }
undefined
> console.log(user.valueOf() === user); 
true
undefined





A conversion can return any primitive type - 
The important thing to know about all primitive-conversion methods is that they do not necessarily return the “hinted” primitive.

There is no control whether toString returns exactly a string, or whether Symbol.toPrimitive method returns a number for the hint "number".

The only mandatory thing: these methods must return a primitive, not an object.


## Methods of primitives-
JavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. They also provide methods to call as such.
here are 7 primitive types: string, number, bigint, boolean, symbol, null and undefined.

Also, there are many built-in objects already exist, such as those that work with dates, errors, HTML elements, etc. They have different properties and methods.

A primitive as an object- 
The language allows access to methods and properties of strings, numbers, booleans and symbols.
In order for that to work, a special “object wrapper” that provides the extra functionality is created, and then is destroyed.
The “object wrappers” are different for each primitive type and are called: String, Number, Boolean, Symbol and BigInt. Thus, they provide different sets of methods.

> let name = "Shubham";
undefined
> console.log( name.toUpperCase() );
SHUBHAM
undefined

Formally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call.

## Numbers methods
there are two types of numbers:

Regular numbers in JavaScript are stored in 64-bit format IEEE-754, also known as “double precision floating point numbers”. Most common type of numner used.

BigInt numbers represent integers of arbitrary length. They are sometimes needed because a regular integer number can’t safely exceed (253-1) or be less than -(253-1).

More ways to write a number-
We also can use underscore _ as the separator.
To amke big no. more readeable .
The JavaScript engine simply ignores _ between digits
try to avoid writing long sequences of zeroes .
we can shorten a number by appending the letter "e" to it and specifying the zeroes count

> let x = 10000;
undefined
> let y = 10_000;
undefined
> console.log(x == y)
true
> let z = 1e4;
undefined
> 
> console.log(x == z)
true
>  z = 1e-4;
0.0001
> 


For different numeral systems:
Can write numbers directly in hex (0x), octal (0o) and binary (0b) systems.

> z = 0xFF;
255
> z = 0b11111111;
255
> z = 0o377;
255
There are only 3 numeral systems with such support.

toString(base)- 

The method num.toString(base) returns a string representation of num in the numeral system with the given base.
> z.toString(2);
'11111111'
> z.toString(16);
'ff'
> z.toString(8);
'377'
Common use cases for this are:
base=16 is used for hex colors, character encodings etc, digits can be 0..9 or A..F.
base=2 is mostly for debugging bitwise operations, digits can be 0 or 1.

Rounding-

To roud to nearest integer.
Math.floor
Rounds down: 3.1 becomes 3, and -1.1 becomes -2.

Math.ceil
Rounds up: 3.1 becomes 4, and -1.1 becomes -1.

Math.round
Rounds to the nearest integer: 3.1 becomes 3, 3.6 becomes 4, the middle case: 3.5 rounds up to 4 too.

Math.trunc (not supported by Internet Explorer)
Removes anything after the decimal point without rounding: 3.1 becomes 3, -1.1 becomes -1.
> Math.floor(3.1);
3
> Math.floor(-3.1);
-4
> Math.ceil(-3.1);
-3
> Math.ceil(3.1);
4
> Math.round(3.1);
3
> Math.round(-3.1);
-3
> Math.trunc(-3.1);
-3
> Math.trunc(3.1);
3
> 


TO round to nearest decimal points - 
Multiply-and-divide.
For example, to round the number to the 2nd digit after the decimal, we can multiply the number by 100, call the rounding function and then divide it back.
> let num = 1.23456789;
undefined
> console.log( Math.round(num * 100) / 100 ); 
1.23
undefined

The method toFixed(n) rounds the number to n digits after the point and returns a string representation of the result.
> console.log( num.toFixed(1) ); 
1.2
undef
> console.log( num.toFixed(5) ); 
1.23457
undefined
> 
the result of toFixed is a string. If the decimal part is shorter than required, zeroes are appended to the end
> console.log( z.toFixed(5) ); 
255.00000
undefined
And we can convert it to a number using the unary plus or a Number()
> console.log( +z.toFixed(5) ); 
255
undefined

> console.log(Number(z.toFixed(5)) ); 
255

Imprecise calculations -
Internally, a number is represented in 64-bit format IEEE-754, so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point, and 1 bit is for the sign.

If a number is really huge, it may overflow the 64-bit storage and become a special numeric value Infinity
> console.log( 1e500 );
Infinity

There’s just no way to store exactly 0.1 or exactly 0.2 using the binary system, just like there is no way to store one-third as a decimal fraction.

The numeric format IEEE-754 solves this by rounding to the nearest possible number. These rounding rules normally don’t allow us to see that “tiny precision loss”, but it exists
> console.log( 0.1.toFixed(20) );
0.10000000000000000555
undefined
> console.log( 0.1 + 0.2 == 0.3 );
false
undefined

we can elminite this error by using  toFixed method but have change string to number after it.
> console.log( +sum.toFixed(2) );
0.4
undefined
> 

Infinity (and -Infinity) is a special numeric value that is greater (less) than anything.

NaN represents an error.


isNaN(value) converts its argument to a number and then tests it for being NaN
> console.log( isNaN(NaN) );
true
undefined
> console.log( isNaN(sum) );
false


 we can not just use the comparison === NaN. The value NaN is unique in that it does not equal anything


isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity

> console.log( isFinite(Infinity) );
false
undefined
> console.log( isFinite(sum) );
true

isFinite can also be used to check if the string is valid number or not
> sum = "Hello"
'Hello'
> console.log( isFinite(sum) );
false
undefined

parseInt and parseFloat - 
Numeric conversion using a plus + or Number() is strict. If a value is not exactly a number, it fails.

To get no. out of '13$' or '13.4cm' have to use above funtions.
> console.log(parseInt('13.4$'));
13
undefined
> console.log(parseFloat('13.4$'));
13.4
undefined
> 

Other math functions-
Math.random()
Returns a random number from 0 to 1 (not including 1).
> Math.random(20);
0.6982506610603878
> Math.random();
0.10144248663710376


Math.max(a, b, c...) and Math.min(a, b, c...)
Returns the greatest and smallest from the arbitrary number of arguments.
> Math.max(3, 5, -10, 0, 1)
5
> Math.min(1, 2)
1

Math.pow(n, power)
Returns n raised to the given power.
> Math.pow(2, 10)
1024

## Strings
In JavaScript, the textual data is stored as strings. There is no separate type for a single character.

Strings can be enclosed within either single quotes, double quotes or backticks:
> let single = 'single-quoted';
undefined
> let double = "double-quoted";
undefined
> let backticks = `backticks`;
undefined
> single+double+ backticks
'single-quoteddouble-quotedbackticks'

Single and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, by wrapping it in ${…}
> (`1 + 2 = ${Math.min(1, 2)}.`);
'1 + 2 = 1.'

Another advantage of using backticks is that they allow a string to span multiple lines but this cannot be done with single and double qoutes.

> let guestList = `Guests:
...  * John
...  * Pete
...  * Mary
... `;
undefined
> guestList
'Guests:\n * John\n * Pete\n * Mary\n'

Special characters-
It is still possible to create multiline strings with single and double quotes by using a so-called “newline character”, written as \n, which denotes a line break
> let guestList1 = "Guests:\n * John\n * Pete\n * Mary";
undefined
> guestList1
'Guests:\n * John\n * Pete\n * Mary'

> "\u00A9"
'©'
> 'I\'m the Shubham' 
"I'm the Shubham"
> `The backslash: \\`
'The backslash: \\'
> console.log(`The backslash: \\`);
The backslash: \
undefined

String length
The length property has the string length
> sum.length
5

Accessing characters
To get a character at position pos, use square brackets [pos] or call the method str.charAt(pos)
The only difference between them is that if no character is found, [] returns undefined, and charAt returns an empty string
> let str = `Hello`;
undefined
> str[0] 
'H'
> str.charAt(0)
'H'
> str[1000] 
undefined
> str.charAt(1000)
''

Strings are immutable-
Strings can’t be changed in JavaScript. It is impossible to change a character.
> str[0] = 'h';
'h'
> str
'Hello's

The usual workaround is to create a whole new string and assign it to str instead of the old one.
> str
'Hello'
> str = 'h' + str[1];
'he'
> str
'he'

Changing the case-
> sum.toUpperCase()
'HELLO'
> sum.toLowerCase()
'hello'


Searching for a substring
str.indexOf
The first method is str.indexOf(substr, pos).
It looks for the substr in str, starting from the given position pos, and returns the position where the match was found or -1 if nothing can be found.
> str = 'Widget with id';
'Widget with id'
> str.indexOf('Widget') 
0
> str.indexOf("ids")
-1
> 
The optional second parameter allows us to start searching from a given position.
> str.indexOf('id', 2)
12
> str = 'Widget id with id';
'Widget id with id'
> str.indexOf('id', 2)
7
> str.indexOf('id', 8)
15
> 

str.lastIndexOf(substr, position)
There is also a similar method str.lastIndexOf(substr, position) that searches from the end of a string to its beginning.
There is a slight inconvenience with indexOf in the if test. We can’t put it in the if like this
It doesnot work

The bitwise NOT trick
It converts the number to a 32-bit integer (removes the decimal part if exists) and then reverses all bits in its binary representation
~n is zero only if n == -1 
> ~0
-1
> ~-2
1
> 
 as modern JavaScript provides .includes method it is not much used.
The more modern method str.includes(substr, pos) returns true/false depending on whether str contains substr within.
It’s the right choice if we need to test for the match, but don’t need its position
The optional second argument of str.includes is the position to start searching from:

> "Widget".includes("id", 3)
false
> "Widget".includes("id")
true

 includes, startsWith, endsWith
 The methods str.startsWith and str.endsWith do exactly what they say
> "Widget".endsWith("get")
true
> "Widget".endsWith("Wid")
false
> "Widget".startsWith("Wid")
true
> 



Getting a substring
There are 3 methods in JavaScript to get a substring: substring, substr and slice.
str.slice(start [, end])
Returns the part of the string from start to (but not including) end.

> str.slice(-4, -1)
'h i'
> str.slice(0, 5)
'Widge'

str.substring(start [, end])
Returns the part of the string between start and end.
This is almost the same as slice, but it allows start to be greater than end.
Negative arguments are (unlike slice) not supported, they are treated as
> str.substring(6, 2)
'dget'
> str.substring(0, 2)
'Wi'

str.substr(start [, length])
Returns the part of the string from start, with the given length
> str.substr(-4, 2)
'h '
> str.substr(2, 4)
'dget'

Comparing strings-
strings are compared character-by-character in alphabetical order
A lowercase letter is always greater than the uppercase:
> 'a' > 'Z'
true
> 'z' > 'Z'
true
> 'A' > 'Z'
false

Letters with diacritical marks are “out of order”

> 'Österreich' > 'Zealand'
true
> 

str.codePointAt(pos)
Returns the code for the character at position pos
> "z".codePointAt(0)
122
> "za".codePointAt(1)
97
> 

String.fromCodePoint(code)
Creates a character by its numeric codes
>  String.fromCodePoint(90)
'Z'
>  String.fromCodePoint(97)
'a'
> 
The characters are compared by their numeric code. The greater code means that the character is greater. The code for a (97) is greater than the code for Z (90).

All lowercase letters go after uppercase letters because their codes are greater.
Some letters like Ö stand apart from the main alphabet. Here, its code is greater than anything from a to z.


Internals, Unicode-
Surrogate pairs

str.trim() – removes (“trims”) spaces from the beginning and end of the string.
str.repeat(n) – repeats the string n times.



##  Arrays
Objects allow you to store keyed collections of values. But data structure named Array is used to store ordered collections.
> let fruits = ["Apple", "Orange", "Plum"];
undefined
> fruits[0]
'Apple'
> fruits[1]
'Orange'

The total count of the elements in the array is its length
> fruits.length
3

The call to new Array(number) creates an array with the given length, but without elements.

The length property is the array length or, to be precise, its last numeric index plus one. It is auto-adjusted by array methods.
If we shorten length manually, the array is truncated.
Getting the elements:

we can get element by its index, like arr[0]
also we can use at(i) method that allows negative indexes. For negative values of i, it steps back from the end of the array. If i >= 0, it works same as arr[i].
We can use an array as a deque with the following operations:

push(...items) adds items to the end.
pop() removes the element from the end and returns it.
shift() removes the element from the beginning and returns it.
unshift(...items) adds items to the beginning.
To loop over the elements of the array:

for (let i=0; i<arr.length; i++) – works fastest, old-browser-compatible.
for (let item of arr) – the modern syntax for items only,
for (let i in arr) – never use.
To compare arrays, don’t use the == operator (as well as >, < and others), as they have no special treatment for arrays. They handle them as any objects, and it’s not what we usually want.

Instead you can use for..of loop to compare arrays item-by-item.

pop/push, shift.unshift
> fruits
[ 'Apple', 'Orange', 'Plum' ]
> fruits.pop()
'Plum'
> fruits.push()
2
> fruits
[ 'Apple', 'Orange' ]
> fruits.push("Mango")
3
> fruits
[ 'Apple', 'Orange', 'Mango' ]
> 
> fruits.shift()
'Apple'
> fruits
[ 'Orange', 'Mango' ]
> fruits.unshift()
2
> fruits.unshift("APple")
3
> fruits
[ 'APple', 'Orange', 'Mango' ]
> 

Both fruits.pop() and fruits.at(-1) return the last element of the array, but fruits.pop() also modifies the array by removing it.

Internals
Array is an object and thus behaves like an object.
The pop method does not need to move anything, because other elements keep their indexes. That’s why it’s blazingly fast.

## More arrray methods
To add/remove elements:

push(...items) – adds items to the end,
pop() – extracts an item from the end,
shift() – extracts an item from the beginning,
unshift(...items) – adds items to the beginning.
splice(pos, deleteCount, ...items) – at index pos deletes deleteCount elements and inserts items.
> delete fruits[1]
true
delete obj.key removes a value by the key. It’s all it does. Fine for objects. But for arrays we usually want the rest of elements to shift and occupy the freed place. We expect to have a shorter array now.
> fruits.splice(1, 1);
[ <1 empty item> ]
> fruits.splice(1, 2);
[ 'Mango' ]

slice(start, end) – creates a new array, copies elements from index start till end (not inclusive) into it.
concat(...items) – returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken.
To search among elements:

indexOf/lastIndexOf(item, pos) – look for item starting from position pos, return the index or -1 if not found.
includes(value) – returns true if the array has value, otherwise false.
find/filter(func) – filter elements through the function, return first/all values that make it return true.
findIndex is like find, but returns the index instead of a value.
To iterate over elements:

forEach(func) – calls func for every element, does not return anything.
To transform the array:

map(func) – creates a new array from results of calling func for every element.
sort(func) – sorts the array in-place, then returns it.
reverse() – reverses the array in-place, then returns it.
split/join – convert a string to array and back.
reduce/reduceRight(func, initial) – calculate a single value over the array by calling func for each element and passing an intermediate result between the calls.
Additionally:

Array.isArray(value) checks value for being an array, if so returns true, otherwise false.
Please note that methods sort, reverse and splice modify the array itself.

These methods are the most used ones, they cover 99% of use cases. But there are few others:

arr.some(fn)/arr.every(fn) check the array.

The function fn is called on each element of the array similar to map. If any/all results are true, returns true, otherwise false.

These methods behave sort of like || and && operators: if fn returns a truthy value, arr.some() immediately returns true and stops iterating over the rest of items; if fn returns a falsy value, arr.every() immediately returns false and stops iterating over the rest of items as well.

We can use every to compare arrays:

function arraysEqual(arr1, arr2) {
  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
}

alert( arraysEqual([1, 2], [1, 2])); // true
arr.fill(value, start, end) – fills the array with repeating value from index start to end.

arr.copyWithin(target, start, end) – copies its elements from position start till position end into itself, at position target (overwrites existing).

arr.flat(depth)/arr.flatMap(fn) create a new flat array from a multidimensional array.



## Browser environment, specs
The Document Object Model, or DOM for short, represents all page content as objects that can be modified.
The document object is the main “entry point” to the page. We can change or create anything on the page using it.

BOM (Browser Object Model)
The Browser Object Model (BOM) represents additional objects provided by the browser (host environment) for working with everything except the document.
