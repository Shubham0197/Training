JavaScript was initially created to “make web pages alive
The program Written are called scripts.That can be written with HTMLand run automatically as page loads

Today, JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.

The browser has an embedded engine sometimes called a “JavaScript virtual machine”.

Different engines have different “codenames”. For example:

V8 – in Chrome, Opera and Edge.
SpiderMonkey – in Firefox.

How do engines work?
Engines are complicated. But the basics are easy.

The engine (embedded if it’s a browser) reads (“parses”) the script.
Then it converts (“compiles”) the script to the machine language.
And then the machine code runs, pretty fast.
The engine applies optimizations at each step of the process. It even watches the compiled script as it runs, analyzes the data that flows through it, and further optimizes the machine code based on that knowledge.
There are at least three great things about JavaScript:
Full integration with HTML/CSS.
Simple things are done simply.
Supported by all major browsers and enabled by default.

Modern Java Script is safe as it does not provide access to low level access to memory or cpu.

JavaScript 

a. Can do in browser
Add new HTML to the page, change the existing content, modify styles.
React to user actions, run on mouse clicks, pointer movements, key presses.
Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
Get and set cookies, ask questions to the visitor, show messages.
Remember the data on the client-side (“local storage”).

b. Cant do in browser
In the interest of user security, JavaScript's capabilities in the browser are constrained. The objective is to stop a malicious webpage from accessing personal data or damaging the user's data.

JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS functions.

Modern browsers allow it to work with files, but the access is limited and only provided if the user does certain actions, like “dropping” a file into a browser window or selecting it via an <input> tag.

There are ways to interact with camera/microphone and other devices, but they require a user’s explicit permission. So a JavaScript-enabled page may not sneakily enable a web-camera, observe the surroundings and send the information to the NSA.

Different tabs/windows generally do not know about each other. Sometimes they do, for example when one window uses JavaScript to open the other one. But even in this case, JavaScript from one page may not access the other if they come from different sites (from a different domain, protocol or port).

This is called the “Same Origin Policy”. To work around that, both pages must agree for data exchange and contain a special JavaScript code that handles it. We’ll cover that in the tutorial.

This limitation is, again, for the user’s safety. A page from http://anysite.com which a user has opened must not be able to access another browser tab with the URL http://gmail.com and steal information from there.

JavaScript can easily communicate over the net to the server where the current page came from. But its ability to receive data from other sites/domains is crippled. Though possible, it requires explicit agreement (expressed in HTTP headers) from the remote side. Once again, that’s a safety limitation.


Specification
The ECMA-262 specification contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.

Developer tools allow us to see errors, run commands, examine variables, and much more.
They can be opened with F12 for most browsers on Windows. Chrome for Mac needs Cmd+Opt+J, Safari: Cmd+Opt+C (need to enable first).


To run javascript code in the browser can write html code with javascript embedded in it.


Code Structure

can use ; after every line to indicate that the line is ended and to make code more readable but it not necessary for case of line breaks exists
 JavaScript interprets the line break as an “implicit” semicolon. This is called an automatic semicolon insertion.
 But it is not always that it runs perfectly wihtout ; so no ; may lead to error in code.
 

 Comments
One-line comments start with two forward slash characters //.
alert('World'); // This comment follows the statement

Multiline comments start with a forward slash and an asterisk /* and end with an asterisk and a forward slash */.
Shrtcut to add 
In most editors, a line of code can be commented out by pressing the Ctrl+/ hotkey for a single-line comment and something like Ctrl+Shift+/ – for multiline comments (select a piece of code and press the hotkey).



## special directive: "use strict".

For a long time, JavaScript evolved without compatibility issues. New features were added to the language while old functionality didn’t change.

That had the benefit of never breaking existing code. But the downside was that any mistake or an imperfect decision made by JavaScript’s creators got stuck in the language forever.

This was the case until 2009 when ECMAScript 5 (ES5) appeared. It added new features to the language and modified some of the existing ones. To keep the old code working, most such modifications are off by default. You need to explicitly enable them with a special directive: "use strict".

The directive looks like a string: "use strict" or 'use strict'. When it is located at the top of a script, the whole script works the “modern” way.

Modern JavaScript supports “classes” and “modules” – advanced language structures (we’ll surely get to them), that enable use strict automatically. So we don’t need to add the "use strict" directive, if we use them.

So, for now "use strict"; is a welcome guest at the top of your scripts. Later, when your code is all in classes and modules, you may omit it.


## Variables

A variable is a “named storage” for data
to create variable have to use let keyword before that have to use var keyword there  is subtle differences between let and var.

let user = 'John'
  , age = 25
  , message = 'Hello';

  can not initialize the same variable twice

let user = 123;
let user = 1222;
will get error

Variable naming
There are two limitations on variable names in JavaScript:

The name must contain only letters, digits, or the symbols $ and _.
The first character must not be a digit.

Constants
To declare a constant (unchanging) variable, use const instead of let.
As the name suggests they are constants. They cannot be reassigned. An attempt to do so would cause an error
There is a widespread practice to use constants as aliases for difficult-to-remember values that are known prior to execution. 
const PI = 3.14;

Name things right
Talking about variables, there’s one more extremely important thing.

A variable name should have a clean, obvious meaning, describing the data that it stores.

Variable naming is one of the most important and complex skills in programming. A quick glance at variable names can reveal which code was written by a beginner versus an experienced developer.

Data types in javascript
There are eight basic data types in JavaScript.
number -  integer and floating point numbers
BigInt  -- for more than number range like entire range of really big integers, e.g. for cryptography   
          or microsecond-precision timestamps.
string -  anything surrounded by quotes
boolean - type has only two values: true and false
null  -  value does not belong to any of the types described above
undefined - is “value is not assigned”.
symbol - for unique identifiers
object -they  are used to store collections of data and more complex entities


The typeof operator returns the type of the argument. It’s useful when we want to process values of different types differently or just want to do a quick check.

typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"


## Interaction: alert, prompt, confirm

=> alert-  It shows a message and waits for the user to press “OK”.

=> prompt - The function prompt accepts two arguments
eg.
result = prompt(title, [default]);
will accept 2 variables -
title -The text to show the visitor.
default - An optional second parameter, the initial value for the input field.


=> confirm shows a modal window with a question and two buttons: OK and Cancel.

but there are two limitations shared by all the methods above:

The exact location of the modal window is determined by the browser. Usually, it’s in the center.
The exact look of the window also depends on the browser. We can’t modify it.

## Type Conversions
operators and functions automatically convert the values given to them to the right type as needed by them 
different types of cenversion are 
String Conversion - Occurs when we output something. Can be performed with String(value). The conversion to string is usually obvious for primitive values.
Numeric Conversion - Occurs in math operations. Can be performed with Number(value).
Boolean Conversion -  Occurs in logical operations. Can be performed with Boolean(value).
for boolean conversion
Value	                        Becomes…
0, null, undefined, NaN, "" 	false
any other value	              true


## Basic operators, maths
 things like addition +, multiplication *, subtraction -, and so on.

 The following math operations are supported:

Addition +,
Subtraction -,
Multiplication *,
Division /,
Remainder %,
Exponentiation **.

Operator precedence
If an expression has more than one operator, the execution order is defined by their precedence, or, in other words, the default priority order of operators

Precedence	Name	Sign
…	…	…
15	unary plus	+
15	unary negation	- =>  unary negation - reverses the sign of a number:
14	exponentiation	**
13	multiplication	*
13	division	/
12	addition	+
12	subtraction	-
…	…	…
2	assignment	=

The unary plus doesn’t do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.


Assignment = returns a value
and there is also Another interesting feature is the ability to chain assignments

can also chain the assignments, 
Modify-in-place(n = n + 5;) also  notation can be shortened using the operators += and *=
Increment ++ increases a variable by 1
Decrement -- decreases a variable by 1
The operators ++ and -- can be placed either before or after a variable.
When the operator goes after the variable, it is in “postfix form”: counter++.
The “prefix form” is when the operator goes before the variable: ++counter


Bitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.
These operators are not JavaScript-specific. They are supported in most programming languages.
The list of operators:
AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )

The comma operator ,  = it’s used to write shorter codes , it has very low precedence

## Comparison
Greater/less than: a > b, a < b.
Greater/less than or equals: a >= b, a <= b.
Equals: a == b, please note the double equality sign == means the equality test, while a single one a = b means an assignment.


All comparison operators return a boolean value:

true – means “yes”, “correct” or “the truth”.
false – means “no”, “wrong” or “not the truth”.

To see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order.
alert( 'Glow' > 'Glee' ); // true

When comparing values of different types, JavaScript converts the values to numbers.
alert( '2' > 1 );

A regular equality check == has a problem. It cannot differentiate 0 from false

Null and undefined are very strange while using coomparision
Treat any comparison with undefined/null except the strict equality === with exceptional care.
Don’t use comparisons >= > < <= with a variable which may be null/undefined, unless you’re really sure of what you’re doing. If a variable can have these values, check for them separately.



## Conditional branching: if, '?'

The “if” statement - The if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of code.

Boolean conversion- The if (…) statement evaluates the expression in its parentheses and converts the result to a boolean.So ->
A number 0, an empty string "", null, undefined, and NaN all become false. Because of that they are called “falsy” values.
Other values become true, so they are called “truthy”

The “else” clause - The if statement may contain an optional “else” block. It executes when the condition is falsy.

Several conditions: “else if” -  Can nest the if else condition . to test several variants of a condition. The else if clause lets us do that. by chaining in else using else if

Conditional operator ‘?’- The operator is represented by a question mark ?. Sometimes it’s called “ternary”, because the operator has three operands
let result = condition ? value1 : value2;

Multiple ‘?’- A sequence of question mark operators ? can return a value that depends on more than one condition. its like switch case
let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';

Non-traditional use of ‘?’ - Sometimes the question mark ? is used as a replacement for if
(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');

## Logical operators

There are four logical operators in JavaScript: || (OR), && (AND), ! (NOT), ?? (Nullish Coalescing)

|| (OR) - If any of its arguments are true, it returns true, otherwise it returns false

OR "||" finds the first truthy value

&& (AND) Evaluates operands from left to right.
For each operand, converts it to boolean. If the result is true, stops and returns the original value of that operand.

AND “&&” finds the first falsy value
 Given multiple AND’ed values:
result = value1 && value2 && value3;
The AND && operator does the following:
Evaluates operands from left to right.
For each operand, converts it to a boolean. If the result is false, stops and returns the original value of that operand.
Incase of alert if the first operand is truthy,AND returns the second operand
and if the first operand is falsy, AND returns it. The second operand is ignored

! (NOT)
The operator accepts a single argument and does the following
Converts the operand to boolean type: true/false.
Returns the inverse value.


## Nullish coalescing operator '??'
The result of a ?? b is:

if a is defined, then a,
if a isn’t defined, then b

it treats null and undefined similarly

result = a ?? b is similiar to result = (a !== null && a !== undefined) ? a : b;

The important difference between ?? and ||:

|| returns the first truthy value.
?? returns the first defined value.

The precedence of the ?? operator is the same as ||. They both equal 4

Due to safety reasons, JavaScript forbids using ?? together with && and || operators, unless the precedence is explicitly specified with parentheses.

## Loops while and for
The “while” loop
while (condition) {
  // code
  // so-called "loop body"
}

The “do…while” loop
do {
  // loop body
} while (condition);

The “for” loop
for (begin; condition; step) {
  // ... loop body ...
}

Breaking the loop
Normally, a loop exits when its condition becomes falsy.
But we can force the exit at any time using the special break directive.

Continue to the next iteration
The continue directive is a “lighter version” of break. It doesn’t stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).

Labels for break/continue
If we want to break from multiple loop have to use the label name to specify so that we can specify specifically from whcih loop we need to break or continue the next operation from.
labelName: for (...) {
  ...
}


## Switch Case

A switch statement can replace multiple if checks.
The switch has one or more case blocks and an optional default.
Breaks are inmoprtant If there is no break then the execution continues with the next case without any checks.
Any expression can be a switch/case argument
Several variants of case which share the same code can be grouped.
Type matters -  The values must be of the same type to match

## Functions

Function Declaration
To create a function we can use a function declaration.
Syntax
function name(parameter1, parameter2, ... parameterN) {
  ...body...
}



Local variables - A variable declared inside a function is only visible inside that function.

Outer variables - A function can access an outer variable as well which are not declared in the function

Parameters - pass arbitrary data to functions using parameters

Default values - If a function is called, but an argument is not provided, then the corresponding value becomes undefined. So while creating function we can give the parameters the value to default to is no value is passed while calling funtion.

Returning a value - A function can return a value back into the calling code as the result.
The directive return can be in any place of the function. When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to result above).
It is possible to use return without a value. That causes the function to exit immediately.

Naming a function -Functions are actions. So their name is usually a verb. 
It should be brief, as accurate as possible and describe what the function does, so that someone reading the code gets an indication of what the function does.

Functions == Comments - Functions should be short and do exactly one thing.
A separate function is not only easier to test and debug – its very existence is a great comment!



## Function expressions
Function is a value
Syntax for creating a function that is called a Function Expression

Callback functions
We can send the funtion as the parameters to another funtion and then that function can be called in that function
Function declared in the calling statement of another function as they have no name, and so are called anonymous.

Function Expression vs Function Declaration
Function Declaration: a function, declared as a separate statement, in the main code flow
Function Expression: a function, created inside an expression or inside another syntax construct. Here, the function is created on the right side of the “assignment expression” =
A Function Expression is created when the execution reaches it and is usable only from that moment.
but A Function Declaration can be called earlier than it is defined

Function Declaration is only visible inside the code block in which it resides
So as to make that function be visible outside then the approach would be to use a Function Expression and assign function to the variable that is declared outside of block and has the proper visibility.


## Arrow functions, the basics
another very simple and concise syntax for creating functions, that’s often better than Function Expressions.It’s called “arrow functions”
Syntax
let func = (arg1, arg2, ..., argN) => expression;
let sum = (a, b) => a + b;

If there are no arguments, parentheses are empty, but they must be present:
let sayHi = () => alert("Hello!");

to dynamically create a function.eg. ->
let welcome = (age < 18) ?
  () => alert('Hello!') :
  () => alert("Greetings!");

Multiline arrow functions
With curly braces: (...args) => { body } – brackets allow us to write multiple statements inside the function, but we need an explicit return to return something.

Debugging in the browser
Debugging is the process of finding and fixing errors within a script.


The “Sources” panel
Turn on developer tools with F12
Select the Sources panel.
The Sources panel has 3 parts:
The File Navigator pane lists HTML, JavaScript, CSS and other files, including images that are attached to the page. Chrome extensions may appear here too.
The Code Editor pane shows the source code.
The JavaScript Debugging pane is for debugging, we’ll explore it soon.

Console- In sources panel If we press Esc, then a console opens below. We can type commands there and press Enter to execute.


Breakpoints - A breakpoint is a point of code where the debugger will automatically pause the JavaScript execution.In the sources click on the line number to create breakpoints.

The command “debugger”
We can also pause the code by using the debugger command in it

Pause and look around- while in the sources pane
Please open the informational dropdowns to the right (labeled with arrows). They allow you to examine the current code state:
Watch – shows current values for any expressions.
You can click the plus + and input an expression. The debugger will show its value, automatically recalculating it in the process of execution.
Call Stack – shows the nested calls chain.
At the current moment the debugger is inside hello() call, called by a script in index.html (no function there, so it’s called “anonymous”).
click on a stack item (e.g. “anonymous”), the debugger jumps to the corresponding code, and all its variables can be examined as well.
Scope – current variables.
Local shows local function variables. You can also see their values highlighted right over the source.
Global has global variables (out of any functions). \


Tracing the execution - After stoppin have to execute the command by “Resume”: continue the execution, hotkey F8.
And If there are no additional breakpoints, then the execution just continues and the debugger loses control.
“Step”: run the next command, hotkey F9.
“Step over”: run the next command, but don’t go into a function, hotkey F10.
“Step into”, hotkey F11. similar to “Step”, but behaves differently in case of asynchronous function calls
“Step out”: continue the execution till the end of the current function, hotkey Shift+F11.


Logging - To output something to console from our code, there’s console.log function.
To see it, either open the Console panel of developer tools or press Esc while in another panel: that opens the console at the bottom


## Coding style




## Comments

comments can be single-line: starting with // and multiline: /* ... */.
Do not  use comments to explain “what is going on in the code”.donot make comment to  tell “how code works” and “what it does”.
Recipe: factor out functions, Sometimes it’s beneficial to replace a code piece with a function

Good Comments
Describe the architecture
Document function parameters and usage
Can explain Why is the task solved this way?
Also, If the code has anything subtle and counter-intuitive, it’s definitely worth commenting.


## Polyfills and transpilers

Transpilers
A transpiler is a special piece of software that translates source code to another source code. 
It can parse (“read and understand”) modern code and rewrite it using older syntax constructs, so that it’ll also work in outdated engines.


Polyfills
If there is only introduction of  new functions, not syntax changes, there’s no need to transpile anything here. We just need to declare the missing function.
A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations.

