Active Records Associations
In Rails, an association is a connection between two Active Record models
With Active Record associations, we can streamline  operations by declaratively telling Rails that there is a connection between the two models

The Types of Associations
Rails supports six types of associations:

belongs_to
has_one
has_many
has_many :through
has_one :through
has_and_belongs_to_many

belong _to associations
it sets up a connection with another model,
 such that each instance of the declaring model
 "belongs to" one instance of the other model.
 When used alone, belongs_to produces a one-directional one-to-one connection. 
 belongs_to does not ensure reference consistency, 
 so depending on the use case, you might also need to add a database-level 
 foreign key constraint on the reference column,

The has_one Association
A has_one association indicates that one other model has a reference to this model. 
That model can be fetched through this association.

The has_many Association
A has_many association is similar to has_one, but indicates a one-to-many connection with another model.

The has_many :through Association
A has_many :through association is often used to set up a many-to-many connection with another model.
This association indicates that the declaring model can be matched with zero or more instances of another model by proceeding through a third model.
Can break all object relation with each other

## belongs to
gives foreign key
t.belongs_to :table_name
t.references :table_name 

belongs_to is singular so have to give table name singular

post.author / reads the author that post belongs to 
post.author = / assigns the author that post will belong to or set the author
will gives the category id by default to products while ceating new object of product
3.0.0 :011 > product = category.products.new
 => 
#<Product:0x00007f2c049f86c0                                
...  
3.0.0 :013 > product
 => 
#<Product:0x0000561e6ccfdb78                                
 id: nil,                                                   
 name: nil,                                                 
 price: 0.1e3,                                              
 category_id: 1,                                            
 description: nil>

 3.0.0 :018 > Product.all
  Product Load (0.2ms)  SELECT "products".* FROM "products"
 =>                                                         
[#<Product:0x0000561e6dbc0a48                               
  id: 1,                                                    
  name: nil,                                                
  price: 0.12334e3,                                         
  category_id: nil,       
  description: nil>,      
 #<Product:0x0000561e6dbc0908
  id: 2,                  
  name: nil,              
  price: 0.12334e3,
  category_id: nil,
  description: nil>,
 #<Product:0x0000561e6dbc0840
  id: 3,
  name: nil,
  price: 0.12212e3,
  category_id: nil,
  description: nil>,
 #<Product:0x0000561e6dbc0778
  id: 4,
  name: "mobile",
  price: 0.1e3,
  category_id: 1,
  description: nil>] 


now after the associations are give it will not add new record of object with out category id

3.0.0 :020 > product.name = "Mobile MI"
 => "Mobile MI" 
3.0.0 :021 > product.save!
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/validations.rb:80:in `raise_validation_error': Validation failed: Category must exist (ActiveRecord::RecordInvalid)   

Appending to the category new associations

3.0.0 :022 > category.products << product
  TRANSACTION (0.1ms)  BEGIN
  Product Create (0.2ms)  INSERT INTO "products" ("name", "price", "category_id", "description") VALUES ($1, $2, $3, $4) RETURNING "id"  [["name", "Mobile MI"], ["price", "100.0"], ["category_id", 1], ["description", nil]]                  
  TRANSACTION (6.6ms)  COMMIT                               
  Product Load (0.1ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1  [["category_id", 1]]   
 =>                                                         
[#<Product:0x0000561e6ccfdb78                               
  id: 4,                                                    
  name: "mobile",                                           
  price: 0.1e3,
  category_id: 1,
  description: nil>,
 #<Product:0x0000561e6d567480
  id: 5,
  name: "Mobile MI",
  price: 0.1e3,
  category_id: 1,
  description: nil>,
 #<Product:0x0000561e6cd87710
  id: nil,
  name: nil,
  price: 0.1e3,
  category_id: 1,
  description: nil>,
 #<Product:0x00007f2c049f86c0
  id: nil,
  name: nil,
  price: 0.1e3,
  category_id: 1,
  description: nil>] 

  To check whether if the associations has empty belongs_to
  3.0.0 :023 > category.products.empty?
 => false
but when created new it shows empty? = true
 3.0.0 :025 > category2.products.empty?
  Product Exists? (0.3ms)  SELECT 1 AS one FROM "products" WHERE "products"."category_id" = $1 LIMIT $2  [["category_id", 2], ["LIMIT", 1]]                                         
 => true   


To see all the associations use of size options

3.0.0 :026 > category2.products.size
  Product Count (2.4ms)  SELECT COUNT(*) FROM "products" WHERE "products"."category_id" = $1  [["category_id", 2]]      
 => 0                                                       
3.0.0 :027 > category.products.size
 => 4 

To see all the associations of the category in prodcts table record

3.0.0 :028 > category.products.all
  Product Load (0.2ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1  [["category_id", 1]]   
 =>                                                         
[#<Product:0x0000561e6dbe3688                               
  id: 4,                                                    
  name: "mobile",                                           
  price: 0.1e3,                                             
  category_id: 1,                                           
  description: nil>,                                        
 #<Product:0x0000561e6dbe3390                               
  id: 5,                                                    
  name: "Mobile MI",                                        
  price: 0.1e3,
  category_id: 1,
  description: nil>] 


Above method will give the array of records if saved in different variable 

3.0.0 :032 > product_electronics = category.products.all
  Product Load (0.3ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1  [["category_id", 1]]   
 =>                                                         
[#<Product:0x0000561e6d5fdb10                               
... 

3.0.0 :044 > product_electronics.class
 => Product::ActiveRecord_AssociationRelation 

but if used first option

3.0.0 :045 > product_electronics = category.products.all.fir
st
  Product Load (0.2ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1 ORDER BY "products"."id" ASC LIMIT $2  [["category_id", 1], ["LIMIT", 1]]           
 =>                                                         
#<Product:0x00007f2c04bfd1c8                                
...  

it will create object with product class
3.0.0 :046 > product_electronics.class
 => Product(id: integer, name: text, price: decimal, category_id: integer, description: string) 
 all variables  are directly accessible

3.0.0 :047 > category2.products.create(:name => "Jeans")
  TRANSACTION (0.1ms)  BEGIN
  Product Create (0.2ms)  INSERT INTO "products" ("name", "price", "category_id", "description") VALUES ($1, $2, $3, $4) RETURNING "id"  [["name", "Jeans"], ["price", "100.0"], ["category_id", 2], ["description", nil]]                      
  TRANSACTION (6.6ms)  COMMIT                               
 =>                                                         
#<Product:0x0000561e6dc300f0                                
 id: 6,                                                     
 name: "Jeans",                                             
 price: 0.1e3,                                              
 category_id: 2,                                            
 description: nil> 

Delete the assiciations only
3.0.0 :051 > category2.products.delete(1)
  Product Delete All (0.7ms)  DELETE FROM "products" WHERE "products"."category_id" = $1 AND "products"."id" = $2  [["category_id", 2], ["id", 1]]                                  
 => 0                                                       
3.0.0 :052 > category2.products.delete(6)
  Product Delete All (6.9ms)  DELETE FROM "products" WHERE "products"."category_id" = $1 AND "products"."id" = $2  [["category_id", 2], ["id", 6]]                                  
 => 1     

 3 Tips, Tricks, and Warnings
  know to make efficient use of Active Record associations

Controlling caching
Avoiding name collisions
Updating the schema
Controlling association scope
Bi-directional associations                                                  

1 Controlling Caching
All of the association methods are built around caching, which keeps the result of the most recent query available for further operations. 
The cache is even shared across methods.

If there some changes int he database but the data we have asscessed have been cached we want to get the latest cope instead of cached one we will use 
reload option
3.0.0 :053 > category.products.load
 => 
[#<Product:0x0000561e6ccfdb78                               
  id: 4,                                                    
  name: "mobile",                                           
  price: 0.1e3,                                             
  category_id: 1,                                           
  description: nil>,                                        
 #<Product:0x0000561e6d567480                               
  id: 5,                                                    
  name: "Mobile MI",                                        
  price: 0.1e3,                                             
  category_id: 1,                                           
  description: nil>,
3.0.0 :054 > category.products.load
 => 
[#<Product:0x0000561e6ccfdb78                               
  id: 4,                                                    
  name: "mobile",                                           
  price: 0.1e3,                                             
  category_id: 1,                                           
  description: nil>,                                        
 #<Product:0x0000561e6d567480                               
  id: 5,                                                    
  name: "Mobile MI",                                        
  price: 0.1e3,                                             
  category_id: 1,                                           
  description: nil>,
  id: nil,
  price: 0.1e3,
  description: nil>,
 #<Product:0x00007f2c049f86c0
  id: nil,
  name: nil,
  price: 0.1e3,
  category_id: 1,
  description: nil>] 

## Added new object

3.0.0 :002 > category.products.create(:name => "Earphone")
  TRANSACTION (0.1ms)  BEGIN
  Product Create (0.2ms)  INSERT INTO "products" ("name", "price", "category_id", "description") VALUES ($1, $2, $3, $4) RETURNING "id"  [["name", "Earphone"], ["price", "100.0"], ["category_id", 1], ["description", nil]]                   
  TRANSACTION (6.5ms)  COMMIT                               
 =>                                                         
#<Product:0x000055af9dcf4fc0                                
 id: 7,                                                     
 name: "Earphone",                                          
 price: 0.1e3,                                              
 category_id: 1,                                            
 description: nil>

## but load still is cached 
##so have to reload

3.0.0 :053 > category.products.load
 => 
[#<Product:0x0000561e6ccfdb78                               
  id: 4,                                                    
  name: "mobile",                                           
  price: 0.1e3,                                             
  category_id: 1,                                           
  description: nil>,                                        
 #<Product:0x0000561e6d567480                               
  id: 5,                                                    
  name: "Mobile MI",                                        
  price: 0.1e3,                                             
  category_id: 1,                                           
  description: nil>,
3.0.0 :054 > category.products.load
 => 
[#<Product:0x0000561e6ccfdb78                               
  id: 4,                                                    
  name: "mobile",                                           
  price: 0.1e3,                                             
  category_id: 1,                                           
  description: nil>,                                        
 #<Product:0x0000561e6d567480                               
  id: 5,                                                    
  name: "Mobile MI",                                        
  price: 0.1e3,                                             
  category_id: 1,                                           
  description: nil>,
  id: nil,
  price: 0.1e3,
  description: nil>,
 #<Product:0x00007f2c049f86c0
  id: nil,
  name: nil,
  price: 0.1e3,
  category_id: 1,
  description: nil>] 

  ## After reloading got new data


3.0.0 :055 > category.products.reload
  Product Load (0.2ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1  [["category_id", 1]]   
 =>                                                         
[#<Product:0x0000561e6d3ecdf8                               
  id: 4,                                                    
  name: "mobile",                                           
  price: 0.1e3,                                             
  category_id: 1,                                           
  description: nil>,                                        
 #<Product:0x0000561e6d3ecc68                               
  id: 5,                                                    
  name: "Mobile MI",                                        
  price: 0.1e3,
  category_id: 1,
  description: nil>,
 #<Product:0x0000561e6d3ecad8
  id: 7,
  name: "Earphone",
  price: 0.1e3,
  category_id: 1,
  description: nil>] 

  so got the new data

2 Avoiding Name Collisions
It is a bad idea to give an association a name that is already used for an instance method of ActiveRecord::Base. 
The association method would override the base method and break things. 
For instance, attributes or connection are bad names for associations.

3 Updating the Schema
Responsible for maintaining your database schema to match your associations.
Like
1. For belongs_to associations you need to create foreign keys
2. for has_and_belongs_to_many associations you need to create the appropriate join table

1 Creating Foreign Keys for belongs_to Associations
When you declare a belongs_to association, you need to create foreign keys as appropriate. 
either when creating table via t.refrence :table_name
or add through migrations
add_reference :table_name, :table_name

It only creates for rails 
So ,if you wish to enforce referential integrity at the database level, add the foreign_key: true option to the ‘reference’ column declarations above.

2 Creating Join Tables for has_and_belongs_to_many Associations
For a has_and_belongs_to_many association, you need to explicitly create the joining table
Unless the name of the join table is explicitly specified by using the :join_table option, 
Active Record creates the name by using the lexical order of the class names. 
So a join between author and book models will give the default join table name of "authors_books" because "a" outranks "b" in lexical ordering.
So we  must manually generate the join table with an appropriate migration.And this his table should be created without a primary key.

class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[7.0]
  def change
    create_table :assemblies_parts, id: false do |t|
      t.bigint :assembly_id
      t.bigint :part_id
    end

    add_index :assemblies_parts, :assembly_id
    add_index :assemblies_parts, :part_id
  end
end

We pass id: false to create_table because that table does not represent a model. 
That's required for the association to work properly. 

4 Controlling Association Scope

By default, associations look for objects only within the current module's scope. This can be important when you declare Active Record models within a module
To associate a model with a model in a different namespace, you must specify the complete class name in your association declaration like
class_name: "MyApplication::Billing::Account"


5 Bi-directional Associations
For working of associations to work it needs to declaration on two different models for the association to make sense
Active Record supports automatic identification for most associations with standard names. 
However, Active Record will not automatically identify bi-directional associations that contain the :through or :foreign_key options

class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end

as the :write is given so author to book associations is not ok but book to author is  so have  to specify in author that book will look for :writer with the help of inverse_of :writer option
class Author < ApplicationRecord
  has_many :books, inverse_of: 'writer'
end

and the association will make sense for rails.
---------------------------------------------------------------------------------------------
## Choosing Between belongs_to and has_one
IN case of one to one relationship  where to put has_one and belongs to association
as belongs to goes to moldel where foreign key is defined so have to choose where foreign key is defined.
So here it makes sense to add foreign key to relation where it is not fully dependendent attribute 

---------------------------------------------------------------------------------------------
1 belongs_to Association
belongs_to association says that this model's table contains a column which represents a reference to another table. 
1 Methods Added by belongs_to
the declaring class automatically gains 8 methods related to the association
association
association=(associate)
build_association(attributes = {})
create_association(attributes = {})
create_association!(attributes = {})
reload_association
association_changed?
association_previously_changed?
In all of these methods, association is replaced with the symbol passed as the first argument to belongs_to. so in case of  belongs_to :author
the methods becomes 

author
author=
build_author
create_author
create_author!
reload_author
author_changed?
author_previously_changed?

1 association- 
The association method returns the associated object
3.0.0 :003 > category2.products
  Product Load (0.3ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1  [["category_id", 2]]
 => []                                                               
3.0.0 :004 > 
2 association=(associate)
The association= method assigns an associated object to this object.
3.0.0 :013 > product1.category= category2
 => #<Category:0x0000558fc833c6d0 id: 2, name: "clothes", description: nil>
 3.0.0 :014 > product1
 => #<Product:0x0000558fc82d4cb0 id: 2, name: nil, price: 0.12334e3, category_id: 2, description: nil>  

3 build_association(attributes = {})
The build_association method returns a new object of the associated type. But does not save the onbject will have to save using save method


3.0.0 :028 > category = product1.build_category(name: "computers")
 => #<Category:0x00007f4b285418c8 id: nil, name: "computers", description: nil> 

4 create_association(attributes = {})
it returns a new object of the associated type.  And also save the object by default.if any validaton fails
will only retun object but not any error
3.0.0 :032 > category = product1.create_category(name: "computers")
 => #<Category:0x00007f4b284fc610 id: nil, name: "computers", description: nil> 
validation failed

3.0.0 :033 > category = product1.create_category(name: "electronics")
  TRANSACTION (0.1ms)  BEGIN
  Category Create (7.4ms)  INSERT INTO "categories" ("name", "description") VALUES ($1, $2) RETURNING "id"  [["name", "electronics"], ["description", nil]]                                          
  TRANSACTION (0.9ms)  COMMIT                                              
 => #<Category:0x0000558fc8211e90 id: 3, name: "electronics", description: nil> 


5 create_association!(attributes = {})
Does the same as create_association above, but raises ActiveRecord::RecordInvalid if the record is invalid.
3.0.0 :034 > category = product1.create_category!(name: "computers")
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/associations/singular_association.rb:60:in `_create_record': Validation failed: Name is not included in the list (ActiveRecord::RecordInvalid)
3.0.0 :035 > category = product1.create_category!(name: "electronics")
  TRANSACTION (0.2ms)  BEGIN
  Category Create (0.3ms)  INSERT INTO "categories" ("name", "description") VALUES ($1, $2) RETURNING "id"  [["name", "electronics"], ["description", nil]]
  TRANSACTION (1.4ms)  COMMIT
 => #<Category:0x00007f4b285d1338 id: 4, name: "electronics", description: nil> 

6 association_changed?
The association_changed? method returns true if a new associated object has been assigned and the foreign key will be updated in the next save.
3.0.0 :020 > category1 = Category.find(1)
  Category Load (0.3ms)  SELECT "categories".* FROM "categories" WHERE "categories"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                                                     
 => #<Category:0x00007f4b28664138 id: 1, name: "electronics", description: nil> 
 3.0.0 :021 > product1.category_changed?
 => false 
 3.0.0 :022 > product1.category= category1
 => #<Category:0x00007f4b28664138 id: 1, name: "electronics", description: nil> 
3.0.0 :023 > product1.category_changed?
 => true 
 3.0.0 :024 > product1.save!
  TRANSACTION (0.4ms)  BEGIN
  Product Update (0.7ms)  UPDATE "products" SET "category_id" = $1 WHERE "products"."id" = $2  [["category_id", 1], ["id", 2]]                                                            
  TRANSACTION (6.8ms)  COMMIT                                   
 => true                                                        
3.0.0 :025 > product1.category_changed?
 => false 

7 association_previously_changed?
The association_previously_changed? method returns true if the previous save updated the association to reference a new associate object.
3.0.0 :014 > product1.category= category2
 => #<Category:0x0000558fc833c6d0 id: 2, name: "clothes", description: nil> 
3.0.0 :015 > product1.save!
 => true 
3.0.0 :016 > product1.category_previously_changed?
 => true 
3.0.0 :017 > product1.category= category2
 => #<Category:0x0000558fc833c6d0 id: 2, name: "clothes", description: nil> 
3.0.0 :018 > product1.save!
 => true 
3.0.0 :019 > product1.category_previously_changed?
 => false 

8 reload_Associations
It reloads the cache and get the latest data from the database .


## Options for belongs_to

when to customize the behavior of the belongs_to association reference have to pass options to do 
different from default behaviour 
Which can be done by passing options and scope blocks while creating the association.

The belongs_to association supports these options:

:autosave
:class_name
:counter_cache
:dependent
:foreign_key
:primary_key
:inverse_of
:polymorphic
:touch
:validate
:optional

1 :autosave
Rails will save any loaded association members and destroy members that are marked for destruction whenever you save the parent object.
:autosave to false is not the same as not setting the :autosave option
If the option is not present, then new associated objects will be saved, but updated associated objects will not be saved.

2. :class_name
:class_name option to supply the model name if the name of the other model cannot be derived from the association name
3.0.0 :006 > cert = Certified.find(1)
  Certified Load (0.5ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                              
 =>                                         
#<Certified:0x0000558200d7ab40              
... 
3.0.0 :007 > cert.pilots
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                  
 =>                                         
#<Employee:0x0000558201258400               
 id: 1,
 name: "Ajay",
 salary: 30000,
 mobile_number: "123456789",
 DOB: nil,
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00> 

3. foreign_key
By convention, Rails assumes that the column used to hold the foreign key on this model is the name of the association with the suffix _id added.
 The :foreign_key option lets you set the name of the foreign key directly.
 rails donot create foreign key by default migrations do so have to do it manually .

4. :counter_cache
The :counter_cache option can be used to make finding the number of belonging objects more efficient.
It makes the count be stod in varialbe than to run count(*) every time in the database.
It return that value in response to the size method.
The :counter_cache option is specified on the model that includes the belongs_to declaration, 
the actual column must be added to the associated (has_many) model.
Also can override the default column name by specifying a custom column name in the counter_cache declaration instead of true.
 Counter cache columns are added to the containing model's list of read-only attributes through attr_readonly.
Employee.find_each { |emp| Employee.reset_counters(emp.id, :certifieds) }
to run for existing data to update the counters

3.0.0 :004 > pilot.certifieds.size
  Certified Count (0.5ms)  SELECT COUNT(*) FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 1]]                                                                                   
 => 4 
 working for default variable but not for different one ????    
 3.0.0 :002 > aircraft.certifieds.size
 => 1 


5. :dependent
 It creates some behavior for the model to do for certain actions
 
:destroy, when the object is destroyed, destroy will be called on its associated objects.

:delete, when the object is destroyed, all its associated objects will be deleted directly from the database without calling their destroy method.

:destroy_async: when the object is destroyed, an ActiveRecord::DestroyAssociationAsyncJob job is enqueued which will call destroy on its associated objects. Active Job must be set up for this to work. 

destroy vs delete 
Basically "delete" sends a query directly to the database to delete the record. In that case Rails doesn't know what attributes are in the record it is deleting nor if there are any callbacks (such as before_destroy).
The "destroy" method takes the passed id, fetches the model from the database using the "find" method, then calls destroy on that. This means the callbacks are triggered.
You would want to use "delete" if you don't want the callbacks to be triggered or you want better performance. Otherwise (and most of the time) you will want to use "destroy".
delete will delete current record from db (No callback)
destroy will delete current record and associated record (Has callback)
3.0.0 :003 > cert.delete
  Certified Destroy (2.0ms)  DELETE FROM "certifieds" WHERE "certifieds"."id" = $1  [["id", 1]]
 =>                                                                                    
#<Certified:0x00007feec0dea600                                                         
 id: 1,                                                                                
 employee_id: 1,                                                                       
 aircraft_id: 1,                                                                       
 created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,                           
 updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00> 

3.0.0 :005 > cert.save
  TRANSACTION (0.1ms)  BEGIN
  Aircraft Load (1.1ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE "aircrafts"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                                  
  TRANSACTION (0.1ms)  ROLLBACK                             
 => false 

3.0.0 :006 > cert.destroy
  TRANSACTION (0.3ms)  BEGIN
  Employee Destroy (1.2ms)  DELETE FROM "employees" WHERE "employees"."id" = $1  [["id", 1]]
  TRANSACTION (0.1ms)  ROLLBACK 

6. :primary_key
It is the option given if the primary key is not the default one.
but the foreign key is default used ie tablename_id if no foreign key option is used to specify different one.

7. :inverse_of
it is just used to specify the table on the other side 

8. :optional
it by default false but when set to true it will let object creation without the need of associated object
9. :validate
it is false by default when set to true it will validate the new associated object before saving 

10. :touch
will update the updated time if the associated object is updated or deleted and can also specify the 
aby other colummn to be updated if the default column is not to be used
  TRANSACTION (0.2ms)  BEGIN
  Aircraft Load (0.4ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE "aircrafts"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                                  
  Certified Update (0.6ms)  UPDATE "certifieds" SET "employee_id" = $1, "updated_at" = $2 WHERE "certifieds"."id" = $3  [["employee_id", 4], ["updated_at", "2022-06-06 13:40:48.889935"], ["id", 2]]
  Employee Update All (0.2ms)  UPDATE "employees" SET "count_of_pilots" = COALESCE("count_of_pilots", 0) + $1 WHERE "employees"."id" = $2  [["count_of_pilots", 1], ["id", 4]]  
  Employee Update All (0.1ms)  UPDATE "employees" SET "count_of_pilots" = COALESCE("count_of_pilots", 0) - $1 WHERE "employees"."id" = $2  [["count_of_pilots", 1], ["id", 2]]  
  Aircraft Update (0.1ms)  UPDATE "aircrafts" SET "updated_at" = $1 WHERE "aircrafts"."id" = $2  [["updated_at", "2022-06-06 13:40:48.895413"], ["id", 1]]                      
  TRANSACTION (0.3ms)  COMMIT                               
 => true  

11 Polymorphic
Passing true to the :polymorphic option indicates that this is a polymorphic association. 
Polymorphic Associations
With polymorphic associations, a model can belong to more than one other model, on a single association
single association to connect to many different model from single belongs_to command
The database representation of this polymorphism consists of two columns, which represent the ID and the type

Syntax example in models-

has_many :reviews, :as => :reviewable
belongs_to :reviewable, :polymorphic => true

Syntax example in migration
the belong_to model migration will have two column
add_references :table_name, :reviewable, polymorphic: true
or
t.references :reviewable, ploymorphic: true

or
 the belong_to model migration will have two column
      t.bigint  :reviewable_id
      t.string  :reviewable_type

-------------------------------------------------------------------------------------------

## Scopes for belongs_to

where
includes
readonly
select

1 where

The where method lets you specify the conditions that the associated object must meet.


2 includes
includes method to specify second-order associations that should be eager-loaded when this association is used

3 readonly
If you use readonly, then the associated object will be read-only when retrieved via the association.

4 select
The select method lets you override the SQL SELECT clause that is used to retrieve data about the associated object

## Do Any Associated Objects Exist?

nil? method to see if any association exists
3.0.0 :007 > cert.aircraft.nil?
 => false

## When are Objects Saved?
assigning object does not automatically save the object and associated object 
???? will using save method save the object 
saving both ojects found
3.0.0 :006 > cert.save
  TRANSACTION (0.3ms)  BEGIN
  Aircraft Create (0.6ms)  INSERT INTO "aircrafts" ("name", "cruising_range", "created_at", "updated_at", "aircraft_updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"  [["name", nil], ["cruising_range", nil], ["created_at", "2022-06-06 17:20:21.956603"], ["updated_at", "2022-06-06 17:20:21.956603"], ["aircraft_updated_at", nil]]
  Certified Update (0.8ms)  UPDATE "certifieds" SET "aircraft_id" = $1, "updated_at" = $2 WHERE "certifieds"."id" = $3  [["aircraft_id", 10], ["updated_at", "2022-06-06 17:20:21.966436"], ["id", 2]]

----------------------------------------------------------------------------------------------

## has_one Association.
has_one association creates a one-to-one match with another model

 Methods Added by has_one
has_one association the declaring class automatically gains 6 methods related to the association

association
association=(associate)
build_association(attributes = {})
create_association(attributes = {})
create_association!(attributes = {})
reload_association

1 association
The association method returns the associated object, if any. If no associated object is found, it returns nil

2 association=(associate)
The association= method assigns an associated object to this object

3 build_association(attributes = {})
The build_association method returns a new object of the associated type with foreign key will be set, but the associated object will not yet be saved

4 create_association(attributes = {})
will do same as above but will also save the object

5 create_association!(attributes = {})
create_association above, but raises ActiveRecord::RecordInvalid if the record is invalid.
ie is it creates the object but will output the error if there is any error

3.0.0 :006 > wallet = Wallet.find(1)
  Wallet Load (0.1ms)  SELECT "wallets".* FROM "wallets" WHERE "wallets"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                                                     
 =>                                                                    
#<Wallet:0x000055d3d12d1ce8                                            
...                           
3.0.0 :007 > cust.wallet = wallet
  Wallet Load (0.2ms)  SELECT "wallets".* FROM "wallets" WHERE "wallets"."customr_id" = $1 LIMIT $2  [["customr_id", 1], ["LIMIT", 1]]                                                     
  TRANSACTION (0.1ms)  BEGIN                                           
  Wallet Update (0.3ms)  UPDATE "wallets" SET "updated_at" = $1, "customr_id" = $2, "lock_version" = $3 WHERE "wallets"."id" = $4 AND "wallets"."lock_version" = $5  [["updated_at", "2022-06-06 18:08:03.179917"], ["customr_id", 1], ["lock_version", 6], ["id", 1], ["lock_version", 5]]         
  TRANSACTION (0.4ms)  COMMIT                               
 =>                                                         
#<Wallet:0x000055d3d12d1ce8                                 
... 

wallet = cust.build_wallet
  Wallet Load (0.3ms)  SELECT "wallets".* FROM "wallets" WHERE "wallets"."customr_id" = $1 LIMIT $2  [["customr_id", 2], ["LIMIT", 1]]                                          
 =>                                                         
#<Wallet:0x000055d3d13fa4a8                                 
...                                                         
3.0.0 :018 > wallet
 => 
#<Wallet:0x000055d3d13fa4a8                                 
 id: nil,                                                   
 name: nil,                                                 
 amount: nil,                                               
 lock_version: 0,                                           
 type: nil,                                                 
 created_at: nil,         
 updated_at: nil,
 customr_id: 2> 

 3.0.0 :020 > wallet = cust.create_wallet(:name => "phonepe")
  TRANSACTION (0.1ms)  BEGIN
  Wallet Create (0.2ms)  INSERT INTO "wallets" ("name", "amount", "lock_version", "type", "created_at", "updated_at", "customr_id") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"  [["name", "phonepe"], ["amount", nil], ["lock_version", 0], ["type", nil], ["created_at", "2022-06-06 18:12:19.897525"], ["updated_at", "2022-06-06 18:12:19.897525"], ["customr_id", 2]]     
  TRANSACTION (6.8ms)  COMMIT

  #<Wallet:0x000055d3d26447a8
 id: 4,                   
 name: "phonepe",         
 amount: nil,             
 lock_version: 0,         
 type: nil,               
 created_at: Mon, 06 Jun 2022 18:12:13.428386000 UTC +00:00,
 updated_at: Mon, 06 Jun 2022 18:12:13.428386000 UTC +00:00,
 customr_id: 2> 

 3.0.0 :022 > wallet = cust.create_wallet!(:name => "phonepe")
  TRANSACTION (0.1ms)  BEGIN
  Wallet Create (0.3ms)  INSERT INTO "wallets" ("name", "amount", "lock_version", "type", "created_at", "updated_at", "customr_id") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"  [["name", "phonepe"], ["amount", nil], ["lock_version", 0], ["type", nil], ["created_at", "2022-06-06 18:13:23.216276"], ["updated_at", "2022-06-06 18:13:23.216276"], ["customr_id", 2]]
  TRANSACTION (1.5ms)  COMMIT
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/associations/has_one_association.rb:105:in `remove_target!': Failed to remove the existing associated wallet. The record failed to save after its foreign key was set to nil. (ActiveRecord::RecordNotSaved)


3.0.0 :023 > cust.wallet
 => 
#<Wallet:0x000055d3d26447a8                                 
 id: 4,                                                     
 name: "phonepe",                                           
 amount: nil,                                               
 lock_version: 0,                                           
 type: nil,                                                 
 created_at: Mon, 06 Jun 2022 18:12:13.428386000 UTC +00:00,
 updated_at: Mon, 06 Jun 2022 18:12:13.428386000 UTC +00:00,
 customr_id: 2>


 Methods Added by has_many:
 When the has_many associations is decalred it adds 17 methods in the related to associations.
 collection
collection<<(object, ...)
collection.delete(object, ...)
collection.destroy(object, ...)
collection=(objects)
collection_singular_ids
collection_singular_ids=(ids)
collection.clear
collection.empty?
collection.size
collection.find(...)
collection.where(...)
collection.exists?(...)
collection.build(attributes = {})
collection.create(attributes = {})
collection.create!(attributes = {})
collection.reload

In here collection is replaced with the symbol passed as the first argument to has_many, and collection_singular is replaced with the singularized version of that symbol.


1 collection
The collection method returns a Relation of all of the associated objects. 
If there are no associated objects, it returns an empty Relation.

3.0.0 :011 > category = Category.find(1)
  Category Load (0.2ms)  SELECT "categories".* FROM "categories" WHERE "categories"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                         
 => #<Category:0x0000560fdac41f68 id: 1, name: "electronics", description: nil> 
3.0.0 :012 > category.products
  Product Load (0.4ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1  [["category_id", 1]]                                                     
 =>                                                   
[#<Product:0x0000560fdaf91e98 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x0000560fdaf91a10 id: 5, name: "Mobile MI", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x0000560fdaf918f8 id: 7, name: "Earphone", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x0000560fdaf917e0 id: 2, name: nil, price: 0.12334e3, category_id: 1, description: nil>] 

 2 collection<<(object, ...)

 It is like append 
It adds one or more objects to the collection by setting their foreign keys to the primary key of the calling model.
3.0.0 :013 > product = Product.create(:name => "VR")
  TRANSACTION (0.2ms)  BEGIN
  Product Create (7.6ms)  INSERT INTO "products" ("name", "price", "category_id", "description") VALUES ($1, $2, $3, $4) RETURNING "id"  [["name", "VR"], ["price", "100.0"], ["category_id", nil], ["description", nil]]
  TRANSACTION (0.4ms)  COMMIT                                                                    
 => #<Product:0x0000560fda82b1e0 id: 8, name: "VR", price: 0.1e3, category_id: nil, description: nil> 

 3.0.0 :014 > category.products << product
  TRANSACTION (0.3ms)  BEGIN
  Product Update (0.2ms)  UPDATE "products" SET "category_id" = $1 WHERE "products"."id" = $2  [["category_id", 1], ["id", 8]]                                                                                       
  TRANSACTION (6.7ms)  COMMIT                                                                    
 =>                                                                                              
[#<Product:0x0000560fdaf91e98 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x0000560fdaf91a10 id: 5, name: "Mobile MI", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x0000560fdaf918f8 id: 7, name: "Earphone", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x0000560fdaf917e0 id: 2, name: nil, price: 0.12334e3, category_id: 1, description: nil>,
 #<Product:0x0000560fda82b1e0 id: 8, name: "VR", price: 0.1e3, category_id: 1, description: nil>] 
3.0.0 :015 > 

3 collection.delete(object, ...)
This method removes one or more objects from the collection by setting their foreign keys to NULL.
3.0.0 :015 > category.products.delete(product)
  TRANSACTION (0.1ms)  BEGIN
  Product Update All (0.2ms)  UPDATE "products" SET "category_id" = $1 WHERE "products"."category_id" = $2 AND "products"."id" = $3  [["category_id", nil], ["category_id", 1], ["id", 8]]                  
  TRANSACTION (1.3ms)  COMMIT                                                           
 => [#<Product:0x0000560fda82b1e0 id: 8, name: "VR", price: 0.1e3, category_id: 1, description: nil>] 
3.0.0 :017 > category.products
 => 
[#<Product:0x0000560fdaf91e98 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x0000560fdaf91a10 id: 5, name: "Mobile MI", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x0000560fdaf918f8 id: 7, name: "Earphone", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x0000560fdaf917e0 id: 2, name: nil, price: 0.12334e3, category_id: 1, description: nil>] 

 3.0.0 :018 > product.reload
  Product Load (0.7ms)  SELECT "products".* FROM "products" WHERE "products"."id" = $1 LIMIT $2  [["id", 8], ["LIMIT", 1]]                                                                                  
 => #<Product:0x0000560fda82b1e0 id: 8, name: "VR", price: 0.1e3, category_id: nil, description: nil> 

 4 collection.destroy(object, ...)
 This method removes one or more objects from the collection by running destroy on each object.
3.0.0 :019 > product = Product.find(2)
  Product Load (0.4ms)  SELECT "products".* FROM "products" WHERE "products"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]                                                                      
 => #<Product:0x0000560fdae6eb60 id: 2, name: nil, price: 0.12334e3, category_id: 1, description: nil> 
 3.0.0 :020 > category.products.destroy(product)
  TRANSACTION (0.3ms)  BEGIN
  Product Destroy (0.5ms)  DELETE FROM "products" WHERE "products"."id" = $1  [["id", 2]]
  TRANSACTION (1.3ms)  COMMIT                                            
 => [#<Product:0x0000560fdae6eb60 id: 2, name: nil, price: 0.12334e3, category_id: 1, description: nil>] 

 runs rollback type operations thats is different from delete destroy  DELETES the object but delete only removes the foreign key 

 5 collection=(objects)
   The collection= method makes the collection contain only the supplied objects, by adding and deleting as appropriate. The changes are persisted to the database.
  
   3.0.0 :012 > product = cat.products
  Product Load (0.1ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1  [["category_id", 1]]                                                                                    
 =>                                                                                  
[#<Product:0x000055fbac36fb70 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>,
3.0.0 :035 > cat.products.reload
  Product Load (0.3ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1  [["category_id", 1]]                                                                                  
 =>                                                                                
[#<Product:0x000055fbab8c7768 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x000055fbab8c7268 id: 5, name: "Mobile MI", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x000055fbab8c6db8 id: 7, name: "Earphone", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x000055fbab8c4b80 id: 3, name: nil, price: 0.12212e3, category_id: 1, description: nil>,
 #<Product:0x00007fcf9411bfc8 id: 9, name: "Mouse", price: 0.1e3, category_id: 1, description: nil>]3.0.0 :041 > cat.products = product
  TRANSACTION (0.1ms)  BEGIN
  Product Update All (0.2ms)  UPDATE "products" SET "category_id" = $1 WHERE "products"."category_id" = $2 AND "products"."id" = $3  [["category_id", nil], ["category_id", 1], ["id", 9]]
  TRANSACTION (6.7ms)  COMMIT                           
 =>                                                     
[#<Product:0x000055fbac5193b8 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>,
...                                                     
which becomes
3.0.0 :021 > cat.products.reload
  Product Load (0.2ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1  [["category_id", 1]]                                                           
 =>                                                         
[#<Product:0x00007fcf94b231d8 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x00007fcf94b22e40 id: 5, name: "Mobile MI", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x00007fcf94b22aa8 id: 7, name: "Earphone", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x00007fcf94b21b80 id: 3, name: nil, price: 0.12212e3, category_id: 1, description: nil>] 

 6 collection_singular_ids
This method method returns an array of the ids of the objects in the collection.
3.0.0 :049 > product = cat.product_ids
 => [4, 5, 7, 3] 

 7 collection_singular_ids=(ids)

The collection_singular_ids= method makes the collection contain only the objects identified by the supplied primary key values, by adding and deleting as appropriate
3.0.0 :052 > product_id = [3,4]
 => [1, 2, 3, 4] 
3.0.0 :055 > cat.product_ids= product_id
  Product Load (0.4ms)  SELECT "products".* FROM "products" WHERE "products"."id" IN ($1, $2)  [["id", 3], ["id", 4]]                                                                               
  TRANSACTION (0.1ms)  BEGIN                                                    
  Product Update All (0.2ms)  UPDATE "products" SET "category_id" = $1 WHERE "products"."category_id" = $2 AND "products"."id" IN ($3, $4)  [["category_id", nil], ["category_id", 1], ["id", 5], ["id", 7]]
  TRANSACTION (1.2ms)  COMMIT
 => [3, 4] 
 3.0.0 :056 > cat.products
 => 
[#<Product:0x000055fbabf6e5d0 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x000055fbabf6e6e8 id: 3, name: nil, price: 0.12212e3, category_id: 1, description: nil>] 

8 collection.clear

The collection.clear method removes all objects from the collection according to the strategy specified by the dependent option. 
If no option is given, it follows the default strategy. 
The default strategy for has_many :through associations is delete_all, and for has_many associations is to set the foreign keys to NULL.

here foreign key set to null 
3.0.0 :061 > cat.products.clear
  Product Update All (7.3ms)  UPDATE "products" SET "category_id" = $1 WHERE "products"."category_id" = $2  [["category_id", nil], ["category_id", 1]]                                                   
 => [] 

Objects will be deleted if they're associated with option
 dependent: :destroy or 
 dependent: :destroy_async, 
 just like dependent: :delete_all.

 9 collection.empty?
 This method returns method returns true if the collection does not contain any associated objects.
3.0.0 :062 > cat.products.empty?
 => true 
 As it was just cleared

10 collection.size
This  method returns the number of objects in the collection.
Here 0 as empty. 

3.0.0 :063 > cat.products.size
 => 0 
 3.0.0 :064 > cat.product_ids= product_id["id", 3]]                                                                         
  Product Update (0.2ms)  UPDATE "products" SET "category_id" = $1 WHERE "products"."id" = $2  [["category_id", 1], ["id", 4]]                                                                         
  Product Update (0.1ms)  UPDATE "products" SET "category_id" = $1 WHERE "products"."id" = $2  [["category_id", 1], ["id", 8]]                                                                         
  Product Update (0.1ms)  UPDATE "products" SET "category_id" = $1 WHERE "products"."id" = $2  [["category_id", 1], ["id", 7]]                                                      
  TRANSACTION (6.5ms)  COMMIT                                   
 => [3, 4, 8, 7]                                                
3.0.0 :065 > cat.products.size
 => 4 

11 collection.find(...)
Will find the associated object through that objects id

3.0.0 :066 > cat.products.find(4)
  Product Load (0.1ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1 AND "products"."id" = $2 LIMIT $3  [["category_id", 1], ["id", 4], ["LIMIT", 1]]                       
 => #<Product:0x000055fbac649670 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil> 
3.0.0 :067 > 

12 collection.where(...)
This method finds objects within the collection based on the conditions supplied but the objects are loaded lazily meaning that the database is queried only when the object(s) are accessed.
3.0.0 :067 > cat.products.where(name: "mobile")
  Product Load (0.5ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1 AND "products"."name" = $2  [["category_id", 1], ["name", "mobile"]]                                   
 => [#<Product:0x000055fbabf6de78 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>] 

13 collection.exists?(...)
This method checks whether an object meeting the supplied conditions exists in the collection's table.
description: nil>,
3.0.0 :064 > cat.product_ids= product_id
3.0.0 :069 > cat.products.exists?(id: 4)
  Product Exists? (0.7ms)  SELECT 1 AS one FROM "products" WHERE "products"."category_id" = $1 AND "products"."id" = $2 LIMIT $3  [["category_id", 1], ["id", 4], ["LIMIT", 1]]     
 => true                                                        
3.0.0 :070 > cat.products.exists?(id: 1)
  Product Exists? (0.7ms)  SELECT 1 AS one FROM "products" WHERE "products"."category_id" = $1 AND "products"."id" = $2 LIMIT $3  [["category_id", 1], ["id", 1], ["LIMIT", 1]]                        
 => false 

14 collection.build(attributes = {})
This method initiate the object of the associated class.
this method returns a single or array of new objects of the associated type and the link through their foreign key will be created, but the associated objects will not yet be saved.

15 collection.create(attributes = {})

this method does the same thing as above but save the object too.

16 collection.create!(attributes = {})
does the same as above method but will return error if there is any error.

3.0.0 :073 > cat.products.build(:name => "watch")
 => #<Product:0x00007fcf94537828 id: nil, name: "watch", price: 0.1e3, category_id: 1, description: nil> 
 3.0.0 :074 > cat.products
 => 
[#<Product:0x000055fbac48a848 id: 3, name: nil, price: 0.12212e3, category_id: 1, description: nil>,
 #<Product:0x000055fbac48a780 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x000055fbac48a5f0 id: 8, name: "VR", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x000055fbac48a6b8 id: 7, name: "Earphone", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x00007fcf94537828 id: nil, name: "watch", price: 0.1e3, category_id: 1, description: nil>
 id is nil as the object is not saved

 3.0.0 :076 > cat.products
 => 
[#<Product:0x000055fbac48a848 id: 3, name: nil, price: 0.12212e3, category_id: 1, description: nil>,
 #<Product:0x000055fbac48a780 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x000055fbac48a5f0 id: 8, name: "VR", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x000055fbac48a6b8 id: 7, name: "Earphone", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x00007fcf94537828 id: nil, name: "watch", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x00007fcf94b95508 id: 10, name: "watch", price: 0.1e3, category_id: 1, description: nil>] 

3.0.0 :078 > cat.products.create!(:name1 => "watch")
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activemodel-7.0.3/lib/active_model/attribute_assignment.rb:51:in `_assign_attribute': unknown attribute 'name1' for Product. (ActiveModel::UnknownAttributeError)

17 collection.reload
This method will reload  the cache if there any changes to loaded.

category.products.reload
3.0.0 :077 > cat.products.reload
  Product Load (0.3ms)  SELECT "products".* FROM "products" WHERE "products"."category_id" = $1  [["category_id", 1]]                                                                                  
 =>                                                                                
[#<Product:0x000055fbaa80ae20 id: 3, name: nil, price: 0.12212e3, category_id: 1, description: nil>,
 #<Product:0x000055fbaa80aba0 id: 4, name: "mobile", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x000055fbaa80a8f8 id: 8, name: "VR", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x000055fbaa80a5b0 id: 7, name: "Earphone", price: 0.1e3, category_id: 1, description: nil>,
 #<Product:0x000055fbaa80a380 id: 10, name: "watch", price: 0.1e3, category_id: 1, description: nil>] 



has_and_belongs_to_many

this associates two classes via an intermediate join table that includes foreign keys referring to each of the classes.
A has_and_belongs_to_many association creates a direct many-to-many connection with another model, with no intervening model. 
But reauires a join table to support the associations.
This association creates a many-to-many relationship with another model.

Cannot add any attribute in join table and not validation or callbacks can be done as no model is made for the join table.For that if validation or callbacks are needed  than you would need has_many :through. 

1 Methods Added by has_and_belongs_to_many
collection
collection<<(object, ...)
collection.delete(object, ...)
collection.destroy(object, ...)
collection=(objects)
collection_singular_ids
collection_singular_ids=(ids)
collection.clear
collection.empty?
collection.size
collection.find(...)
collection.where(...)
collection.exists?(...)
collection.build(attributes = {})
collection.create(attributes = {})
collection.create!(attributes = {})
collection.reload

...

1 Additional Column Methods                                                  
If the join table for a has_and_belongs_to_many association has additional columns beyond the two foreign keys,
 these columns will be added as attributes to records retrieved via that association
Records returned with additional attributes will always be read-only, because Rails cannot save changes to those attributes.


2. collection<<(object, ...)
 This method adds one or more objects to the collection by creating records in the join table.

3.0.0 :030 > author2 = Author.find(2)
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]  
 =>                                                         
#<Author:0x000055fdfa238630                                 
...                                                         
3.0.0 :031 > author3 = Author.find(3)
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT $2  [["id", 3], ["LIMIT", 1]]
 => 
#<Author:0x000055fdfa4ee258

3.0.0 :033 > book1.authors << author1
  TRANSACTION (0.1ms)  BEGIN
  Book::HABTM_Authors Create (0.2ms)  INSERT INTO "authors_books" ("book_id", "author_id") VALUES ($1, $2)  [["book_id", 1], ["author_id", 1]]                                      
  TRANSACTION (0.4ms)  COMMIT                               
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" INNER JOIN "authors_books" ON "authors"."id" = "authors_books"."author_id" WHERE "authors_books"."book_id" = $1  [["book_id", 1]]
 => 
[#<Author:0x000055fdf9e80b78
  id: 1,
  name: "premchand",
  created_at:
   Tue, 07 Jun 2022 13:20:45.278530000 UTC +00:00,
  updated_at:
   Tue, 07 Jun 2022 13:20:45.278530000 UTC +00:00>] 

   3.0.0 :033 > book1.authors << author1
  TRANSACTION (0.1ms)  BEGIN
  Book::HABTM_Authors Create (0.2ms)  INSERT INTO "authors_books" ("book_id", "author_id") VALUES ($1, $2)  [["book_id", 1], ["author_id", 1]]                                      
   Tue, 07 Jun 2022 13:20:45.278530000 UTC +00:00>] 
3.0.0 :035 > book1.authors << author2 << author3
  TRANSACTION (0.1ms)  BEGIN
  Book::HABTM_Authors Create (0.1ms)  INSERT INTO "authors_books" ("book_id", "author_id") VALUES ($1, $2)  [["book_id", 1], ["author_id", 2]]                            
  TRANSACTION (6.6ms)  COMMIT                     
  TRANSACTION (0.1ms)  BEGIN                      
  Book::HABTM_Authors Create (0.1ms)  INSERT INTO "authors_books" ("book_id", "author_id") VALUES ($1, $2)  [["book_id", 1], ["author_id", 3]]                            
  TRANSACTION (0.3ms)  COMMIT                     
 =>                                               
[#<Author:0x000055fdf9e80b78                      
  id: 1,
  name: "premchand",
  created_at:
   Tue, 07 Jun 2022 13:20:45.278530000 UTC +00:00,
  updated_at:
   Tue, 07 Jun 2022 13:20:45.278530000 UTC +00:00>,
 #<Author:0x000055fdfa238630
  id: 2,
  name: "amitabh",
  created_at:
   Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00,
  updated_at:
   Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00>,
 #<Author:0x000055fdfa4ee258
  id: 3,
  name: "sam",
  created_at:
   Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00,
  updated_at:
   Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00>] 

 
   3.0.0 :041 > author3.books << book3 << book2
  TRANSACTION (0.1ms)  BEGIN
  Author::HABTM_Books Create (0.1ms)  INSERT INTO "authors_books" ("book_id", "author_id") VALUES ($1, $2)  [["book_id", 2], ["author_id", 3]]                             
  TRANSACTION (6.6ms)  COMMIT                      
  TRANSACTION (0.0ms)  BEGIN                       
  Author::HABTM_Books Create (0.1ms)  INSERT INTO "authors_books" ("book_id", "author_id") VALUES ($1, $2)  [["book_id", 2], ["author_id", 3]]                             
  TRANSACTION (0.3ms)  COMMIT
 => 
[#<Book:0x000055fdfa0232c8
  id: 1,
  books_name: nil,
  volume: nil,
  publisher_id: nil,
  quantity: nil,
  issued_quantity: nil,
  created_at:
   Tue, 07 Jun 2022 13:21:41.816297000 UTC +00:00,
  updated_at:
   Tue, 07 Jun 2022 13:21:41.816297000 UTC +00:00,
  book_type_id: nil,
  home_page_url: nil>,
 #<Book:0x00007f0d243c6440
  id: 2,
  books_name: "bio",
  volume: nil,
  publisher_id: nil,
  quantity: nil,
  issued_quantity: nil,
  created_at:
   Tue, 07 Jun 2022 13:22:11.496787000 UTC +00:00,
  updated_at:
   Tue, 07 Jun 2022 13:22:11.496787000 UTC +00:00,
  book_type_id: nil,
  home_page_url: nil>,
 #<Book:0x000055fdfa4fe5b8
  id: 2,
  books_name: "bio",
  volume: nil,
  publisher_id: nil,
  quantity: nil,
  issued_quantity: nil,
  created_at:
   Tue, 07 Jun 2022 13:22:11.496787000 UTC +00:00,
  updated_at:
   Tue, 07 Jun 2022 13:22:11.496787000 UTC +00:00,
  book_type_id: nil,
  home_page_url: nil>] 
3.0.0 :042 > 


                                   
lms_development=# select * from authors_books;
 book_id | author_id               
---------+-----------              
       1 |         1               
       1 |         2               
       1 |         3        
       2 |         3        
       2 |         3        
(5 rows)

3. collection
The collection method returns a Relation of all of the associated objects. If there are no associated objects, it returns an empty Relation.

  3.0.0 :036 > book1.authors
 => 
[#<Author:0x000055fdf9e80b78                       
  id: 1,                                           
  name: "premchand",                               
  created_at:                                      
   Tue, 07 Jun 2022 13:20:45.278530000 UTC +00:00, 
  updated_at:                                      
   Tue, 07 Jun 2022 13:20:45.278530000 UTC +00:00>,
 #<Author:0x000055fdfa238630                       
  id: 2,                                           
  name: "amitabh",                                 
  created_at:                                      
   Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00,
  updated_at:
   Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00>,
 #<Author:0x000055fdfa4ee258
  id: 3,
  name: "sam",
  created_at:
   Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00,
  updated_at:
   Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00>]

4 collection.delete(object, ...)
This method removes one or more objects from the collection by deleting records in the join table 
but this does not destroy the objects.

3.0.0 :004 > book1.authors.delete(author1)
  TRANSACTION (0.1ms)  BEGIN
  Book::HABTM_Authors Delete All (6.8ms)  DELETE FROM "authors_books" WHERE "authors_books"."book_id" = $1 AND "authors_books"."author_id" = $2  [["book_id", 1], ["author_id", 1]]                                         
  TRANSACTION (0.5ms)  COMMIT                                                      
 =>                                                                                
[#<Author:0x00005575d73ab2c0                                                       
  id: 1,
  name: "premchand",
  created_at: Tue, 07 Jun 2022 13:20:45.278530000 UTC +00:00,
  updated_at: Tue, 07 Jun 2022 13:20:45.278530000 UTC +00:00>] 
  3.0.0 :005 > author1
 => 
#<Author:0x00005575d73ab2c0
 id: 1,                
 name: "premchand",    
 created_at: Tue, 07 Jun 2022 13:20:45.278530000 UTC +00:00,
 updated_at: Tue, 07 Jun 2022 13:20:45.278530000 UTC +00:00> 
 3.0.0 :007 > book1.authors
  Author Load (0.3ms)  SELECT "authors".* FROM "authors" INNER JOIN "authors_books" ON "authors"."id" = "authors_books"."author_id" WHERE "authors_books"."book_id" = $1  [["book_id", 1]]                  
 =>                                                                
[#<Author:0x00005575d7380d40                                     
  id: 2,                                                         
  name: "amitabh",                                               
  created_at: Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00,    
  updated_at: Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00>,   
 #<Author:0x00005575d7380ae8                                     
  id: 3,                                                         
  name: "sam",                                                   
  created_at: Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00,    
  updated_at: Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00>]

  3.0.0 :008 > author1.books
  Book Load (0.3ms)  SELECT "books".* FROM "books" INNER JOIN "authors_books" ON "books"."id" = "authors_books"."book_id" WHERE "authors_books"."author_id" = $1  [["author_id", 1]]                        
 => []  

5 collection.destroy(object, ...)

This method removes one or more objects from the collection by deleting records in the join table. 
This does not destroy the objects.
So maybe behaves just like delete method
3.0.0 :010 > book1.authors.destroy(author3)
  TRANSACTION (0.1ms)  BEGIN
  HABTM_Authors Load (0.2ms)  SELECT "authors_books".* FROM "authors_books" WHERE "authors_books"."book_id" = $1 AND "authors_books"."author_id" = $2  [["book_id", 1], ["author_id", 3]]              
  Book::HABTM_Authors Delete All (0.2ms)  DELETE FROM "authors_books" WHERE "authors_books"."book_id" = $1 AND "authors_books"."author_id" = $2  [["book_id", 1], ["author_id", 3]]                    
  TRANSACTION (1.2ms)  COMMIT                                 
 =>                                                           
[#<Author:0x00005575d7492bc0                                  
  id: 3,                                                      
  name: "sam",                                                
  created_at: Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00, 
  updated_at: Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00>] 

3.0.0 :011 > book1.authors
 => 
[#<Author:0x00005575d7380d40                                     
  id: 2,                                                         
  name: "amitabh",                                               
  created_at: Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00,    
  updated_at: Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00>]   

  3.0.0 :012 > author3.books
  Book Load (0.4ms)  SELECT "books".* FROM "books" INNER JOIN "authors_books" ON "books"."id" = "authors_books"."book_id" WHERE "authors_books"."author_id" = $1  [["author_id", 3]]                        
 =>                                                                
[#<Book:0x00005575d72bc760                                         
  id: 2,                                                           
  books_name: "bio",                                               
  volume: nil,                                                     
  publisher_id: nil,                                               
  quantity: nil,                                                   
  issued_quantity: nil,                                            
  created_at: Tue, 07 Jun 2022 13:22:11.496787000 UTC +00:00,      
  updated_at: Tue, 07 Jun 2022 13:22:11.496787000 UTC +00:00,      
  book_type_id: nil,                                               
  home_page_url: nil>,


6 collection=(objects)

The collection= method makes the collection contain only the supplied objects, by adding and deleting as appropriate. The changes are persisted to the database.

3.0.0 :020 > book3.authors
  Author Load (0.3ms)  SELECT "authors".* FROM "authors" INNER JOIN "authors_books" ON "authors"."id" = "authors_books"."author_id" WHERE "authors_books"."book_id" = $1  [["book_id", 3]]                
 => []  

 3.0.0 :023 > book1.authors
 => 
[#<Author:0x00005575d7380d40                                               
  id: 2,                                                                   
  name: "amitabh",                                                         
  created_at: Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00,              
  updated_at: Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00>]        

  3.0.0 :022 > authors = book1.authors
 => 
[#<Author:0x00005575d7380d40                                               
...                  

3.0.0 :024 > book3.authors = authors
  TRANSACTION (0.2ms)  BEGIN
  Book::HABTM_Authors Create (0.3ms)  INSERT INTO "authors_books" ("book_id", "author_id") VALUES ($1, $2)  [["book_id", 3], ["author_id", 2]]                                                            
  TRANSACTION (1.3ms)  COMMIT                                    
 =>                                                              
[#<Author:0x00005575d7380d40                                     
... 

3.0.0 :025 > book3.authors
 => 
[#<Author:0x00005575d7380d40                                     
  id: 2,                                                         
  name: "amitabh",                                               
  created_at: Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00,    
  updated_at: Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00>]   
3.0.0 :026 > 

7 collection_singular_ids
This method returns an array of the ids of the objects in the collection.
3.0.0 :032 > author2.book_ids
 => [1, 3] 

8 collection_singular_ids=(ids)
This  method makes the collection contain only the objects identified by the supplied primary key values, 
by adding and deleting as appropriate. 
The changes are persisted to the database.
3.0.0 :034 > author3.book_ids = books
  Book Load (0.4ms)  SELECT "books".* FROM "books" WHERE "books"."id" IN ($1, $2)  [["id", 1], ["id", 3]]
  TRANSACTION (0.1ms)  BEGIN                                       
  Author::HABTM_Books Delete All (0.1ms)  DELETE FROM "authors_books" WHERE "authors_books"."author_id" = $1 AND "authors_books"."book_id" IN ($2, $3)  [["author_id", 3], ["book_id", 2], ["book_id", 2]]  
  Author::HABTM_Books Create (0.1ms)  INSERT INTO "authors_books" ("book_id", "author_id") VALUES ($1, $2)  [["book_id", 1], ["author_id", 3]]                                                              
  Author::HABTM_Books Create (0.1ms)  INSERT INTO "authors_books" ("book_id", "author_id") VALUES ($1, $2)  [["book_id", 3], ["author_id", 3]]                                                              
  TRANSACTION (6.5ms)  COMMIT                                      
 => [1, 3]  

 9 collection.clear
  This method method removes every object from the collection by deleting the rows from the joining table.
   This does not destroy the associated objects.
3.0.0 :035 > book2.authors
 => 
[#<Author:0x00005575d7886e98                                                       
  id: 3,                                                                           
  name: "sam",                                                                     
  created_at: Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00,                      
  updated_at: Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00>,                     
 #<Author:0x00005575d7886da8                                                       
  id: 3,                                                                           
  name: "sam",                                                                     
  created_at: Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00,                      
  updated_at: Tue, 07 Jun 2022 13:20:56.656215000 UTC +00:00>]  

  3.0.0 :036 > book2.authors.clear
  Book::HABTM_Authors Delete All (0.3ms)  DELETE FROM "authors_books" WHERE "authors_books"."book_id" = $1 AND "authors_books"."author_id" IN ($2, $3)  [["book_id", 2], ["author_id", 3], ["author_id", 3]]                 
 => []     

10 collection.empty?
this method returns true if the collection does not contain any associated objects.
3.0.0 :037 > book2.authors.empty?
 => true 

11 collection.size

This method returns the number of objects in the collection.
3.0.0 :038 > book2.authors.size
 => 0 
3.0.0 :039 > book3.authors.size
 => 1 

12 collection.find(...) 
The collection.find method finds objects within the collection's table. 
3.0.0 :040 > book3.authors.find(1)
  Author Load (0.3ms)  SELECT "authors".* FROM "authors" INNER JOIN "authors_books" ON "authors"."id" = "authors_books"."author_id" WHERE "authors_books"."book_id" = $1 AND "authors"."id" = $2 LIMIT $3  [["book_id", 3], ["id", 1], ["LIMIT", 1]]
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/relation/finder_methods.rb:381:in `raise_record_not_found_exception!': Couldn't find Author with 'id'=1 [WHERE "authors_books"."book_id" = $1] (ActiveRecord::RecordNotFound)
3.0.0 :041 > book3.authors.find(2)
  Author Load (0.7ms)  SELECT "authors".* FROM "authors" INNER JOIN "authors_books" ON "authors"."id" = "authors_books"."author_id" WHERE "authors_books"."book_id" = $1 AND "authors"."id" = $2 LIMIT $3  [["book_id", 3], ["id", 2], ["LIMIT", 1]]
 =>                                                                                 
#<Author:0x00005575d65a3bf0                                                         
 id: 2,                                                                             
 name: "amitabh",                                                                   
 created_at: Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00,                        
 updated_at: Tue, 07 Jun 2022 13:20:53.137843000 UTC +00:00>    

13 collection.where(...)

The collection.where method finds objects within the collection based on the conditions supplied but the objects are loaded lazily meaning that the database is queried only when the object(s) are accessed.

???? what is loaded lazily??

3.0.0 :043 > author2.books.where( :name == "biopic")
  Book Load (0.4ms)  SELECT "books".* FROM "books" INNER JOIN "authors_books" ON "books"."id" = "authors_books"."book_id" WHERE "authors_books"."author_id" = $1  [["author_id", 2]]                                                  
 =>                                                                                          
[#<Book:0x00005575d78d4c60                                                                   
  id: 1,                                                                                     
  books_name: nil,                                                                           
  volume: nil,                                                                               
  publisher_id: nil,                                                                         
  quantity: nil,                                                                             
  issued_quantity: nil,                                                                      
  created_at: Tue, 07 Jun 2022 13:21:41.816297000 UTC +00:00,                                
  updated_at: Tue, 07 Jun 2022 13:21:41.816297000 UTC +00:00,                                
  book_type_id: nil,                                                                         
  home_page_url: nil>,
 #<Book:0x00005575d78d4b70
  id: 3,
  books_name: "biopic",
  volume: nil,
  publisher_id: nil,
  quantity: nil,
  issued_quantity: nil,
  created_at: Tue, 07 Jun 2022 13:22:14.033334000 UTC +00:00,
  updated_at: Tue, 07 Jun 2022 13:22:14.033334000 UTC +00:00,
  book_type_id: nil,
  home_page_url: nil>] 

  14 collection.exists?(...)
  This  method checks whether an object meeting the supplied conditions exists in the collection's table. 
  3.0.0 :045 > author3.books.exists?
  Book Exists? (0.4ms)  SELECT 1 AS one FROM "books" INNER JOIN "authors_books" ON "books"."id" = "authors_books"."book_id" WHERE "authors_books"."author_id" = $1 LIMIT $2  [["author_id", 3], ["LIMIT", 1]]                
 => true  
 3.0.0 :049 > author3.books.exists?(:name == "biopic")
 => false 

15 collection.build(attributes = {})

This method returns a new object of the associated type. 
This object will be instantiated from the passed attributes, and the link through the join table will be created,
 but the associated object will not yet be saved.
3.0.0 :011 > author = book3.authors.build(name: "amit")
 => 
#<Author:0x0000561204484010                    
...  

16 collection.create(attributes = {})
Does the same operation as above but also save the object
3.0.0 :024 > author = book3.authors.create(name: "abhishek")

  TRANSACTION (0.3ms)  BEGIN
  Author Create (0.4ms)  INSERT INTO "authors" ("name", "created_at", "updated_at") VALUES ($1, $2, $3) RETURNING "id"  [["name", "abhishek"], ["created_at", "2022-06-07 16:12:41.136921"], ["updated_at", "2022-06-07 16:12:41.136921"]]      
  Book::HABTM_Authors Create (0.2ms)  INSERT INTO "authors_books" ("book_id", "author_id") VALUES ($1, $2)  [["book_id", 3], ["author_id", 9]]                                      
  TRANSACTION (0.4ms)  COMMIT                               
 =>                                                         
#<Author:0x000056120499b670                                 

...

17 collection.create!(attributes = {})
Does the same as above , but raises ActiveRecord::RecordInvalid if the record is invalid.

3.0.0 :003 > author = book3.authors.create!()
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/validations.rb:80:in `raise_validation_error': Validation failed: Name can't be blank (ActiveRecord::RecordInvalid) 

18 collection.reload
The collection.reload method returns a Relation of all of the associated objects, forcing a database read. If there are no associated objects, it returns an empty Relation.

book3.authors.reload



-------------------------------------------------------
## Options for has_and_belongs_to_many
 when you want to customize the behavior of the has_and_belongs_to_many association reference. 
 Such customizations can easily be accomplished by passing options when you create the association

 association supports these options:

:association_foreign_key
:autosave
:class_name
:foreign_key
:join_table
:validate

1 :association_foreign_key
it is assumed by rails that column in the join table used to hold the foreign key pointing to the other model is the name of that model with the suffix _id added. 
But if it is something other that it is to given with this option 

2 :autosave
If you set the :autosave option to true, Rails will save any loaded association members and destroy members that are marked for destruction whenever you save the parent object. 
Setting :autosave to false is not the same as not setting the :autosave option.
 If the :autosave option is not present, then new associated objects will be saved, but updated associated objects will not be saved.


3 :class_name
If the name of the other model cannot be derived from the association name, you can use the :class_name option to supply the model name.

4 :foreign_key
By convention, Rails assumes that the column in the join table used to hold the foreign key pointing to this model is the name of this model with the suffix _id added. The :foreign_key option lets you set the name of the foreign key directly:

5 :join_table
If the default name of the join table, based on lexical ordering, is not what you want, you can use the :join_table option to override the default.



6 :validate
If you set the :validate option to false, then new associated objects will not be validated whenever you save this object.
By default, this is true: new associated objects will be validated when this object is saved.

----------------------------------------------------
## Choosing Between has_many :through and has_and_belongs_to_many
To establish the association between many to many relationship models we need 2 types of associations can be used 
has_many :through
and has_and_belongs_to_many

If want to just make association simply without any valiation , 
callbacks or attribute can simply use has_and_belongs_to_many but 
if in need of any of the above then need to use  has_many :through 
has_many :through uses 3rd model as join model also  the relationship model is an independent entity.
and has_and_belongs_to_many uses self_join table

------------------------------------------------

## The has_one :through Association

This association is used to set up a one-to-one connection with other model via another model. 

-------------------------------------------------
## Self Joins
They are used to create associations to model which is itself only. That is relation with self only.
To do this in rails will have to add a references column to the model itself in migrations/schema.
Like 
  t.references :manager, foreign_key: { to_table: :employees }

  3.0.0 :004 > employee.trainee.build
 => 
#<Employee:0x0000563381c200f0                                                          
 id: nil,                                                                              
 name: nil,                                                                            
 salary: nil,                                                                          
 mobile_number: nil,                                                                   
 DOB: Wed, 01 Jan 1997,                                                                
 created_at: nil,                                                                      
 updated_at: nil,                                                                      
 count_of_pilots: nil,                                 
 trainer_id: 1> 

3.0.0 :009 > trainer = employee.build_trainer
 => 
#<Employee:0x00005633819af7a8                                   
...                                                             
3.0.0 :023 > employee
 => 
#<Employee:0x0000563382d45010                                    
 id: 1,                                                          
 name: "Ajay",                                                   
 salary: 30000,                                                  
 mobile_number: "123456789",                                     
 DOB: nil,                                                       
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,     
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
 count_of_pilots: 3,        
 trainer_id: 13> 
---------------------------------------------------------------------

## Single Table Inheritance (STI)
Sometimes, you may want to share fields and behavior between different models. 

If some common methods  is needed for all of them, but having some specific behavior for each, and separated controllers too.
Then create a parent class and then create child class which inherits methods and variables from parent class.
STI need type feild to work in the parent table.
STI won't work without a "type" field in the table.

While creating child class will ahve to give option --parent= MODEL_NAME
and this  will generate a model that inherits from the specified parent and without equivalent migration

This means that all behavior added to parent class is available for child class too, as associations, public methods, etc.

And object created for child will save data in parent class type.

(base) itsacheckmate@itsacheckmate:~/Training/Rails/simple_cms$ rails db:migrate
== 20220608064852 CreateParagraphs: migrating =================================
-- create_table(:paragraphs)
   -> 0.0070s
== 20220608064852 CreateParagraphs: migrated (0.0070s) ========================

== 20220608101712 AddColumnToContentUsers: migrating ==========================
-- add_column(:content_users, :type, :string)
   -> 0.0011s
-- rename_table(:content_users, :users)
   -> 0.0030s
== 20220608101712 AddColumnToContentUsers: migrated (0.0041s) =================

(base) itsacheckmate@itsacheckmate:~/Training/Rails/simple_cms$ rails generate model content_user --parent= User
      invoke  active_record
      create    app/models/content_user.rb
      invoke    test_unit
      create      test/models/content_user_test.rb
      create      test/fixtures/content_users.yml
(base) itsacheckmate@itsacheckmate:~/Training/Rails/simple_cms$ rails generate model admin_user --parent= User
      invoke  active_record
      create    app/models/admin_user.rb
      invoke    test_unit
      create      test/models/admin_user_test.rb
      create      test/fixtures/admin_users.yml


      3.0.0 :002 > ContentUser.create(name: "Shubham")
  TRANSACTION (0.1ms)  BEGIN
  ContentUser Create (7.5ms)  INSERT INTO "users" ("name", "mobile", "email", "created_at", "updated_at", "type") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"  [["name", "Shubham"], ["mobile", nil], ["email", nil], ["created_at", "2022-06-08 10:25:28.182570"], ["updated_at", "2022-06-08 10:25:28.182570"], ["type", "ContentUser"]]
  TRANSACTION (0.4ms)  COMMIT 
 =>                           
#<ContentUser:0x00007fc0f84595a0
 id: 1,                       
 name: "Shubham",             
 mobile: nil,
 email: nil,
 created_at: Wed, 08 Jun 2022 10:25:28.182570000 UTC +00:00,
 updated_at: Wed, 08 Jun 2022 10:25:28.182570000 UTC +00:00,
 type: "ContentUser"> 

========================================================================================
## Association Callbacks
Association callbacks are similar to normal callbacks, but they are triggered by events in the life cycle of a collection.

There are four available association callbacks:

before_add
after_add
before_remove
after_remove
Here define association callbacks by adding options to the association declaration
Rails passes the object being added or removed to the callback.
If a before_add callback throws :abort, the object does not get added to the collection.
Similarly, if a before_remove callback throws :abort, the object does not get removed from the collection


3.0.0 :004 > cert = Certified.new
 => 
#<Certified:0x00007f4f143cb350              
...                                         
3.0.0 :005 > cert.employee_id=1
 => 1 
3.0.0 :006 > cert.save!
  TRANSACTION (0.3ms)  BEGIN
  Certified Create (1.5ms)  INSERT INTO "certifieds" ("employee_id", "aircraft_id", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"  [["employee_id", 1], ["aircraft_id", nil], ["created_at", "2022-06-20 16:07:08.378329"], ["updated_at", "2022-06-20 16:07:08.378329"]]
  Employee Update All (0.2ms)  UPDATE "employees" SET "count_of_pilots" = COALESCE("count_of_pilots", 0) + $1 WHERE "employees"."id" = $2  [["count_of_pilots", 1], ["id", 1]]
  TRANSACTION (6.5ms)  COMMIT
 => true 

 3.0.0 :003 > air.certifieds << cert
Before add association Callbacks  TRANSACTION (0.1ms)  BEGIN
  Certified Update (0.5ms)  UPDATE "certifieds" SET "aircraft_id" = $1, "updated_at" = $2 WHERE "certifieds"."id" = $3  [["aircraft_id", 1], ["updated_at", "2022-06-20 16:19:41.042106"], ["id", 21]]                              
  TRANSACTION (6.7ms)  COMMIT
  Certified Load (0.2ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."aircraft_id" = $1  [["aircraft_id", 1]]
 => 
[#<Certified:0x000055c046b2f550
  id: 2,
  employee_id: 4,
  aircraft_id: 1,
  created_at:
   Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at:
   Mon, 06 Jun 2022 13:40:48.889935000 UTC +00:00>,
 #<Certified:0x000055c046518c20
  id: 21,
  employee_id: nil,
  aircraft_id: 1,
  created_at:
   Mon, 20 Jun 2022 16:09:32.310058000 UTC +00:00,
  updated_at:
   Mon, 20 Jun 2022 16:19:41.042106000 UTC +00:00>] 
3.0.0 :004 > 

# Triggers `before_add`, and 'after_add' callback
author.books << book
author.books = [book, book2]

# Does not trigger the `before_add` callback
book.update(author_id: 1)


















