Automation test cases in rails
1. BDD vs TDD
3. Rspecs
4. Factory girl

Unit Test - test of individual component in an isolation.
Granularity of test?
Specification
FeedBack
Regression
Granularity

## TDD -Test Driven Development

Unit Test - 
- Writing Unit Tests for existing code can be difficult... or impossible
- A Unit Test is a test of a component in isolation
- In order to test is isolation, any external dependencies must be "mocked"
- An example of something that is frequently "mocked" is a database connection
- Units Tests tend to be very fast to run.

Test Driven Development:
- It's an iterative process: write a small test... write just enough code to get the test to pass. Rinse and repeat.
- The tests and the code that the tests "cover" are born and grow together. They are intertwined.
- Test are written before the code

Process Of TDD
TDD methodology follows a very simple 6 step process:

1) Write a test case: Based on the requirements, write an automated test case.

2) Run all the test cases: Run these automated test cases on the currently developed code.

3) Develop the code for that test cases: If the test case fails, then, write the code to make that test-case work as expected.

4) Run test cases again: Run the test cases again and check if all the test cases developed so far are implemented.

5) Refactor your code: This is an optional step. However, it’s important to refactor your code to make it more readable and reusable.

6) Repeat the steps 1- 5 for new test cases: Repeat the cycle for the other test cases until all the test cases are implemented.

The teams that implement TDD, take more time for development however, they tend to find very few defects. TDD results in improved quality of code and the code that is more reusable and flexible.

TDD also helps in achieving high test coverage of about 90-100%. The most challenging thing for developers following TDD is to write their test cases before writing the code.

Some of the tools which support TDD are: JUnit, TestNG, NUnit, etc.

TDD is iterative development process. IT instructs developer to write code only if automated test has failed.

## BDD - Behavior Driven Development
The test made up of three distinct sections: Context, Event, Outcomes
- Context is the "starting state"
- Event is the thing that the user does
- Outcomes are the expected results of what the user does
- The test describes in a very direct way the set of the behaviours that the customer can expect from the system.

Context - Starting State
Event - What User Does
Outcomes - The Expected Results

BDD stands for Behavior Driven Development. BDD is an extension to TDD where instead of writing the test cases, we start by writing a behavior.


Process Of BDD
The process involved in BDD methodology also consists of 6 steps and is very similar to that of TDD.

1) Write the behavior of the application: The behavior of an application is written in simple English like language by the product owner or the business analysts or QAs.

2) Write the automated scripts: This simple English like language is then converted into programming tests.

3) Implement the functional code: The functional code underlying the behavior is then implemented.

4) Check if the behavior is successful: Run the behavior and see if it is successful. If successful, move to the next behavior otherwise fix the errors in the functional code to achieve the application behavior.

5) Refactor or organize code: Refactor or organize your code to make it more readable and re-usable.

6) Repeat the steps 1-5 for new behavior: Repeat the steps to implement more behaviors in your application.
Some of the tools which support BDD are SpecFlow, Cucumber, MSpec, etc.

## TDD Vs BDD

TDD focuses on how the functionality is implemented. But BDD focuses on the behavior of an application for the end user.
In TDD Test cases are written in a programming language.But for BDD	Scenarios are more readable when compared to TDD as they are written in simple English format.
TDD reduces the likelihood of having bugs in your tests. For BDD bugs in tests are difficult to track when compared to TDD.
TDD might be a better approach for projects which involve API and third-party tools.
And BDD might be a better approach for projects which are driven by user actions. For eg: e-commerce website, application system, etc.




## Automated Testing in Ruby on Rails
 - About Rspec
RSpec is a Behaviour-Driven Development tool for Ruby programmers. 
BDD is an approach to software development that combines Test-Driven Development, Domain Driven Design, and Acceptance Test-Driven Planning.
RSpec helps you do the TDD part of that equation,focusing on the documentation and design aspects of TDD.

- Generators 
RSpec spec are normally generated alongside other application components.
For instance, rails generate model will also generate an RSpec spec file
for the model.

Note that the generators are there to help you get started, but they are no substitute for writing your own examples, and they are only guaranteed to work out of the box for with Rails' defaults.

RSpec generators can also be run independently. For instance,

rails generate rspec:model widget
The same generator pattern is available for all specs:

scaffold
model
controller
helper
view
mailer
integration
feature
job
channel
generator
mailbox
request
system

-Directory Structure
Specs are usually placed in a canonical directory structure that describes
their purpose:
Model specs reside in the spec/models directory
Controller specs reside in the spec/controllers directory
Request specs reside in the spec/requests directory. The directory can also be named integration or api.
Feature specs reside in the spec/features directory
View specs reside in the spec/views directory
Helper specs reside in the spec/helpers directory
Mailer specs reside in the spec/mailers directory
Routing specs reside in the spec/routing directory
Job specs reside in the spec/jobs directory

System specs reside in the spec/system directory
In order to include the correct rspec-rails support functions, the specs need to have the appropriate corresponding metadata :type value:
Eg for in the line 
"RSpec.describe ThingsController, type: :controller"


Model specs: type: :model
Controller specs: type: :controller
Request specs: type: :request
Feature specs: type: :feature
View specs: type: :view
Helper specs: type: :helper
Mailer specs: type: :mailer
Routing specs: type: :routing
Job specs: type: :job
System specs: type: :system


- Transactions
spec/rails_helper.rb have the following line
"config.use_transactional_fixtures = true" 

For in Rails it means is "run every test method within a transaction." 
But in the context of rspec-rails, it means "run every example within a transaction."
It is different because of the idea in rspec is to start each example with a clean database, create whatever data is necessary for that example, and then remove that data by simply rolling back the transaction at the end of the example.
It can be turend of and instead of this can use gem like database_cleaner.

We use before block inside of the rpspec describe block to define the object on which the testing is to be done there are 2 option for before block 
:example
:context

Data created in before(:example) are rolled back
Any data you create in a before(:example) hook will be rolled back at the end of the example. 
This is a good thing because it means that each example is isolated from state that would otherwise be left around by the examples that already ran.
So for every it block it swill create different object and will rollback it,so each example has a different object, and the underlying data is rolled back so the data backing the @widget in each example is new.

But for Data created in before(:context) are not rolled back
before(:context) hooks are invoked before the transaction is opened. You can use this to speed things up by creating data once before any example in a group is run.

But This also creates complication 
1. We have to make sure to  clean up any data in an after(:context) hook
before(:context) do
  @widget = Widget.create!
end

after(:context) do
  @widget.destroy
end
It is not done it will leave data lying around that will eventually interfere with other examples.

2. Reload the object in a before(:example) hook.
before(:context) do
  @widget = Widget.create!
end

before(:example) do
  @widget.reload
end
Even though database updates in each example will be rolled back, the
object won't know about those rollbacks so the object and its backing
data can easily get out of sync.

## Model specs
Model specs are marked by :type => :model or if you have set
config.infer_spec_type_from_file_location! by placing them in spec/models.

A model spec is a thin wrapper for an ActiveSupport::TestCase, and includes all
of the behavior and assertions that it provides, in addition to RSpec's own
behavior and expectations.

base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ rails g rspec:model employee
DEPRECATION WARNING: The factory_girl gem is deprecated. Please upgrade to factory_bot. See https://github.com/thoughtbot/factory_bot/blob/v4.9.0/UPGRADE_FROM_FACTORY_GIRL.md for further instructions. (called from block (2 levels) in require at /usr/share/rvm/rubies/ruby-3.0.0/lib/ruby/site_ruby/3.0.0/bundler/runtime.rb:60)
[Warning] Failed to detect RailsAdmin npm package, did you run 'yarn install'?
      create  spec/models/employee_spec.rb
      invoke  factory_girl
      create    spec/factories/employees.rb



## Controller specs
Controller specs are marked by :type => :controller or if you have set
config.infer_spec_type_from_file_location! by placing them in spec/controllers.

A controller spec is an RSpec wrapper for a Rails functional test
(ActionController::TestCase::Behavior).
It allows you to simulate a single http request in each example, and then specify expected outcomes such as:

rendered templates
redirects
instance variables assigned in the controller to be shared with the view cookies sent back with the response To specify outcomes, you can use:

standard rspec matchers (expect(response.status).to eq(200))
standard test/unit assertions (assert_equal 200, response.status)
rails assertions (assert_response 200)
rails-specific matchers:

render_template

expect(response).to render_template(:new)   # wraps assert_template
redirect_to

expect(response).to redirect_to(location)   # wraps assert_redirected_to
have_http_status

expect(response).to have_http_status(:created)
be_a_new

expect(assigns(:widget)).to be_a_new(Widget)


(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ rspec spec/models/employee_spec.rb 
DEPRECATION WARNING: The factory_girl gem is deprecated. Please upgrade to factory_bot. See https://github.com/thoughtbot/factory_bot/blob/v4.9.0/UPGRADE_FROM_FACTORY_GIRL.md for further instructions. (called from block (2 levels) in require at /usr/share/rvm/rubies/ruby-3.0.0/lib/ruby/site_ruby/3.0.0/bundler/runtime.rb:60)
[Warning] Failed to detect RailsAdmin npm package, did you run 'yarn install'?
DEPRECATION WARNING: The factory_girl gem is deprecated. Please upgrade to factory_bot. See https://github.com/thoughtbot/factory_bot/blob/v4.9.0/UPGRADE_FROM_FACTORY_GIRL.md for further instructions. (called from block (2 levels) in require at /usr/share/rvm/rubies/ruby-3.0.0/lib/ruby/site_ruby/3.0.0/bundler/runtime.rb:60)
[Warning] Failed to detect RailsAdmin npm package, did you run 'yarn install'?
*

Pending: (Failures listed here are expected and do not affect your suite's status)

  1) Employee  is valid 
     # Not yet implemented
     # ./spec/models/employee_spec.rb:4


Finished in 0.00104 seconds (files took 1.57 seconds to load)
1 example, 0 failures, 1 pending

(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ rails generate rspec:controller aircrafts
      create  spec/requests/aircrafts_spec.rb




## Test Your Ruby Code With RSpec
Rspec is ruby testing framework which is very famous
rspec.info
generate gem in project using => bundle init
gem 'rspec', '~>3.0'

(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ gem install rspec
Fetching rspec-mocks-3.11.1.gem
Fetching rspec-3.11.0.gem
Fetching rspec-expectations-3.11.0.gem
Fetching rspec-support-3.11.0.gem
Fetching rspec-core-3.11.0.gem
Successfully installed rspec-support-3.11.0
Successfully installed rspec-mocks-3.11.1
Successfully installed rspec-expectations-3.11.0
Successfully installed rspec-core-3.11.0
Successfully installed rspec-3.11.0
Parsing documentation for rspec-support-3.11.0
Installing ri documentation for rspec-support-3.11.0
Parsing documentation for rspec-mocks-3.11.1
Installing ri documentation for rspec-mocks-3.11.1
Parsing documentation for rspec-expectations-3.11.0
Installing ri documentation for rspec-expectations-3.11.0
Parsing documentation for rspec-core-3.11.0
Installing ri documentation for rspec-core-3.11.0
Parsing documentation for rspec-3.11.0
Installing ri documentation for rspec-3.11.0
Done installing documentation for rspec-support, rspec-mocks, rspec-expectations, rspec-core, rspec after 1 seconds
5 gems installed

(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ rspec -v
RSpec 3.11
  - rspec-core 3.11.0
  - rspec-expectations 3.11.0
  - rspec-mocks 3.11.1
  - rspec-support 3.11.0

(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ bundle binstubs rspec-core
Resolving dependencies...


require 'rspec/autorun'

# then have to write describe block which club toger all the test for the class in one block
describe ClassName do

end


## code 1
class Calculator
  def add(a,b)

  end 

end


describe Calculator do
  it "adds two numbers" do
    calculator = Calculator.new

    expect(calculator.add(2,3)to eq(5))
  end
end

- Result
(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ ruby calculator.rb 
F

Failures:

  1) Calculator adds two numbers
     Failure/Error: expect(calculator.add(2,3)).to eq(5)
     
       expected: 5
            got: nil
     
       (compared using ==)
     # calculator.rb:15:in `block (2 levels) in <main>'

Finished in 0.02294 seconds (files took 0.04687 seconds to load)
1 example, 1 failure

Failed examples:

rspec calculator.rb:12 # Calculator adds two numbers

## code 2
class Calculator
  def add(a,b)
    a+b
  end 

end


describe Calculator do
  it "adds two numbers" do
    calcualtor = Calculator.new

    expect(calculator.add(2,3)to eq(5))
  end
end

- Result
(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ ruby calculator.rb 
.

Finished in 0.00135 seconds (files took 0.04651 seconds to load)
1 example, 0 failures




## 
(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ bin/rspec --init
  create   .rspec
  create   spec/spec_helper.rb

Rspec results comes in yellow it means it is pending which is it does not have its block
(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ bin/rspec
*

Pending: (Failures listed here are expected and do not affect your suite's status)

  1) Bouncer rejects xx from entring the venue
     # Not yet implemented
     # ./spec/bouncer_spec.rb:2


Finished in 0.00217 seconds (files took 0.04559 seconds to load)
1 example, 0 failures, 1 pending

After creating block
(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ bin/rspec
F

Failures:

  1) Bouncer rejects xx from entring the venue
     Failure/Error: b = Bouncer.new
     
     NameError:
       uninitialized constant Bouncer
     # ./spec/bouncer_spec.rb:3:in `block (2 levels) in <top (required)>'

Finished in 0.00176 seconds (files took 0.04639 seconds to load)
1 example, 1 failure

Failed examples:

rspec ./spec/bouncer_spec.rb:2 # Bouncer rejects xx from entring the venue 



Setting up Rspec
Step 1 — Delete Any Existing Test Folders
If  generated a new rails app using rails new <app> without using any additional flags, remove the app/test directory

base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ bundle
Your Gemfile lists the gem capybara (>= 0) more than once.
You should probably keep only one of them.
Remove any duplicate entries and specify the gem only once.
While it's not a problem now, it could cause errors if you change the version of one of them later.
Fetching gem metadata from https://rubygems.org/..........
Resolving dependencies...
Installing database_cleaner-core 2.0.1
Installing rspec-support 3.9.4 (was 3.11.0)
Installing factory_girl 4.9.0
Fetching rspec-core 3.9.3 (was 3.11.0)
Fetching rspec-expectations 3.9.4 (was 3.11.0)
Fetching rspec-mocks 3.9.1 (was 3.11.1)
Installing byebug 11.1.3 with native extensions
Fetching database_cleaner-active_record 2.0.1
Fetching factory_girl_rails 4.9.0
Installing database_cleaner-active_record 2.0.1
Fetching database_cleaner 2.0.1
Installing rspec-mocks 3.9.1 (was 3.11.1)
Installing rspec-expectations 3.9.4 (was 3.11.0)
Installing factory_girl_rails 4.9.0
Installing rspec-core 3.9.3 (was 3.11.0)
Fetching rspec-rails 3.9.1
Installing rspec-rails 3.9.1
Installing database_cleaner 2.0.1
Bundle complete! 29 Gemfile dependencies, 110 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.

Step 2 — Add Gems
 add the following gems to the :development, :test group in my Gemfile and run bundle.

group :development, :test do
  gem 'byebug', platform: :mri
  gem 'rspec-rails', '~> 3.5'
  gem 'factory_girl_rails'
  gem 'capybara'
  gem 'database_cleaner'
end
Briefly running through these gems one-by-one:

byebug allows for step-through debugging by placing byebug anywhere in the app.
rspec-rails is the testing framework.
factory_girl_rails replaces Rails fixtures for generating data to use in the tests.
capybara provides helper methods that make integration testing easier.
database_cleaner allows us to manage our testing database with precision: we decide when to wipe data (e.g. after, before tests).

Step 3 — Run Rspec Generator
Currently, the app directory doesn’t include a app/test/ directory (remember we deleted it in step 1). This is where the Rspec generator, which will generate app/spec/, comes in:

rails generate rspec:install
This adds the following files in a app/spec directory:

spec/spec_helper.rb
spec/rails_helper.rb
and app/.rspec in the project’s root directory.




Created the new Model department to see rspec created new files other than what is rails default and created 2 test for it and using rspec in the developmnet environment.



 Pending: (Failures listed here are expected and do not affect your suite's status)

  1) Department is not valid without a name
     # Not yet implemented
     # ./spec/models/department_spec.rb:4

  2) Department is not valid without a description
     # Not yet implemented
     # ./spec/models/department_spec.rb:5


Finished in 0.00139 seconds (files took 1.62 seconds to load)
2 examples, 0 failures, 2 pending



Aircraft rspec test cases 
(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ rspec spec/models/aircraft_spec.rb 
.*

Pending: (Failures listed here are expected and do not affect your suite's status)

  1) Aircraft is not valid without a name
     # Not yet implemented
     # ./spec/models/aircraft_spec.rb:10


Finished in 0.01639 seconds (files took 1.48 seconds to load)
2 examples, 0 failures, 1 pending

(base) itsacheckmate@itsacheckmate:~/Training/Rails/airport$ rspec spec/models/aircraft_spec.rb 
Finished in 0.01838 seconds (files took 1.56 seconds to load)
2 examples, 0 failures


Since our specs are passing, we’ve reached the green step of the red-green-refactor flow. It’s time to refactor our examples. 
This refactoring step is quite simple.
We’ll add a subject to our specs, which will be the main object under test in this spec file. 
After that, we will appropriately set the object attributes in the examples

So here subject is the testing subject—meaning that it will be the object upon which our examples will set expectations.
Continuous Integration (CI) is a software development practice in which the code is continually tested on an automated CI Pipeline. Teams using CI enjoy the benefits of having the code continually tested, they can merge changes more often, usually many times a day. A good CI setup raises the bar of software quality considerably.

Fixtures are data that you can feed into your unit testing. 
They are automatically created whenever rails generates the corresponding tests for your controllers and models. 
They are only used for your tests and cannot actually be accessed when running the application.

Factory Girl
Fixtures are data that you can feed into your unit testing. 
They are automatically created whenever rails generates the corresponding tests for your controllers and models. 
They are only used for your tests and cannot actually be accessed when running the application.
This gem provides a clean syntax for creating new model instances and lets you manage the attributes from a single fixture file. 
FactoryGirl enables you to:
- Create new model instances from a fixture file
- Interact with the test database to create test data
- Automatically generate fixtures when you run Rails generators
- Allow for automatic database relationship connections, e.g. you can have a fixture for a Post that has a belongs_to relationship to an Author and call them in specs the same way you call them in the application
- Store the created values in variables
- Create multiple fixtures for each model

Build works as the new  and does not insert record but create works same as create and insert the record.

Loading development environment (Rails 7.0.3.1)
3.0.0 :001 > FactoryGirl.build(:aircraft)
 => 
#<Aircraft:0x000056023ac18490                                                                              
 id: nil,                                                                                                  
 name: "Airmax",                                                                                           
 cruising_range: 1300,                                                                                     
 created_at: nil,                                                                                          
 updated_at: nil,                                                                                          
 aircraft_updated_at: nil,                                                                                 
 certifieds_count: 0,                                                                                      
 place: "Delhi",                                                                                           
 availability: nil> 

 3.0.0 :002 > FactoryGirl.create(:aircraft)
  TRANSACTION (0.2ms)  BEGIN
  Aircraft Create (7.1ms)  INSERT INTO "aircrafts" ("name", "cruising_range", "created_at", "updated_at", "aircraft_updated_at", "certifieds_count", "place") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"  [["name", "Airmax"], ["cruising_range", 1300], ["created_at", "2022-08-05 22:17:31.742447"], ["updated_at", "2022-08-05 22:17:31.742447"], ["aircraft_updated_at", nil], ["certifieds_count", 0], ["place", "Delhi"]]
  TRANSACTION (0.7ms)  COMMIT                                                 
 =>                                                                           
#<Aircraft:0x000056023a8494e0                                                 
 id: 37,                                                                      
 name: "Airmax",                                                              
 cruising_range: 1300,                                                        
 created_at: Fri, 05 Aug 2022 22:17:31.742447000 IST +05:30,                  
 updated_at: Fri, 05 Aug 2022 22:17:31.742447000 IST +05:30,                  
 aircraft_updated_at: nil,                                                    
 certifieds_count: 0,                                                         
 place: "Delhi",
 availability: nil> 

## Using Sequnces

Global sequences
Unique values in a specific format (for example, e-mail addresses) can be generated using sequences. Sequences are defined by calling sequence in a definition block, and values in a sequence are generated by calling generate

- Defines a new sequence
FactoryBot.define do
  sequence :email do |n|
    "person#{n}@example.com"
  end
end

generate :email
# => "person1@example.com"

generate :email
# => "person2@example.com"

- With dynamic attributes
Sequences can be used in dynamic attributes:

factory :invite do
  invitee { generate(:email) }
end
- As implicit attributes
Or as implicit attributes:

factory :user do
  email # Same as `email { generate(:email) }`
end
Note that defining sequences as implicit attributes will not work if you have a factory with the same name as the sequence.

- Inline sequences
And it's also possible to define an in-line sequence that is only used in a particular factory:

factory :user do
  sequence(:email) { |n| "person#{n}@example.com" }
end
- Initial value
You can override the initial value. Any value that responds to the #next method will work (e.g. 1, 2, 3, 'a', 'b', 'c')

factory :user do
  sequence(:email, 1000) { |n| "person#{n}@example.com" }
end


Using of inline sequence in the Aircraft factory
using build 

3.0.0 :020 > FactoryGirl.build(:aircraft)
 => 
 id: nil,
 name: "Airmax-20",
 cruising_range: 1300,
 created_at: nil,
 updated_at: nil,
 aircraft_updated_at: nil,
 certifieds_count: 0,
 place: "Delhi",
 availability: nil> 
3.0.0 :021 > FactoryGirl.build(:aircraft)
 => 
 id: nil,
 name: "Airmax-21",
 cruising_range: 1300,
 created_at: nil,
 updated_at: nil,
 aircraft_updated_at: nil,
 certifieds_count: 0,
 place: "Delhi",
 availability: nil> 
3.0.0 :022 > FactoryGirl.build(:aircraft)
 => 
 id: nil,
 name: "Airmax-22",
 cruising_range: 1300,
 created_at: nil,
 updated_at: nil,
 aircraft_updated_at: nil,
 certifieds_count: 0,
 place: "Delhi",
 availability: nil> 


- using  create
3.0.0 :024 > FactoryGirl.create(:aircraft)
  TRANSACTION (0.4ms)  BEGIN
  
  Aircraft Create (1.3ms)  INSERT INTO "aircrafts" ("name", "cruising_range", "created_at", "updated_at", "aircraft_updated_at", "certifieds_count", "place") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"  [["name", "Airmax-24"], ["cruising_range", 1300], ["created_at", "2022-08-08 13:51:14.657482"], ["updated_at", "2022-08-08 13:51:14.657482"], ["aircraft_updated_at", nil], ["certifieds_count", 0], ["place", "Delhi"]]
  TRANSACTION (0.5ms)  COMMIT                                                 
 =>  

 #<Aircraft:0x000055ce45d3fa40
  id: 38,
  name: "Airmax-24",
  cruising_range: 1300,
  created_at: Mon, 08 Aug 2022 13:51:14.657482000 IST +05:30,
  updated_at: Mon, 08 Aug 2022 13:51:14.657482000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 0,
  place: "Delhi",
  availability: Mon, 08 Aug 2022 13:51:14.659052000 IST +05:30>] 


  ## Using factories
factory_girl supports several different build strategies: build, create, attributes_for and build_stubbed:

- Returns a User instance that's not saved
user = build(:user)

- Returns a saved User instance
user = create(:user)

- Returns a hash of attributes that can be used to build a User instance
attrs = attributes_for(:user)

- Returns an object with all defined attributes stubbed out
stub = build_stubbed(:user)

- Passing a block to any of the methods above will yield the return object
create(:user) do |user|
  user.posts.create(attributes_for(:post))
end
No matter which strategy is used, it's possible to override the defined attributes by passing a hash:

- Build a User instance and override the first_name property
user = build(:user, first_name: "Joe")
user.first_name
 => "Joe"
Factory is something that can create multiple objects. Thus, a factory for Article would be some way of creating many article instances when we need them.

FactoryGirl does just that.

FactoryGirl.build(:article) - creates an instance of a real Article model, which is equivalent to Article.new
FactoryGirl.create(:article) - creates an instance and saves to to the database, which is equivalent to Article.create
This is useful, because FactoryGirl has a handful of methods for creating many instances with predefined field values and even associations.
Since these are instances of a real model, they will have all the instance variables and methods.
FactoryGirl.build_stubbed(:article) - is a shiny new method from FactoryGirl.
It creates non-persisted instance just as #build, but makes it look, as though it is persisted, by assigning an :id field.
It intercepts all the calls to the database and raises an error. This way you know that your test is accessing the database, when it probably should not.
If your factory contains associations, calling :build_stubbed would also call :build_stubbed when building associated models, unlike :build, which calls :create on associated models.

So, what to choose?
- Saving an instance to the database is longer, than just instantiating it. Therefore, prefer to use FactoryGirl.build or build_stubbed over FactoryGirl.create, unless your tests rely on the instance to be saved in the database, because the database is queried for it, for example.
- using FactoryGirl.build_stubbed to control the access to the database.

 3.0.0 :035 > FactoryGirl.attributes_for(:aircraft)
 => {:name=>"Airmax-31", :cruising_range=>1300} 
3.0.0 :036 > FactoryGirl.attributes_for(:aircraft)
 => {:name=>"Airmax-32", :cruising_range=>1300} 
3.0.0 :037 > FactoryGirl.attributes_for(:aircraft)
 => {:name=>"Airmax-33", :cruising_range=>1300} 



 3.0.0 :038 > FactoryGirl.build(:aircraft)
 => 
#<Aircraft:0x000055ce45cfd988
 id: nil,
 name: "Airmax-34",
 cruising_range: 1300,
 created_at: nil,
 updated_at: nil,
 aircraft_updated_at: nil,
 certifieds_count: 0,
 place: "Delhi",
 availability: nil> 
3.0.0 :039 > FactoryGirl.build_stubbed(:aircraft)
 => 
#<Aircraft:0x000055ce43f81008
 id: 1003,
 name: "Airmax-35",
 cruising_range: 1300,
 created_at: nil,
 updated_at: nil,
 aircraft_updated_at: nil,
 certifieds_count: 0,
 place: "Delhi",
 availability: nil> 

## Dynamic Attributes
Most factory attributes can be added using static values that are evaluated when the factory is defined, but some attributes (such as associations and other attributes that must be dynamically generated) will need values assigned each time an instance is generated. These "dynamic" attributes can be added by passing a block instead of a parameter:

factory :user do
  # ...
  activation_code { User.generate_activation_code }
  date_of_birth   { 21.years.ago }
end
Because of the block syntax in Ruby, defining attributes as Hashes (for serialized/JSON columns, for example) requires two sets of curly brackets:

factory :program do
  configuration { { auto_resolve: false, auto_define: true } }
end

## Aliases
factory_girl allows you to define aliases to existing factories to make them easier to re-use. This could come in handy when, for example, your Post object has an author attribute that actually refers to an instance of a User class. While normally factory_girl can infer the factory name from the association name, in this case it will look for a author factory in vain. So, alias your user factory so it can be used under alias names.

factory :user, aliases: [:author, :commenter] do
  first_name    "John"
  last_name     "Doe"
  date_of_birth { 18.years.ago }
end

factory :post do
  author
  # instead of
  # association :author, factory: :user
  title "How to read a book effectively"
  body  "There are five steps involved."
end

factory :comment do
  commenter
  # instead of
  # association :commenter, factory: :user
  body "Great article!"
end


## Routing specs
Routing specs are marked by :type => :routing or if you have set
config.infer_spec_type_from_file_location! by placing them in spec/routing.

Simple apps with nothing but standard RESTful routes won't get much value from
routing specs, but they can provide significant value when used to specify
customized routes, like vanity links, slugs, etc.

## Mailer specs
By default Mailer specs reside in the spec/mailers folder. Adding the metadata
:type => :mailer to any context makes its examples be treated as mailer specs.

A mailer spec is a thin wrapper for an ActionMailer::TestCase, and includes all
of the behavior and assertions that it provides, in addition to RSpec's own
behavior and expectations

RSpec-Rails MAtchers
Models
obj.should be_valid
obj.should have(n).errors_on(:field)
obj.errors.on(:field).should == "is required"
General
response.should be_valid
response.should_not be_valid

response.should be_success
response.should be_redirect

response.should redirect_to("path/to/action")
response.should redirect_to("http://test.host/path/to/action")
response.should redirect_to(:action => 'list')

response.should render_template('list')
response.should render_template('same_controller/list')
response.should render_template('other_controller/list')

# partials
response.should render_template('_a_partial')
response.should render_template('same_controller/_a_partial')
response.should render_template('other_controller/_a_partial')
Routing
"path".should route_to(expected) # assumes GET
{ :get => "path" }.should route_to(expected)
{ :put => "path" }.should route_to(expected)

{ "path" }.should_not be_routable # assumes GET
{ :get => "path" }.should_not be_routable
{ :put => "path" }.should_not be_routable
Content
response.should have_tag("div", "some text")
person_address_tag.should have_tag("input#person_address") # in a helper

response.should have_tag("div#form") do
  with_tag("input#person_name[name=?]", "person[name]")
end

response.should have_tag("div#1") do
  without_tag("span", "some text that shouldn't be there")
end

response.should include_text("This text will be in the actual string")
Mail
response.should send_email(*args, &block)
rspec-expectations.md



## RSpec Expectations
Built-in matchers
Equivalence
actual.should eq(expected)  # passes if actual == expected
actual.should == expected   # passes if actual == expected
actual.should eql(expected) # passes if actual.eql?(expected)
Identity
actual.should be(expected)    # passes if actual.equal?(expected)
actual.should equal(expected) # passes if actual.equal?(expected)
Comparisons
actual.should be >  expected
actual.should be >= expected
actual.should be <= expected
actual.should be <  expected
actual.should be_within(delta).of(expected)
Regular expressions
actual.should =~ /expression/
actual.should match(/expression/)
Types/classes
actual.should be_an_instance_of(expected)
actual.should be_a_kind_of(expected)
Truthiness
actual.should be_true  # passes if actual is truthy (not nil or false)
actual.should be_false # passes if actual is falsy (nil or false)
actual.should be_nil   # passes if actual is nil
Expecting errors
expect { ... }.to raise_error
expect { ... }.to raise_error(ErrorClass)
expect { ... }.to raise_error("message")
expect { ... }.to raise_error(ErrorClass, "message")
Expecting throws
expect { ... }.to throw_symbol
expect { ... }.to throw_symbol(:symbol)
expect { ... }.to throw_symbol(:symbol, 'value')
Predicate matchers
actual.should be_xxx         # passes if actual.xxx?
actual.should have_xxx(:arg) # passes if actual.has_xxx?(:arg)
Ranges (Ruby >= 1.9 only)
(1..10).should cover(3)
Collection membership
actual.should include(expected)
actual.should start_with(expected)
actual.should end_with(expected)
Examples
[1,2,3].should include(1)
[1,2,3].should include(1, 2)
[1,2,3].should start_with(1)
[1,2,3].should start_with(1,2)
[1,2,3].should end_with(3)
[1,2,3].should end_with(2,3)
{:a => 'b'}.should include(:a => 'b')
"this string".should include("is str")
"this string".should start_with("this")
"this string".should end_with("ring")


## Rspec: Writing Custom Matchers
A custom matcher allows us to create custom assertions for our specs (that are not included by default in rspec).
Writing your matcher
You can just add your custom matcher to the spec_helper.rb file of your project (or to something else and import it there).
We have a section to define the boolean expression that defines if your expected (the object that goes into the expect method) matches your actual (the one that is passed into your matcher).
Then, on the failure_message section we define what is the output we should display to our users if our assertion fails (in other words: if our boolean expression defined previously returns false).

## RSpec Let vs Before

In RSpec, there are two different ways to write DRY tests, by using before or let. Their purpose is to create variables that are common across tests

- let
let creates lazily-evaluated local variables. This means that let() is not evaluated until the method that it formed is run for the first time. It DRYs up the spec and makes it more readable.
let should not be used for local variables, which have to be saved to the database, as they will not be saved to the database unless they have already been referenced. In this case, you should use let! or before blocks.
Also, never have a let block inside of a before the block, this is what let! is made for!
  let(:count) { $count += 1 }

- let!
Unlike let, you can use let! to force the method's invocation before each example.
It means that even if you didn't invoke the helper method inside the example it will be invoked before your example runs.As with let blocks, if multiple let! blocks are defined with the same name, the most recent one will be executed. 
The core difference is that  let! blocks will be executed multiple times if used like this, whereas the let block will only execute the last time.
 let!(:count) do
    invocation_order << :let!
    $count += 1
  end

- before (: each)
The before (: each) block will run before each example, even if the example does not use any of the instance variables defined in the block. This can noticeably slow down the setup of the instance variables.
In nearly every situation, it is better to use let over before blocks. Depending on your personal preference you could use before blocks when:
There is a reasonable amount of variables.
There are variables that don't need to be referenced directly but are required.
There are many commands to be executed because its syntax is clearer when many commands are involved.
Creating mocks/stubs.
  before(:each) do
    @user = User.new
  end

- before (: all)
This block is executed only once, before all of the examples in a group. There are certain situations this can cut down on execution and effort.
Using runs (: all) in RSpec will cause you lots of trouble unless you know what you are doing! It runs outside of transactions, so the data created here will bleed into other specs.

Difference
Let blocks bring more to the table than before blocks. It all depends on what and how you need to make the RSpec tests.
Besides being slower, one of the major problems with before blocks is that spelling errors can lead to bugs and false positives, allowing certain types of tests to pass when they shouldn't
  before(:all) do
    @user = User.new
  end


## Rspec Test Double

A test double is a simplified version of an object that allows us to define “fake” methods and their return values.
RSpec Doubles, also known as RSpec Mocks. A Double is an object which can “stand in” for another object
 “test double” as an umbrella term for the following four terms:

Mocks: Expectations about method calls, verifying them, and faking returning a value
Stubs: Fake responses to method calls
Fake: Objects with a working implementation that is useful for tests
Spies: Verifying that a stubbed method has been called before

Stubs
By definition:
A method stub is an implementation that returns a pre-determined value.
This means that we can say RSpec to preventively define the return value of an object method without actually call it.

Mock
A mock is a stub with a built-in expectation to be satisfied during the test.

Spies
Spies are objects that by default can accept all methods without throwing any exception and keep an history of the methods called on them.

Here’s some simple rules to keep in mind when we need to choose the right test double in our specs:

Choose to stub (using allow) when you want to stub something into the setup phase, which usually is a prerequisite of what you want to test;
Choose to mock or spy (using expect) when the stubbed method is also a method you want to test;
Choose to use a verifying double when you need to be sure that the method you are stubbing remains consistent with its real implementation.

## Feature specs vs model specs
Speaking loosely, model specs test ActiveRecord models by themselves and feature specs test the whole “stack” including model code, controller code, and any HTML/CSS/JavaScript together. 
Neither type of spec is better or worse (and it’s not an “either/or” situation anyway), the two types of specs just have different strengths and weaknesses in different scenarios.
## The strengths and weaknesses of model specs
An advantage of model specs is that they’re “inexpensive”. 
Compared to feature specs, model specs are relatively fast to run and relatively fast to write. 
It tends to be slower to actually load the pages of an application and switch among them than to just test model code by itself with no browser involved. 
That’s an advantage of model specs. 
A disadvantage of model specs is that they don’t tell you anything about whether your whole application actually works from the user’s perspective. 
Rails model works perfectly by itself but doesn’t have have any working HTML/CSS/JavaScript plugged into that model to make the whole application work.
In such a case the model specs could pass even though there’s no working feature built on top of the model code.

## The strengths and weaknesses of feature specs
Feature specs have basically the opposite pros and cons. 
Unlike model specs, feature specs do tell you whether all the parts of your application are working together. 
There’s a cost to this, though, in that feature specs are relatively “expensive”. 
Feature specs are relatively time-consuming to run because you’re running more stuff than in a model spec. (It’s slower to have to bring up a web browser than to not have to.) 
Feature specs are also relatively time-consuming to write. 
The reason feature specs are time-consuming to write is that, unlike a model spec where you can exercise e.g. just one method at a time, a feature spec has to exercise a whole feature at a time. 
In order to test a feature it’s often necessary to have certain non-trivial conditions set up—if  want to test.
This necessity makes the feature spec slower to write and slower to run than a model spec where you could test e.g. a method on a `Stylist` class all by itself.

