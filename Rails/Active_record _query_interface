Active Record Query Interface

It is the different ways to retrieve data from the database using Active Record. 
Instead of using the sql queries can use use to same things via Active record methods

## Retrieving Objects from the Database
To retrieve objects from the database, Active Record provides several finder methods.
The methods are:

annotate
find
create_with
distinct
eager_load
extending
extract_associated
from
group
having
includes
joins
left_outer_joins
limit
lock
none
offset
optimizer_hints
order
preload
readonly
references
reorder
reselect
reverse_order
select
where

Finder methods that return a collection, such as where and group, return an instance of ActiveRecord::Relation.
3.0.0 :004 > aircrafts = Aircraft.where("id > 4" )
  Aircraft Load (7.2ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE (id > 4)
 =>                                                                                          
[#<Aircraft:0x000055fd7b227c38                                                               
... 
3.0.0 :005 > aircrafts.class
 => Aircraft::ActiveRecord_Relation 


Methods that find a single entity, such as find and first, return a single instance of the model.
3.0.0 :006 > air = Aircraft.find(4)
  Aircraft Load (0.2ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE "aircrafts"."id" = $1 LIMIT $2  [["id", 4], ["LIMIT", 1]]                                                            
 =>                                                                   
#<Aircraft:0x000055fd7b1dfde8                                         
...  
3.0.0 :007 > air.class
 => Aircraft(id: integer, name: text, cruising_range: integer, created_at: datetime, updated_at: datetime, aircraft_updated_at: datetime, certifieds_count: integer)  

 So the operation steps are as followed
 The primary operation of Model.find(options) can be summarized as:

1 Convert the supplied options to an equivalent SQL query.
2 Fire the SQL query and retrieve the corresponding results from the database.
3 Instantiate the equivalent Ruby object of the appropriate model for every resulting row.
4 Run after_find and then after_initialize callbacks, if any.

1. annotate
Adds an SQL comment to queries generated from this relation.
3.0.0 :008 > Aircraft.annotate("selecting aircraft names").select(:name)
  Aircraft Load (0.6ms)  SELECT "aircrafts"."name" FROM "aircrafts" /* selecting aircraft names */''
 =>                                                         
[#<Aircraft:0x00007f2744d63090 id: nil, name: "Airbus320">, 
 #<Aircraft:0x00007f2744d62fa0 id: nil, name: "Boeing737">, 
 #<Aircraft:0x00007f2744d62eb0 id: nil, name: "Jet01">,     
 #<Aircraft:0x00007f2744d62de8 id: nil, name: "Airbus380">, 
 #<Aircraft:0x00007f2744d62d20 id: nil, name: "Boeing777">, 
 #<Aircraft:0x00007f2744d62c08 id: nil, name: "PrivateCraft">,
 #<Aircraft:0x00007f2744d62af0 id: nil, name: "Aircraft200">,
 #<Aircraft:0x00007f2744d62a28 id: nil, name: nil>] 


 ## Retrieving a Single Object
  
  
  1. find
  Using the find method, it retrieve the object corresponding to the specified primary key that matches any supplied options
  The find method will raise an ActiveRecord::RecordNotFound exception unless a matching record is found for all of the supplied primary keys.
  3.0.0 :011 > Aircraft.find(1)
  Aircraft Load (0.7ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE "aircrafts"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                                      
 =>                                                             
#<Aircraft:0x00007f2744ab9470                                   
 id: 1,                                                         
 name: "Airbus320",                                             
 cruising_range: 1234566,                                       
 created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,    
 updated_at: Mon, 06 Jun 2022 13:40:48.895413000 UTC +00:00,    
 aircraft_updated_at: nil,                                      
 certifieds_count: 1>  

 can also use this method to query for multiple objects. Call the find method and pass in an array of primary keys. 
 The return will be an array containing all of the matching records for the supplied primary keys.
 3.0.0 :012 > keys = [1,2,3,4]
 => [1, 2, 3, 4] 
3.0.0 :013 > Aircraft.find(keys)
  Aircraft Load (0.8ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE "aircrafts"."id" IN ($1, $2, $3, $4)  [["id", 1], ["id", 2], ["id", 3], ["id", 4]]                                                  
 =>                                                             
[#<Aircraft:0x00007f27444bc180                                  
  id: 1,                                                        
  name: "Airbus320",                                            
  cruising_range: 1234566,                                      
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,   
  updated_at: Mon, 06 Jun 2022 13:40:48.895413000 UTC +00:00,   
  aircraft_updated_at: nil,                                     
  certifieds_count: 1>,                                         
 #<Aircraft:0x00007f27444bc068
  id: 2,
  name: "Boeing737",
  cruising_range: 5000,
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  aircraft_updated_at: nil,
  certifieds_count: 3>,
 #<Aircraft:0x000055fd7aa55e88
  id: 3,
  name: "Jet01",
  cruising_range: 5000,
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  aircraft_updated_at: nil,
  certifieds_count: 3>,
 #<Aircraft:0x00007f2744740be0
  id: 4,
  name: "Airbus380",
  cruising_range: 8000,
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  aircraft_updated_at: nil,
  certifieds_count: 2>

2 take
The take method retrieves a record without any implicit ordering
The take method returns nil if no record is found and no exception will be raised.

3.0.0 :035 > Certified.take
  Certified Load (0.4ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 1]]
 =>                           
#<Certified:0x00007f2744bb0ec8
 id: 3,                       
 aircraft_id: 3,              
 created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
 updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00> 
3.0.0 :036 > Certified.take(1)
  Certified Load (0.4ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 1]]
 =>                         
[#<Certified:0x00007f2744d122f8
  id: 3,                  
  employee_id: 1,
  aircraft_id: 3,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>] 
3.0.0 :037 > Certified.take(2)
  Certified Load (0.6ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 2]]
 => 

You can pass in a numerical argument to the take method to return up to that number of results
3.0.0 :037 > Certified.take(2)
  Certified Load (0.6ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 2]]
 => 
[#<Certified:0x00007f274411fd38
  id: 3,
  employee_id: 1,
  aircraft_id: 3,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
 #<Certified:0x00007f274411fc48
  id: 4,
  employee_id: 5,
  aircraft_id: 3,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>] 
3.0.0 :038 > 
The take! method behaves exactly like take, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.


3 first
The first method finds the first record ordered by primary key (default) but if any order method is defined in scope the it will order according to that.
The first method returns nil if no matching record is found and no exception will be raised.
3.0.0 :038 > Employee.first
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 1]]
 =>                                                              
#<Employee:0x00007f2744356840                                    
 id: 1,                                                          
 name: "Ajay",                                                   
 salary: 30000,                                                  
 mobile_number: "123456789",                                     
 DOB: nil,                                                       
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,     
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,     
 count_of_pilots: 3,                                             
 trainer_id: nil>  

can pass in a numerical argument to the first method to return up to that number of results.
3.0.0 :039 > Employee.first(2)
  Employee Load (0.7ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 2]]
 =>                                      
[#<Employee:0x000055fd7b348a18           
  id: 1,                                 
  name: "Ajay",                          
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055fd7b348950
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  collection that is ordered using order, first will return the first record ordered by the specified attribute for order.

  3.0.0 :044 > Employee.order(name: :desc).first
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."name" DESC LIMIT $1  [["LIMIT", 1]]
 =>                                                    
#<Employee:0x000055fd7b9397b0                          
 id: 13,                                               
 name: "Tesh",                                         
 salary: nil,                                          
 mobile_number: nil,                                   
 DOB: Wed, 01 Jan 1997,                                
 created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
 updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
 count_of_pilots: nil,                                 
 trainer_id: nil>  
 The first! method behaves exactly like first, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.

 4 last
 The last method finds the last record ordered by primary key (default).
 It function same as  first but in opposite order. Like if fisrt is ascending then last is descending.

3.0.0 :045 > Employee.last(2)
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" DESC LIMIT $1  [["LIMIT", 2]]
 =>                                                             
[#<Employee:0x00007f2744d4eb90                                  
  id: 11,                                                       
  name: "Gustav",                                               
  salary: nil,                                                  
  mobile_number: nil,                                           
  DOB: Wed, 01 Jan 1997,                                        
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,   
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,   
  count_of_pilots: nil,                                         
  trainer_id: nil>,                                             
 #<Employee:0x00007f2744d4ec58                                  
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>] 

  3.0.0 :046 > Employee.order(name: :desc).last
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."name" ASC LIMIT $1  [["LIMIT", 1]]
 =>                                                                      
#<Employee:0x000055fd7baab648                                            
 id: 1,                                                                  
 name: "Ajay",                                                           
 salary: 30000,                                                          
 mobile_number: "123456789",                                             
 DOB: nil,                                                               
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,             
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,             
 count_of_pilots: 3,                                                     
 trainer_id: nil> 

 5 find_by    
 The find_by method finds the first record matching some conditions.
 Here as find only see primary key here have to specify the column to match
As there e is no ORDER BY so  find_by conditions can match multiple records, have apply an order to guarantee a deterministic result.
The find_by! method behaves exactly like find_by, except that it will raise ActiveRecord::RecordNotFound if no matching record is found
3.0.0 :049 > Employee.find_by name: "Ajit"
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Ajit"], ["LIMIT", 1]]
 => nil 
3.0.0 :050 > Employee.find_by name: "Ajith"
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Ajith"], ["LIMIT", 1]]
 => 
#<Employee:0x000055fd7b20cd20
 id: 2,
 name: "Ajith",
 salary: 85000,
 mobile_number: "123456789",
 DOB: nil,
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
 updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
 count_of_pilots: 2,
 trainer_id: nil> 

 3.0.0 :052 > Employee.find_by! name: "Ajit"
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Ajit"], ["LIMIT", 1]]
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/relation/finder_methods.rb:378:in raise_record_not_found_exception!': Couldn't find Employee with [WHERE "employees"."name" = $1] (ActiveRecord::RecordNotFound)


## Retrieving Multiple Objects in Batches

1 find_each
The find_each method retrieves records in batches and then yields each one to the block. 
find_each retrieves  in batches of 1000 and yields them to the block one by one

3.0.0 :012 > Employee.find_each do |employee| print employee.certifieds.ids end
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 1000]]
  Certified Pluck (0.2ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 1]]
[3, 6, 16]  Certified Pluck (0.1ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 2]]                                                      
[7, 8]  Certified Pluck (0.1ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 3]]
[11, 14]  Certified Pluck (0.1ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 4]]
[9, 17, 2]  Certified Pluck (0.1ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 5]]                                                      
[4, 12]  Certified Pluck (0.1ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 6]]
[10, 13]  Certified Pluck (0.0ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 7]]
[5, 15]  Certified Pluck (0.0ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 8]]
[]  Certified Pluck (0.0ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 9]]
[]  Certified Pluck (0.0ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 11]]
[]  Certified Pluck (0.0ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 13]]
[] => nil 
Options for find_each

:batch_size = ption allows you to specify the number of records to be retrieved in each batch, before being passed individually to the block

3.0.0 :013 > Employee.find_each(batch_size:5) do |employee| print employee.certifieds.ids end

  :start
  records are fetched in ascending order of the primary key. 
  
The :start option allows you to configure the first ID of the sequence whenever the lowest ID is not the one you need
This would be useful, for example, if you wanted to resume an interrupted batch process, provided you saved the last processed ID as a checkpoint.

3.0.0 :014 > Employee.find_each(start: 5) do |employee| print employee.certifieds.ids end
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" >= $1 ORDER BY "employees"."id" ASC LIMIT $2  [["id", 5], ["LIMIT", 1000]]                                    
  Certified Pluck (0.1ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 5]]
[4, 12]  Certified Pluck (0.0ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 6]]
[10, 13]  Certified Pluck (0.1ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 7]]
[5, 15]  Certified Pluck (0.0ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 8]]
[]  Certified Pluck (0.0ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 9]]
[]  Certified    (0.1ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 11]]
[]  Certified Pluck (0.0ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 13]]
[] => nil 


:finish
This  allows you to configure the last ID of the sequence whenever the highest ID is not the one you need.
3.0.0 :015 > Employee.find_each(start: 5, finish:7) do |employee| print employee.certifieds.ids end
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" >= $1 AND "employees"."id" <= $2 ORDER BY "employees"."id" ASC LIMIT $3  [["id", 5], ["id", 7], ["LIMIT", 1000]]
  Certified Pluck (0.1ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 5]]
[4, 12]  Certified Pluck (0.0ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 6]]
[10, 13]  Certified Pluck (0.0ms)  SELECT "certifieds"."id" FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 7]]
[5, 15] => nil   


:error_on_ignore

Overrides the application config to specify if an error should be raised when an order is present in the relation.

2 find_in_batches

The find_in_batches method is similar to find_each, since both retrieve batches of records. 
The difference is that find_in_batches yields batches to the block as an array of models, instead of individually. 
The following example will yield to the supplied block an array of up to 1000 customers at a time, 
with the final block containing any remaining customers

3.0.0 :004 > Employee.find_in_batches do |employee| print em
  ployee.size end
    Employee Load (0.4ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 1000]]
  11 => nil

Options for find_in_batches
:batch_size
establishes how many records will be retrieved in each group.
3.0.0 :006 > Employee.find_in_batches(batch_size:5) do |empl
  oyee| print employee.size end
    Employee Load (0.3ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 5]]
  5  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" > $1 ORDER BY "employees"."id" ASC LIMIT $2  [["id", 5], ["LIMIT", 5]]
  5  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" > $1 ORDER BY "employees"."id" ASC LIMIT $2  [["id", 11], ["LIMIT", 5]]
  1 => nil 


  :start

  The start option allows specifying the beginning ID from where records will be selected.
  3.0.0 :007 > Employee.find_in_batches(batch_size:5, start:3 
    ) do |employee| print employee.size end
      Employee Load (0.2ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" >= $1 ORDER BY "employees"."id" ASC LIMIT $2  [["id", 3], ["LIMIT", 5]]                       
    5  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" >= $1 AND "employees"."id" > $2 ORDER BY "employees"."id" ASC LIMIT $3  [["id", 3], ["id", 7], ["LIMIT", 5]]                                             
    4 => nil   

    :finish

    The finish option allows specifying the ending ID of the records to be retrieved.
    3.0.0 :008 > Employee.find_in_batches(batch_size:5, start:3,
      finish: 9 ) do |employee| print employee.size end
       Employee Load (0.2ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" >= $1 AND "employees"."id" <= $2 ORDER BY "employees"."id" ASC LIMIT $3  [["id", 3], ["id", 9], ["LIMIT", 5]]
     5  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" >= $1 AND "employees"."id" <= $2 AND "employees"."id" > $3 ORDER BY "employees"."id" ASC LIMIT $4  [["id", 3], ["id", 9], ["id", 7], ["LIMIT", 5]]
     2 => nil 

     :error_on_ignore

The error_on_ignore option overrides the application config to specify if an error should be raised when a specific order is present in the relation.











---------------------------------------------------------------

##  Ordering
To retrieve records from the database in a specific order, you can use the order method.
can give both asc and desc but by default is asc
3.0.0 :054 > Employee.order(name: :desc).limit 4
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."name" DESC LIMIT $1  [["LIMIT", 4]]
 =>                                                                          
[#<Employee:0x00007f2744b0b7e8                                               
  id: 13,                                                                    
  name: "Tesh",                                                              
  salary: nil,                                                               
  mobile_number: nil,                                                        
  DOB: Wed, 01 Jan 1997,                                                     
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                
  count_of_pilots: nil,                                                      
  trainer_id: nil>,                                                          
 #<Employee:0x00007f2744b0b720                                               
  id: 8,
  name: "shubham",
  salary: 120000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.979496000 UTC +00:00,
  count_of_pilots: 0,
  trainer_id: nil>,
 #<Employee:0x00007f2744b0b658
  id: 6,
  name: "Sam",
  salary: 75000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.977471000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f2744b0b590
  id: 7,
  name: "Ram",
  salary: 150000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.978501000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  can order by multiple columns
  3.0.0 :057 > Employee.order(mobile_number: :desc, id: :asc).limit 4
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."mobile_number" DESC, "employees"."id" ASC LIMIT $1  [["LIMIT", 4]]                            
 =>                                       
[#<Employee:0x000055fd7be20a08            
  id: 11,                                 
  name: "Gustav",                      
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055fd7be20940
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055fd7be20878
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055fd7be207b0
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  Can call order multiple times 
  If you want to call order multiple times, subsequent orders will be appended to the first
  but that will work like above.
  3.0.0 :058 > Employee.order(mobile_number: :desc).order( id: :asc).limit 4
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."mobile_number" DESC, "employees"."id" ASC LIMIT $1  [["LIMIT", 4]]                                                                    
 =>                                                                               
[#<Employee:0x000055fd7b414e10                                                    
  id: 11,                                                                         
  name: "Gustav",                                                                 
  salary: nil,                                                                    
  mobile_number: nil,                                                             
  DOB: Wed, 01 Jan 1997,                                                          
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                     
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                     
  count_of_pilots: nil,                                                           
  trainer_id: nil>,                                                               
 #<Employee:0x000055fd7b414d48
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055fd7b414c80
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055fd7b414bb8
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 
3.0.0 :059 > 
-------------------------------------------------------------------------------
## Selecting Specific Fields

Model.find selects all the fields from the result set using select *
To select only a subset of fields from the result set, you can specify the subset via the select method.
3.0.0 :001 > Employee.select(:name, :mobile_number)
  Employee Load (1.0ms)  SELECT "employees"."name", "employees"."mobile_number" FROM "employees"
 =>                                                                                            
[#<Employee:0x0000557b04d08fe8 id: nil, name: "Ajay", mobile_number: "123456789">,             
 #<Employee:0x0000557b04dc32a8 id: nil, name: "Ajith", mobile_number: "123456789">,            
 #<Employee:0x0000557b04dc31e0 id: nil, name: "Arnab", mobile_number: "123456789">,            
 #<Employee:0x0000557b04dc3118 id: nil, name: "Amar", mobile_number: "123456789">,             
 #<Employee:0x0000557b04dc3050 id: nil, name: "Pritam", mobile_number: "123456789">,           
 #<Employee:0x0000557b04dc2f88 id: nil, name: "Sam", mobile_number: "123456789">,              
 #<Employee:0x0000557b04dc2ec0 id: nil, name: "Ram", mobile_number: "123456789">,              
 #<Employee:0x0000557b04dc2df8 id: nil, name: "shubham", mobile_number: "123456789">,          
 #<Employee:0x0000557b04dc2d30 id: nil, name: "naman", mobile_number: "123456789">,            
 #<Employee:0x0000557b04dc2c68 id: nil, name: "Gustav", mobile_number: nil>,                   
 #<Employee:0x0000557b04dc2ba0 id: nil, name: "Tesh", mobile_number: nil>] 

 So this also means you're initializing a model object with only the fields that you've selected.
  If you attempt to access a field that is not in the initialized record you'll receive'
  3.0.0 :002 > emp = Employee.select(:name, :mobile_number).first
  Employee Load (0.6ms)  SELECT "employees"."name", "employees"."mobile_number" FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 1]]                                                 
 => #<Employee:0x0000557b0511bcc0 id: nil, name: "Ajay", mobile_number: "123456789"> 
 3.0.0 :004 > emp.salary
 /home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activemodel-7.0.3/lib/active_model/attribute.rb:226:in value': 'missing attribute: salary (ActiveModel::MissingAttributeError)    

 But The id method will not raise the ActiveRecord::MissingAttributeError, so have to be careful when working with associations because they need the id method to function properly.
 
 
 If you would like to only grab a single record per unique value in a certain field, you can use distinct
 3.0.0 :006 > emp = Employee.select( :mobile_number).distinct
 Employee Load (1.2ms)  SELECT DISTINCT "employees"."mobile_number" FROM "employees"
=>                                                                                           
[#<Employee:0x0000557b0588af88 id: nil, mobile_number: "123456789">,                          
...                                                     
    
Can also remove distinct constraint
3.0.0 :008 > emp.distinct(false)
  Employee Load (0.2ms)  SELECT "employees"."mobile_number" FROM "employees"
 =>                                                                                 
[#<Employee:0x0000557b05c93aa8 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c93990 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c938a0 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c93788 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c93670 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93580 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93468 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93350 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93260 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93148 id: nil, mobile_number: nil>,
 #<Employee:0x0000557b05c93030 id: nil, mobile_number: nil>] 
3.0.0 :009 > 


-------------------------------------------------------------------------------
## Limit and Offset
To apply LIMIT to the SQL fired by the Model.find, you can specify the LIMIT using limit and offset methods on the relation.
Limit constraints the no of rows it has to return and offset constrsaints will tell limit to start from that row.

3.0.0 :010 > Employee.limit 2
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" LIMIT $1  [["LIMIT", 2]]
 =>                                                             
[#<Employee:0x0000557b06068570                                  
  id: 1,                                                        
  name: "Ajay",                                                 
  salary: 30000,                                                
  mobile_number: "123456789",                                   
  DOB: nil,                                                     
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,   
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,   
  count_of_pilots: 3,                                           
  trainer_id: nil>,                                             
 #<Employee:0x0000557b060684a8                                  
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 


  3.0.0 :012 > Employee.limit(2).offset 3
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" LIMIT $1 OFFSET $2  [["LIMIT", 2], ["OFFSET", 3]]
 =>                                                           
[#<Employee:0x0000557b05202418                                
  id: 4,                                                      
  name: "Amar",                                               
  salary: 45000,                                              
  mobile_number: "123456789",                                 
  DOB: nil,                                                   
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00, 
  updated_at: Thu, 26 May 2022 09:47:38.975047000 UTC +00:00, 
  count_of_pilots: 3,                                         
  trainer_id: nil>,
 #<Employee:0x0000557b05202350
  id: 5,
  name: "Pritam",
  salary: 90000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.976349000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>]

  ----------------------------------------------------------------------------
  ## Group
  To apply a GROUP BY clause to the SQL fired by the finder, have to  use the group method.
  Certified Load (6.8ms)  SELECT "certifieds"."employee_id" FROM "certifieds" GROUP BY "certifieds"."employee_id"
 =>                                                                                                          
[#<Certified:0x0000557b05870bb0 id: nil, employee_id: 3>,                                                    
 #<Certified:0x0000557b0589b450 id: nil, employee_id: 5>,                                                    
 #<Certified:0x0000557b0589b388 id: nil, employee_id: 4>,                                                    
 #<Certified:0x0000557b0589b2c0 id: nil, employee_id: 6>,                                                    
 #<Certified:0x0000557b0589b1f8 id: nil, employee_id: 2>,                                                    
 #<Certified:0x0000557b0589b130 id: nil, employee_id: 7>,                                                    
 #<Certified:0x0000557b0589b068 id: nil, employee_id: 1>] 
 3.0.0 :016 > Certified.select(:employee_id, :aircraft_id).group(:employee_id, :aircraft_id)
  Certified Load (0.3ms)  SELECT "certifieds"."employee_id", "certifieds"."aircraft_id" FROM "certifieds" GROUP BY "certifieds"."employee_id", "certifieds"."aircraft_id"                                                               
 =>                                                                                                                 
[#<Certified:0x0000557b060b3098 id: nil, employee_id: 4, aircraft_id: 1>,                                           
 #<Certified:0x0000557b060b2e68 id: nil, employee_id: 1, aircraft_id: 3>,                                           
 #<Certified:0x0000557b060b2c88 id: nil, employee_id: 4, aircraft_id: 2>,                                           
 #<Certified:0x0000557b060b2aa8 id: nil, employee_id: 2, aircraft_id: 2>,                                           
 #<Certified:0x0000557b060b2828 id: nil, employee_id: 7, aircraft_id: 6>,                                           
 #<Certified:0x0000557b060b2648 id: nil, employee_id: 3, aircraft_id: 4>,                                           
 #<Certified:0x0000557b060b2468 id: nil, employee_id: 6, aircraft_id: 7>,                                           
 #<Certified:0x0000557b060b21e8 id: nil, employee_id: 4, aircraft_id: 3>,                                           
 #<Certified:0x0000557b060b1ec8 id: nil, employee_id: 2, aircraft_id: 6>,                                           
 #<Certified:0x0000557b060b1ba8 id: nil, employee_id: 1, aircraft_id: 2>,                                           
 #<Certified:0x0000557b060b1888 id: nil, employee_id: 3, aircraft_id: 5>,
 #<Certified:0x0000557b060b1608 id: nil, employee_id: 5, aircraft_id: 3>,
 #<Certified:0x0000557b060b1428 id: nil, employee_id: 1, aircraft_id: 7>,
 #<Certified:0x0000557b060b11a8 id: nil, employee_id: 7, aircraft_id: 5>,
 #<Certified:0x0000557b060b0f50 id: nil, employee_id: 6, aircraft_id: 4>,
 #<Certified:0x0000557b060b0dc0 id: nil, employee_id: 5, aircraft_id: 7>]

Total of the grouped items
HAve to call count after the group.
3.0.0 :018 > Certified.select(:employee_id).group(:employee_id).count
  Certified Count (7.6ms)  SELECT COUNT("certifieds"."employee_id") AS "count_employee_id", "certifieds"."employee_id" AS "certifieds_employee_id" FROM "certifieds" GROUP BY "certifieds"."employee_id"                                
 => {3=>2, 5=>2, 4=>3, 6=>2, 2=>2, 7=>2, 1=>3}

 --------------------------------------------------------------------------------------

 ## Readonly Objects

 It is to create object which is as name suggests read only 
 Active Record provides the readonly method on a relation to explicitly disallow modification of any of the returned objects. 
 Any attempt to alter a readonly record will not succeed, raising an ActiveRecord::ReadOnlyRecord exception.

 3.0.0 :022 > emp = Employee.readonly.find(2)
 Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]                                                                                    
=>                                                                                           
#<Employee:0x0000557b048db0b0                                                                 
... 
3.0.0 :025 > emp.name = "changin"
 => "changin" 
3.0.0 :026 > emp.save!
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/persistence.rb:1123:in '_raise_readonly_record_error': Employee is marked as readonly (ActiveRecord::ReadOnlyRecord)

Functions to check read only


----------------------------------------------------------------------------------------------------
## Null Relation

 ???? when to use null realtion

 The none method returns a chainable relation with no records.

 3.0.0 :030 > emp = Employee.none
 => [] 
3.0.0 :031 > emp.class
 => Employee::ActiveRecord_Relation 
  
 3.0.0 :032 > emp.name = "shubham"
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/relation/delegation.rb:110:in `method_missing': undefined method `name=' for #<ActiveRecord::Relation []> (NoMethodError)
3.0.0 :033 > '


--------------------------------------------------------------------------------
## Running EXPLAIN

You can run explain on a relation. EXPLAIN output varies for each database.
3.0.0 :034 > Certified.select(:employee_id).group(:employee_id).explain
  Certified Load (0.3ms)  SELECT "certifieds"."employee_id" FROM "certifieds" GROUP BY "certifieds"."employee_id"
 =>                                                                                             
EXPLAIN for: SELECT "certifieds"."employee_id" FROM "certifieds" GROUP BY "certifieds"."employee_id"
                             QUERY PLAN                                                         
--------------------------------------------------------------------                            
 HashAggregate  (cost=27.00..29.00 rows=200 width=4)                                            
   Group Key: employee_id                                                                       
   ->  Seq Scan on certifieds  (cost=0.00..23.60 rows=1360 width=4)                             
(3 rows)                                                                                        
           

------------------------------------------------------------------------------

## Calculations

1. Count
to see how many records are in your models table
This section uses count as an example method in this preamble, but the options described apply to all sub-sections.
3.0.0 :035 > Employee.count
  Employee Count (0.8ms)  SELECT COUNT(*) FROM "employees"
 => 11  

2.average
If you want to see the average of a certain number in one of your tables you can call the average method on the class that relates to the table.

3.0.0 :044 > Certified.select(:id).average("id")
  Certified Average (0.4ms)  SELECT AVG("certifieds"."id") FROM "certifieds"
 => 0.95e1                                                                                                   
3.0.0 :045 > Certified.select(:id).average("id").class
  Certified Average (0.7ms)  SELECT AVG("certifieds"."id") FROM "certifieds"
 => BigDecimal  


 3 Minimum
 If you want to find the minimum value of a field in your table you can call the minimum method on the class that relates to the table.
 3.0.0 :049 > Employee.minimum(:salary)
 Employee Minimum (0.8ms)  SELECT MIN("employees"."salary") FROM "employees"
=> 30000 

 4 Maximum
 If you want to find the maximum value of a field in your table you can call the maximum method on the class that relates to the table.

 3.0.0 :048 > Employee.maximum(:salary)
 Employee Maximum (0.7ms)  SELECT MAX("employees"."salary") FROM "employees"
=> 150000

 5 Sum
 If you want to find the sum of a field for all records in your table you can call the sum method on the class that relates to the table.
 3.0.0 :047 > Employee.sum(:salary)
 Employee Sum (0.9ms)  SELECT SUM("employees"."salary") FROM "employees"
=> 768345 


-------------------------------------------------------------------------------

## Array Conditions
To use condition to get specific result can use where 
Here for eg.
1 Pure String Conditions 
Active Record will take the first argument as the conditions string and any additional arguments will replace the question marks (?) in it.

3.0.0 :001 > Employee.where("salary > ?", 100000) 
  Employee Load (1.8ms)  SELECT "employees".* FROM "employees" WHERE (salary > 100000)
 =>                                                                                                  
[#<Employee:0x000055d38c10c678                                                                       
  id: 7,                                                                                             
  name: "Ram",                                                                                       
  salary: 150000,                                                                                    
  mobile_number: "123456789",                                                                        
  DOB: nil,                                                                                          
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                        
  updated_at: Thu, 26 May 2022 09:47:38.978501000 UTC +00:00,                                        
  count_of_pilots: 2,                                                                                
  trainer_id: nil>,                                                                                  

So based on above condition can also give multiple condition
3.0.0 :004 > Employee.where("salary < ? or name = ? ", 100000, "Ajith") 
  Employee Load (0.8ms)  SELECT "employees".* FROM "employees" WHERE (salary < 100000 or name = 'Ajith' )
 => 
[#<Employee:0x000055d38c6860b8
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055d38c685ff0
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,

  The method below used should not be used in project as it makes system vunerable to sql injection.
  As Putting the variable directly into the conditions string will pass the variable to the database as-is.
  3.0.0 :005 > salary = 10000 
 => 10000 
 Putting the variable directly into the conditions string will pass the variable to the database as-is.
 3.0.0 :006 > Employee.where("salary < #{salary}") 
 Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE (salary < 10000)
=> []                                                             
3.0.0 :007 > Employee.where("salary > #{salary}") 
 Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE (salary > 10000)
=>                                                                
[#<Employee:0x00007f64e07d9258                                     
 id: 1,                                                           
 name: "Ajay",                                                    
 salary: 30000,                                                   
 mobile_number: "123456789",                                      
 DOB: nil,                                                        
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,      
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,      
 count_of_pilots: 3,
 trainer_id: nil>,
#<Employee:0x00007f64e07d8f60
 id: 2,
 name: "Ajith",
 salary: 85000,
 mobile_number: "123456789",
 DOB: nil,
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
 updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
 count_of_pilots: 2,
 trainer_id: nil>,
#<Employee:0x00007f64e07d8df8

1 Placeholder Conditions
The above method used is the (?) replacement style of params .
This can also be done using specifing keys in condition string along with corresponding key value pair.
This makes for clearer readability if you have a large number of variable conditions.

created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
3.0.0 :008 > Employee.where("salary > :salary_min", salary_min: salary) 
  Employee Load (0.7ms)  SELECT "employees".* FROM "employees" WHERE (salary > 10000)
 =>                                                                                              
[#<Employee:0x000055d38bf9c1d0                                                                   
  id: 1,                                                                                         
  name: "Ajay",                                                                                  
  salary: 30000,                                                                                 
  mobile_number: "123456789",                                                                    
  DOB: nil,                                                                                      
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                    
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,                                    
  count_of_pilots: 3,                                                                            
  trainer_id: nil>

  2 Conditions That Use LIKE
  Using the like condition as in used in sql statement. 
  Although condition arguments are automatically escaped to prevent SQL injection, SQL LIKE wildcards (i.e., % and _) are not escaped.

  3.0.0 :010 > Employee.where("name like ?","A"+ "%") 
  Employee Load (0.8ms)  SELECT "employees".* FROM "employees" WHERE (name like 'A%')
 => 
[#<Employee:0x000055d38c406f90
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055d38c406ec8
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x000055d38c406e00
  id: 3,
  name: "Arnab",
  salary: 50000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x000055d38c406d38
  id: 4,
  name: "Amar",
  salary: 45000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.975047000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>] 
3.0.0 :011 > Employee.where("name like ?","A") 
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE (name like 'A')
 => [] 

 it treaks % and _ as wild cards evenif the that is not their intended use in ruby but that is in sql 
 so there is need to sanitize that in ruby before the are passed to like condition.

 sanitize_sql_like(string, escape_character = "\\")
Sanitizes a string so that it is safe to use within an SQL LIKE statement.
This method uses escape_character to escape all occurrences of itself, _ and "%".
3.0.0 :017 > sanitize_sql_like("100% true!")
 => "100\\% true!" 
 3.0.0 :018 > sanitize_sql_like("100%", "!")
 => "100!%" 

 3.0.0 :020 > Employee.where("name like ?",Employee.sanitize_sql_like("A%")) 
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE (name like 'A\%')
 => []

 3 Hash Conditions
 Active Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax. 
 With hash conditions, you pass in a hash with keys of the fields you want qualified and the values of how you want to qualify them

 But only equality, range, and subset checking are possible with Hash conditions.

 1 Equality Conditions
 3.0.0 :023 > Employee.where(id: true) 
 =>                                                                                                         
[#<Employee:0x000055d38bffca08                            
  id: 1,                                                  
  name: "Ajay",                                           
  salary: 30000,                                          
  mobile_number: "123456789",                             
  DOB: nil,                                               
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,                                     
  trainer_id: nil>]                                       
3.0.0 :024 > Employee.where(name: true) 
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1  [["name", "t"]]
 => [] 
Other way of writing this is field within string
3.0.0 :025 > Employee.where("name" => true) 
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1  [["name", "t"]]
 => []  
 In the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. 
  This method works with polymorphic relationships as well.
  3.0.0 :026 > emp = Employee.where(id: true) 
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1  [["id", 1]]
 =>                                                              
[#<Employee:0x000055d38c21c810                                   
...   
3.0.0 :027 > Certified.where(employee: emp)
  Certified Load (0.5ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."employee" IN (SELECT "employees"."id" FROM "employees" WHERE "employees"."id" = $1)  [["id", 1]]
(Object doesnt support #inspect)                                
 =>                                                              
3.0.0 :028 > Certified.where(employee_id: emp)
  Certified Load (8.0ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."employee_id" IN (SELECT "employees"."id" FROM "employees" WHERE "employees"."id" = $1)  [["id", 1]]
 =>                                                              
[#<Certified:0x000055d38c44e458                                  
  id: 3,                                                         
  employee_id: 1,                                                
  aircraft_id: 3,                                                
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
 #<Certified:0x000055d38c47c010
  id: 6,
  employee_id: 1,
  aircraft_id: 2,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
 #<Certified:0x000055d38c477e98
  id: 16,
  employee_id: 1,
  aircraft_id: 7,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>]

 2 Range Conditions
It is done by using a BETWEEN SQL statement
3.0.0 :029 > Employee.where(salary: 10000..30000) 
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" WHERE "employees"."salary" BETWEEN $1 AND $2  [["salary", 10000], ["salary", 30000]]                                                                     
 =>                                                                                                 
[#<Employee:0x000055d38c4de468                                                                      
  id: 1,                                                                                            
  name: "Ajay",                                                                                     
  salary: 30000,                                                                                    
  mobile_number: "123456789",                                                                       
  DOB: nil,                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                       
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,                                       
  count_of_pilots: 3,                                                                               
  trainer_id: nil>] 
  3.0.0 :030 > Employee.where(salary: 10000...30000) 
  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE "employees"."salary" >= $1 AND "employees"."salary" < $2  [["salary", 10000], ["salary", 30000]]                                                    
 => [] 
 
 3 Subset Conditions
 find records using the IN expression
 3.0.0 :031 > Employee.where(salary: [30000, 40000, 50000]) 
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."salary" IN ($1, $2, $3)  [["salary", 30000], ["salary", 40000], ["salary", 50000]]                                                     
 =>                                                                                                  
[#<Employee:0x000055d38d1070f0                                                                       
  id: 1,                                                                                             
  name: "Ajay",                                                                                      
  salary: 30000,                                                                                     
  mobile_number: "123456789",                                                                        
  DOB: nil,                                                                                          
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                        
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,                                        
  count_of_pilots: 3,                                                                                
  trainer_id: nil>,
 #<Employee:0x000055d38d107000
  id: 3,
  name: "Arnab",
  salary: 50000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.973659000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  4 NOT Conditions
  NOT SQL queries can be built by where.not
  3.0.0 :032 > Employee.where.not(salary: [30000, 40000, 50000]).limit(1) 
  Employee Load (0.8ms)  SELECT "employees".* FROM "employees" WHERE "employees"."salary" NOT IN ($1, $2, $3) LIMIT $4  [["salary", 30000], ["salary", 40000], ["salary", 50000], ["LIMIT", 1]]                                         
 =>                                                                                                                 
[#<Employee:0x000055d38cfb49f0                                                                                      
  id: 2,                                                                                                            
  name: "Ajith",                                                                                                    
  salary: 85000,                                                                                                    
  mobile_number: "123456789",                                                                                       
  DOB: nil,                                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                                       
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,                                                       
  count_of_pilots: 2,                                                                                               
  trainer_id: nil>] 
 
  This will not show any value which is nil after not condition has been fullfilled
  3.0.0 :033 > Employee.where.not(mobile_number: "123456789") 
  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" != $1  [["mobile_number", "123456789"]]                                                                                                
 => []
 3.0.0 :034 > Employee.where(mobile_number: nil) 
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL
 =>                                                                                                                 
[#<Employee:0x000055d38c7167a8                                                                                      
  id: 11,                                                                                                           
  name: "Gustav",                                                                                                   
  salary: nil,                                                                       
  mobile_number: nil,                                                                
  DOB: Wed, 01 Jan 1997,                                                             
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                        
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                        
  count_of_pilots: nil,                                                              
  trainer_id: nil>,    

  
  5 OR Conditions
  Employee.where(id: 1) or (Employee.where(mobile_number: nil))
  OR conditions between two relations can be built by calling or on the first relation, 
  and passing the second one as an argument.
  3.0.0 :039 > Employee.where(id: 1).or(Employee.where(mobile_number: nil))
  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE ("employees"."id" = $1 OR "employees"."mobile_number" IS NULL)  [["id", 1]]                                        
 =>                                                                 
[#<Employee:0x000055d38cceeba8                                      
  id: 1,                                                            
  name: "Ajay",                                                     
  salary: 30000,                                                    
  mobile_number: "123456789",                                       
  DOB: nil,                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,       
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,       
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055d38cceeae0
  id: 11,
  name: "Gustav",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055d38cceea18
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>]

  6 AND Conditions
  AND conditions can be built by chaining where conditions.
  3.0.0 :042 > Employee.where(id: 11).where(mobile_number: nil)
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1 AND "employees"."mobile_number" IS NULL  [["id", 11]]                                                                 
 =>                                                                                          
[#<Employee:0x000055d38c2d4028                                                               
  id: 11,                                                                                    
  name: "Gustav",                                                                            
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>] 

  another way of doing same is AND conditions for the logical intersection between relations can be built by calling and on the first relation, and passing the second one as an argument.
3.0.0 :040 > Employee.where(id: 11).and(Employee.where(mobile_number: nil))
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1 AND "employees"."mobile_number" IS NULL  [["id", 11]]                                                                
 =>                                                                                         
[#<Employee:0x000055d38d09c2f0                                                              
  id: 11,                                                                                   
  name: "Gustav",                                                                           
  salary: nil,                                                                              
  mobile_number: nil,                                                                       
  DOB: Wed, 01 Jan 1997,                                                                    
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                               
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                               
  count_of_pilots: nil,
  trainer_id: nil>] 

  ---------------------------------------------------------------------------------------------
  8 Having
  It is just like having clause in sql that is used to specify the condition on the group by fields
  3.0.0 :046 >           having("count(*) > ?", 2) 
  Certified Load (0.3ms)  SELECT Employee_id, count(*) as Total_certified_airplane FROM "certifieds" GROUP BY Employee_id HAVING (count(*) > 2)                                                     
 => [#<Certified:0x000055d38cedc848 id: nil, employee_id: 4>, #<Certified:0x000055d38cedc780 id: nil, employee_id: 1>]   

 3.0.0 :047 > emp = Certified.select("Employee_id, count(*) as Total_certified_airplane").
 3.0.0 :048 > group("Employee_id").
 3.0.0 :049 >           having("count(*) > ?", 1) 
   Certified Load (0.3ms)  SELECT Employee_id, count(*) as Total_certified_airplane FROM "certifieds" GROUP BY Employee_id HAVING (count(*) > 1)
  => 
 [#<Certified:0x000055d38d15cde8 id: nil, employee_id: 3>,
  #<Certified:0x000055d38d15cd20 id: nil, employee_id: 5>,
  #<Certified:0x000055d38d15cc58 id: nil, employee_id: 4>,
  #<Certified:0x000055d38d15cb40 id: nil, employee_id: 6>,
  #<Certified:0x000055d38d15ca50 id: nil, employee_id: 2>,
  #<Certified:0x000055d38d15c960 id: nil, employee_id: 7>,
  #<Certified:0x000055d38d15c870 id: nil, employee_id: 1>] 

  3.0.0 :055 > emp.class
  => Certified::ActiveRecord_Relation 

  3.0.0 :061 > emp[0].total_certified_airplane
 => 2 


--------------------------------------------------------------------------------------------
## 9 Overriding Conditions

It overrides different conditions written in the query
1 unscope

specify certain conditions to be removed using the unscope method
3.0.0 :064 > emp = Certified.select("employee_id, count(*) as total_certified_airplane").
3.0.0 :065 > group("Employee_id").
3.0.0 :066 >           having("count(*) > ?", 1) .unscope(:having)
  Certified Load (0.5ms)  SELECT employee_id, count(*) as total_certified_airplane FROM "certifieds" GROUP BY Employee_id                                                                                                               
 =>                                                                                                                 
[#<Certified:0x000055d38cf3cf68 id: nil, employee_id: 3>,                                                           
...             

Here the unscope work to remove conditoion applied by having clause so no having clause in sql query.
Can also unscope specific where clauses
3.0.0 :073 > Employee.where(id: 11, mobile_number: nil).unscope(where: :id)
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL
 =>                                                                                                                 
[#<Employee:0x000055d38c1aea68                                                                                      
  id: 11,                                                                                                           
  name: "Gustav",                                                                                                   
  salary: nil,                                                                                                      
  mobile_number: nil,                                                                                               
  DOB: Wed, 01 Jan 1997,                                                                                            
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                                                       
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                                                       
  count_of_pilots: nil,                                                                                             
  trainer_id: nil>,
 #<Employee:0x000055d38c1ae9a0
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>] 
3.0.0 :074 > 

2. only

You can also override conditions using the only method
3.0.0 :077 > Employee.where(id: 11, mobile_number: nil).unscope(where: :id).limit(1).only(:where)
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL
 => 
[#<Employee:0x000055d38ce5dea8
  id: 11,
  name: "Gustav",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055d38ce5dde0
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>] 

  3 reselect
  The reselect method overrides an existing select statement.
  3.0.0 :078 > emp = Certified.select("employee_id").reselect("aircraft_id")
  Certified Load (0.3ms)  SELECT "certifieds"."aircraft_id" FROM "certifieds"
 =>                                                                                                                 
[#<Certified:0x000055d38bcc5d30 id: nil, aircraft_id: 3>,                                                           
...                                                                                                                 
3.0.0 :079 > 

We can also use select twice to select more columns
3.0.0 :079 > emp = Certified.select("employee_id").select("aircraft_id")
  Certified Load (0.6ms)  SELECT "certifieds"."employee_id", "certifieds"."aircraft_id" FROM "certifieds"
 =>                                                                                                                 
[#<Certified:0x000055d38c29da50 id: nil, employee_id: 1, aircraft_id: 3>,                                           
...                                                                        

4 reorder
The reorder method overrides the default scope order. 
3.0.0 :081 > Employee.where.not(mobile_number: nil).order(name: :asc)
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NOT NULL ORDER BY "employees"."name" ASC                                                                                            
 =>                                                                                                                 
[#<Employee:0x000055d38d379888                                                                                      
  id: 1,                                                                                                            
  name: "Ajay",                                                                                                     
  salary: 30000,                                                                                                    
  mobile_number: "123456789",                                                                                       
  DOB: nil,                                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                                       
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,                                                       
  count_of_pilots: 3,
  trainer_id: nil>,

  3.0.0 :082 > Employee.where.not(mobile_number: nil).order(name: :asc).reorder(name: :desc)
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NOT NULL ORDER BY "employees"."name" DESC                                                                                           
 =>                                                                                                                 
[#<Employee:0x000055d38d4102b0                                                                                      
  id: 8,                                                                                                            
  name: "shubham",                                                                                                  
  salary: 120000,                                                                                                   
  mobile_number: "123456789",                                                                                       
  DOB: nil,                                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                                       
  updated_at: Thu, 26 May 2022 09:47:38.979496000 UTC +00:00,                                                       
  count_of_pilots: 0,
  trainer_id: nil>,
 #<Employee:0x000055d38d4101e8
  id: 6,
  name: "Sam",
  salary: 75000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.977471000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>

  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NOT NULL ORDER BY "employees"."salary" DESC                                                                              
  =>                                                                                                      
 [#<Employee:0x000055d38cfa4668                                                                           
   id: 7,                                                                                                 
   name: "Ram",                                                                                           
   salary: 150000,                                                                                        
   mobile_number: "123456789",                                                                            
   DOB: nil,                                                                                              
   created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                            
   updated_at: Thu, 26 May 2022 09:47:38.978501000 UTC +00:00,                                            
   count_of_pilots: 2,
   trainer_id: nil>,

   5 reverse_order
   The reverse_order method reverses the ordering clause if specified.
   3.0.0 :084 > Employee.where.not(mobile_number: nil).order(name: :asc).reverse_order
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NOT NULL ORDER BY "employees"."name" DESC                                                                                           
 =>                                                                                                                 
[#<Employee:0x000055d38cd05240                                                                                      
  id: 8,                                                                                                            
  name: "shubham",                                                                                                  
  salary: 120000,                                                                                                   
  mobile_number: "123456789",                                                                                       
  DOB: nil,                                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                                       
  updated_at: Thu, 26 May 2022 09:47:38.979496000 UTC +00:00,                                                       
  count_of_pilots: 0,
  trainer_id: nil>,
 #<Employee:0x000055d38cd05178

 3.0.0 :085 > Employee.where.not(mobile_number: nil).order(name: :asc).reorder(salary: :desc).reverse_order
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NOT NULL ORDER BY "employees"."salary" ASC                                                                                          
 =>                                                                                                                 
[#<Employee:0x000055d38cdae4f8                                                                                      
  id: 1,                                                                                                            
  name: "Ajay",                                                                                                     
  salary: 30000,                                                                                                    
  mobile_number: "123456789",                                                                                       
  DOB: nil,                                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                                       
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,                                                       
  count_of_pilots: 3,
  trainer_id: nil>,

  6 rewhere
  This rewhere method overrides an existing, named where condition.
  3.0.0 :086 > Employee.where.not(mobile_number: nil).order(name: :asc).reorder(salary: :desc).reverse_order.rewhere(m
    obile_number: nil)
      Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL ORDER BY "employees"."salary" ASC                                                                                              
     =>                                                                                                                 
    [#<Employee:0x000055d38cbc42a0                                                                                      
      id: 11,                
      name: "Gustav",
      salary: nil,
      mobile_number: nil,
      DOB: Wed, 01 Jan 1997,
      created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
      updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
      count_of_pilots: nil,
      trainer_id: nil>,
     #<Employee:0x000055d38cbc41d8
      id: 13,
      name: "Tesh",
      salary: nil,
      mobile_number: nil,
      DOB: Wed, 01 Jan 1997,
      created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
      updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
      count_of_pilots: nil,
      trainer_id: nil>] 
    
      If the rewhere clause is not used, the where clauses are ANDed together
      Different case when rewhere is used multiple times.

      3.0.0 :088 > Employee.where(id: 11).where.not(mobile_number: nil).rewhere(mobile_number: nil)
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1 AND "employees"."mobile_number" IS NULL  [["id", 11]]                                                                                        
 =>                                                                                                                 
[#<Employee:0x000055d38c63fc80                                                                                      
  id: 11,                                                                                                           
  name: "Gustav",                                                                                                   
  salary: nil,                                                                                                      
  mobile_number: nil,                                                                                               
  DOB: Wed, 01 Jan 1997,                                                                                            
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                                                       
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                                                       
  count_of_pilots: nil,
  trainer_id: nil>]

  3.0.0 :089 > Employee.where(id: 11).where.not(mobile_number: nil).rewhere(mobile_number: nil).rewhere(id: 13)
  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL AND "employees"."id" = $1  [["id", 13]]                                                                                        
 =>                                                                                                                 
[#<Employee:0x000055d389697438                                                                                      
  id: 13,                                                                                                           
  name: "Tesh",                                                                                                     
  salary: nil,                                                                                                      
  mobile_number: nil,                                                                                               
  DOB: Wed, 01 Jan 1997,                                                                                            
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                                                       
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                                                       
  count_of_pilots: nil,
  trainer_id: nil>] 

  3.0.0 :091 > Employee.where(id: 11).and(Employee.where.not(mobile_number: nil)).rewhere(mobile_number: nil).rewhere(
    id: 13)
      Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL AND "employees"."id" = $1  [["id", 13]]                                                                     
     =>                                                                                              
    [#<Employee:0x000055d38d04ec58                                                             
      id: 13,                                                                                  
      name: "Tesh",                                                                            
      salary: nil,                                                                             
      mobile_number: nil,                                                                      
      DOB: Wed, 01 Jan 1997,                                                                   
      created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                              
      updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
      count_of_pilots: nil,
      trainer_id: nil>] 

      ---------------------------------------------------------------------------

## Locking Records for Update

Locking is helpful for preventing race conditions when updating records in the database and ensuring atomic updates.

What is a race condition?
A race condition is an undesirable situation that occurs when a device or system attempts to perform two or more operations at the same time, 
but because of the nature of the device or system, the operations must be done in the proper sequence to be done correctly.

Active Record provides two locking mechanisms:

Optimistic Locking
Pessimistic Locking

1 Optimistic Locking
Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data.
It does this by checking whether another process has made changes to a record since it was opened. 
An ActiveRecord::StaleObjectError exception is thrown if that has occurred and the update is ignored.
It is done by updating locking columns when record is updated and when it is updates the value of locking coolumn
is checked and if it is changed then then error is raised.

So here it needs a locking column
the table needs to have a column called lock_version of type integer.
 Each time the record is updated, Active Record increments the lock_version column. 
 If an update request is made with a lower value in the lock_version field than is currently in the lock_version column in the database,
  the update request will fail with an "ActiveRecord::StaleObjectError."

Responsibility for dealing with the conflict by rescuing the exception and either rolling back,
 merging, or otherwise apply the business logic needed to resolve the conflict.

 This behavior can be turned off by setting ActiveRecord::Base.lock_optimistically = false.

To override the name of the lock_version column, ActiveRecord::Base provides a class attribute called locking_column:
#<Wallet:0x00007fdfec1aaad0
3.0.0 :024 > wallet1
 => 
#<Wallet:0x00007fdfec1aaad0                                        
3.0.0 :029 > wallet1.save!
  TRANSACTION (0.1ms)  BEGIN
  Customr Load (0.2ms)  SELECT "customrs".* FROM "customrs" WHERE "customrs"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                                             
  Wallet Update (0.2ms)  UPDATE "wallets" SET "amount" = $1, "updated_at" = $2, "lock_version" = $3 WHERE "wallets"."id" = $4 AND "wallets"."lock_version" = $5  [["amount", 12345678.0], ["updated_at", "2022-06-10 12:52:58.877018"], ["lock_version", 3], ["id", 1], ["lock_version", 2]]               
  TRANSACTION (0.2ms)  ROLLBACK                                    
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/locking/optimistic.rb:108:in 'update_row': Attempted to update a stale object: Wallet. (ActiveRecord::StaleObjectError)
To override the name of the lock_version column, ActiveRecord::Base provides a class attribute called locking_column
inn class have to write .
after creating the columns 
self.locking_column = :lock_customer_column

2 Pessimistic Locking
Pessimistic locking uses a locking mechanism provided by the underlying database.
Using lock when building a relation obtains an exclusive lock on the selected rows. 
Relations using lock are usually wrapped inside a transaction for preventing deadlock conditions.
 

???? NOt able use Pessimistic locking

----------------------------------------------------------------------------------------------
## Existence of Objects
If you simply want to check for the existence of the object there s a method called exists?. 
This method will query the database using the same query as find, 
but instead of returning an object or collection of objects it will return either true or false.
3.0.0 :007 > Customr.exists?
  Customr Exists? (0.6ms)  SELECT 1 AS one FROM "customrs" LIMIT $1  [["LIMIT", 1]]
 => true                                                         
3.0.0 :008 > Customr.exists?(1)
  Customr Exists? (0.7ms)  SELECT 1 AS one FROM "customrs" WHERE "customrs"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                                            
 => true  
 3.0.0 :009 > Customr.exists?(4)
 Customr Exists? (0.6ms)  SELECT 1 AS one FROM "customrs" WHERE "customrs"."id" = $1 LIMIT $2  [["id", 4], ["LIMIT", 1]]
=> false 

The exists? method also takes multiple values, but the catch is that it will return true if any one of those records exists.
3.0.0 :012 > Customr.exists?(id: [1,4])
  Customr Exists? (0.9ms)  SELECT 1 AS one FROM "customrs" WHERE "customrs"."id" IN ($1, $2) LIMIT $3  [["id", 1], ["id", 4], ["LIMIT", 1]]                                    
 => true  

 Its even possible to use exists? without any arguments on a model or a relation.

 3.0.0 :002 > Wallet.where(name: "Ashish").exists?
 Wallet Exists? (0.5ms)  SELECT 1 AS one FROM "wallets" WHERE "wallets"."name" = $1 LIMIT $2  [["name", "Ashish"], ["LIMIT", 1]]                                                                              
=> true                                                                                   
3.0.0 :003 > Wallet.where(id: 2).exists?
 Wallet Exists? (0.7ms)  SELECT 1 AS one FROM "wallets" WHERE "wallets"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]                                                                                         
=> false 

can also use any? and many? to check for existence on a model or relation. many? will use SQL count to determine if the item exists.

3.0.0 :002 > Employee.any?
  Employee Exists? (0.3ms)  SELECT 1 AS one FROM "employees" LIMIT $1  [["LIMIT", 1]]
 => true 
 3.0.0 :003 > Employee.many?
  Employee Count (0.8ms)  SELECT COUNT(*) FROM (SELECT 1 AS one FROM "employees" LIMIT $1) subquery_for_count  [["LIMIT", 2]]                                                       
 => true 
 3.0.0 :008 > emp.certifieds.many?
 Certified Count (0.3ms)  SELECT COUNT(*) FROM (SELECT 1 AS one FROM "certifieds" WHERE "certifieds"."employee_id" = $1 LIMIT $2) subquery_for_count  [["employee_id", 1], ["LIMIT", 2]]                
=> true                                                                             
3.0.0 :009 > emp.certifieds.any?
 Certified Exists? (0.6ms)  SELECT 1 AS one FROM "certifieds" WHERE "certifieds"."employee_id" = $1 LIMIT $2  [["employee_id", 1], ["LIMIT", 1]]                                                        
=> true 
3.0.0 :012 > Employee.first.certifieds.any?
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 1]]                                                                                     
  Certified Exists? (0.5ms)  SELECT 1 AS one FROM "certifieds" WHERE "certifieds"."employee_id" = $1 LIMIT $2  [["employee_id", 1], ["LIMIT", 1]]                                                        
 => true 
 3.0.0 :014 > Employee.where("id > 3").many?
  Employee Count (0.8ms)  SELECT COUNT(*) FROM (SELECT 1 AS one FROM "employees" WHERE (id > 3) LIMIT $1) subquery_for_count  [["LIMIT", 2]]                                                             
 => true                                                                             
3.0.0 :015 > Employee.where("id > 3").many?
  Employee Count (0.8ms)  SELECT COUNT(*) FROM (SELECT 1 AS one FROM "employees" WHERE (id > 3) LIMIT $1) subquery_for_count  [["LIMIT", 2]]                                                             
 => true

 ================================================================================

 ##  Dynamic Finders
 For every field (also known as an attribute) you define in your table, 
 Active Record provides a finder method. If you have a field called first_name on your Customer model for example, 
 you get the instance method find_by_first_name for free from Active Record.
 3.0.0 :018 > Employee.find_by_name("Ajay") 
 Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Ajay"], ["LIMIT", 1]]
 =>                                              
#<Employee:0x00007f0644c934d8                    
 id: 1,                                          
 name: "Ajay",                                   
 salary: 30000,                                  
 mobile_number: "123456789",                     
 DOB: nil,                                       
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
 count_of_pilots: 3,                             
 trainer_id: nil>                                
3.0.0 :019 > Employee.find_by_id(1)
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]
 => 
#<Employee:0x00007f0644db99e8
 id: 1,
 name: "Ajay",
 salary: 30000,
 mobile_number: "123456789",
 DOB: nil,
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
 count_of_pilots: 3,
 trainer_id: nil>

 exclamation point (!) on the end of the dynamic finders to get them to raise an ActiveRecord::RecordNotFound error if they do not return any record  
  3.0.0 :022 > Employee.find_by_name("ajay")
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "ajay"], ["LIMIT", 1]]                
 => nil 
  3.0.0 :021 > Employee.find_by_name!("ajay")
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "ajay"], ["LIMIT", 1]]
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/relation/finder_methods.rb:378:in 'raise_record_not_found_exception!': Couldn't find Employee with [WHERE "employees"."name" = $1] (ActiveRecord::RecordNotFound)'

  If we want to find both by first_name and orders_count, you can chain these finders together by simply typing "and" between the fields. 
  For example, Customer.find_by_first_name_and_orders_count("Ryan", 5).
  3.0.0 :025 > Employee.find_by_name_and_id("Ajay",1)
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 AND "employees"."id" = $2 LIMIT $3  [["name", "Ajay"], ["id", 1], ["LIMIT", 1]]
 => 
#<Employee:0x000055b575a4f5a8
 id: 1,
 name: "Ajay",
 salary: 30000,
 mobile_number: "123456789",
 DOB: nil,
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
 count_of_pilots: 3,
 trainer_id: nil> 
-----------------------------------------------------------

## Joining Tables
THere 2 join methods
joins and
left_outer_joins

Here  joins is used for INNER JOIN or custom queries,
 and left_outer_joins is used for queries using LEFT OUTER JOIN

 1 joins
There different ways to use join methods

# Using a String SQL Fragment
Here we can supply the raw SQL specifying the JOIN clause to joins

3.0.0 :015 > Employee.joins("Inner join certifieds on employ
  ees.id= certifieds.employee_id and employees.salary < 40000 
  ")
    Employee Load (0.4ms)  SELECT "employees".* FROM "employees" Inner join certifieds on employees.id= certifieds.employee_id and employees.salary < 40000
   => 
  [#<Employee:0x000055dfb73b0758
    id: 1,
    name: "Ajay",
    salary: 30000,
    mobile_number: "123456789",
    DOB: nil,
    created_at:
     Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
    updated_at:
     Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
    count_of_pilots: 3,
    trainer_id: nil>,
   #<Employee:0x000055dfb73b0668
    id: 1,
    name: "Ajay",
    salary: 30000,
    mobile_number: "123456789",
    DOB: nil,
    created_at:
     Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
    updated_at:
     Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
    count_of_pilots: 3,
    trainer_id: nil>,
   #<Employee:0x000055dfb73b0528
    id: 1,
    name: "Ajay",
    salary: 30000,
    mobile_number: "123456789",
    DOB: nil,
    created_at:
     Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
    updated_at:
     Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
    count_of_pilots: 3,
    trainer_id: nil>] 

    2 Using Array/Hash of Named Associations
    use the names of the associations defined on the model as a shortcut for specifying JOIN clauses for those associations when using the joins method
    3.0.0 :016 > Employee.joins(:certifieds).distinct
  Employee Load (1.3ms)  SELECT DISTINCT "employees".* FROM "employees" INNER JOIN "certifieds" ON "certifieds"."employee_id" = "employees"."id"                                                      
 =>                                                         
[#<Employee:0x00007f3d04c85bc0                              
  id: 4,                                                    
  name: "Amar",                                             
  salary: 45000,                                            
  mobile_number: "123456789",                               
  DOB: nil,                                                 
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.975047000 UTC +00:00,
  count_of_pilots: 3,                                       
  trainer_id: nil>,
 #<Employee:0x00007f3d04c85aa8
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x00007f3d04c859b8
  id: 3,
  name: "Arnab",
  salary: 50000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.973659000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04c858a0
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04c85788
  id: 7,
  name: "Ram",
  salary: 150000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.978501000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04c85698
  id: 5,
  name: "Pritam",
  salary: 90000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.976349000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04c85580
  id: 6,
  name: "Sam",
  salary: 75000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.977471000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 


  3 Joining Multiple Associations
  3.0.0 :006 > Customr.joins(:wallet, :orders)
  Customr Load (0.3ms)  SELECT "customrs".* FROM "customrs" INNER JOIN "wallets" ON "wallets"."customr_id" = "customrs"."id" INNER JOIN "orders" ON "orders"."orderable_type" = $1 AND "orders"."orderable_id" = "customrs"."id"  [["orderable_type", "Customr"]]                         
 => []   
 #### Joining Nested Associations (Single Level)
 3.0.0 :009 > Customr.joins(wallet: :identificat
  ion)
    Customr Load (1.3ms)  SELECT "customrs".* FROM "customrs" INNER JOIN "wallets" ON "wallets"."customr_id" = "customrs"."id" INNER JOIN "identifications" ON "identifications"."wallet_id" = "wallets"."id"
   => [] 

   2 Joining Nested Associations (Multiple Level)
   3.0.0 :018 > Customr.joins(:orders, wallet: [:identification] )  
   Customr Load (0.4ms)  SELECT "customrs".* FROM "customrs" INNER JOIN "orders" ON "orders"."orderable_type" = $1 AND "orders"."orderable_id" = "customrs"."id" INNER JOIN "wallets" ON "wallets"."customr_id" = "customrs"."id" INNER JOIN "identifications" ON "identifications"."wallet_id" = "wallets"."id"  [["orderable_type", "Customr"]]         
  => []  

  ## Specifying Conditions on the Joined Tables
  specify conditions on the joined tables using the regular Array and String conditions. 

  3.0.0 :034 > Employee.joins(:certifieds).where('employees.salary < 40000')
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" INNER JOIN "certifieds" ON "certifieds"."employee_id" = "employees"."id" WHERE (employees.salary < 40000)                     
 =>                                                                      
[#<Employee:0x00007f3d04347590                                           
  id: 1,                                                                 
  name: "Ajay",                                                          
  salary: 30000,                                                         
  mobile_number: "123456789",                                            
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x00007f3d043474c8
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x00007f3d04347388
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>]

  2 left_outer_joins  

  If you want to select a set of records whether or not they have associated records you can use the left_outer_joins method
  3.0.0 :032 > Employee.left_outer_joins(:certifieds)
  Employee Load (0.9ms)  SELECT "employees".* FROM "employees" LEFT OUTER JOIN "certifieds" ON "certifieds"."employee_id" = "employees"."id"                                        
 =>                                                             
[#<Employee:0x00007f3d04b54378                                  
  id: 1,                                                        
  name: "Ajay",                                                 
  salary: 30000,                                                
  mobile_number: "123456789",                                   
  DOB: nil,                                                     
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,   
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,   
  count_of_pilots: 3,                                           
  trainer_id: nil>,                                             
 #<Employee:0x00007f3d04b542b0
  id: 5,
  name: "Pritam",
  salary: 90000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.976349000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b54080
  id: 7,
  name: "Ram",
  salary: 150000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.978501000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4ffa8
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4fee0
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4fe18
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4fd50
  id: 4,
  name: "Amar",
  salary: 45000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.975047000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4fc88
  id: 6,
  name: "Sam",
  salary: 75000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.977471000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4fbc0
  id: 3,
  name: "Arnab",
  salary: 50000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.973659000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4faf8
  id: 5,
  name: "Pritam",
  salary: 90000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.976349000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4fa30
  id: 6,
  name: "Sam",
  salary: 75000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.977471000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4f968
  id: 3,
  name: "Arnab",
  salary: 50000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.973659000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4f8a0
  id: 7,
  name: "Ram",
  salary: 150000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.978501000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4f7d8
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4f710
  id: 4,
  name: "Amar",
  salary: 45000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.975047000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4f648
  id: 4,
  name: "Amar",
  salary: 45000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.975047000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4f580
  id: 11,
  name: "Gustav",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4f4b8
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4f3f0
  id: 8,
  name: "shubham",
  salary: 120000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.979496000 UTC +00:00,
  count_of_pilots: 0,
  trainer_id: nil>,
 #<Employee:0x00007f3d04b4f328
  id: 9,
  name: "naman",
  salary: 123345,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.980433000 UTC +00:00,
  count_of_pilots: 0,
  trainer_id: nil>] 
-------------------------------------------------------------------------------------------------------

## Eager Loading Associations
Eager loading is the mechanism for loading the associated records of the objects returned by Model.find using as few queries as possible

n+1 query problem 
it runs 1 query to get all n records
Then it runs n numbers of queries to fetch all association related to all the records it fetched.

It can be done more efficiently by pre loading via eager loading 
Active Record lets you specify in advance all the associations that are going to be loaded.

The methods are:

includes
preload
eager_load

1 includes
With includes, Active Record ensures that all of the specified associations are loaded 
using the minimum possible number of queries.
3.0.0 :037 > Employee.includes(:certifieds).limit 2
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" LIMIT $1  [["LIMIT", 2]]
  Certified Load (0.4ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."employee_id" IN ($1, $2)  [["employee_id", 1], ["employee_id", 2]]
 => 
[#<Employee:0x000055dfb7d51f50
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055dfb7d51e88
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 
3.0.0 :038 > 

Eager Loading Multiple Associations
Array of Multiple Associations

3.0.0 :021 > Customr.includes(:orders, :wallet )  
  Customr Load (0.4ms)  SELECT "customrs".* FROM "customrs"
  Order Load (0.1ms)  SELECT "orders".* FROM "orders" WHERE "orders"."orderable_type" = $1 AND "orders"."orderable_id" = $2  [["orderable_type", "Customr"], ["orderable_id", 1]]                                   
  Wallet Load (0.1ms)  SELECT "wallets".* FROM "wallets" WHERE "wallets"."customr_id" = $1  [["customr_id", 1]]
 =>                                                                                             
[#<Customr:0x000055856433dff8                                                                   
  id: 1,                                                                                        
  name: "asdfsdf",                                           
  mobile_number: nil,                                        
  email_address: nil,                                        
  DOB: nil,                                                  
  created_at: Fri, 10 Jun 2022 12:50:04.437623000 UTC +00:00,
  updated_at: Fri, 10 Jun 2022 13:20:58.919337000 UTC +00:00,
  lock_customer: 1>] 
3.0.0 :022 > 

Nested Associations Hash

3.0.0 :022 > Customr.includes(:orders, wallet: [:identification] )  
  Customr Load (0.4ms)  SELECT "customrs".* FROM "customrs"
  Order Load (0.2ms)  SELECT "orders".* FROM "orders" WHERE "orders"."orderable_type" = $1 AND "orders"."orderable_id" = $2  [["orderable_type", "Customr"], ["orderable_id", 1]]  
  Wallet Load (0.1ms)  SELECT "wallets".* FROM "wallets" WHERE "wallets"."customr_id" = $1  [["customr_id", 1]]
  Identification Load (0.1ms)  SELECT "identifications".* FROM "identifications" WHERE "identifications"."wallet_id" = $1  [["wallet_id", 1]]                                      
 =>                                                            
[#<Customr:0x0000558563c6cad0                                  
  id: 1,                                                       
  name: "asdfsdf",                                             
  mobile_number: nil,                                          
  email_address: nil,                                          
  DOB: nil,                                                    
  created_at: Fri, 10 Jun 2022 12:50:04.437623000 UTC +00:00,
  updated_at: Fri, 10 Jun 2022 13:20:58.919337000 UTC +00:00,
  lock_customer: 1>] 
3.0.0 :023 > 



Specifying Conditions on Eager Loaded Associations
Even though Active Record lets you specify conditions on the eager loaded associations just 
like joins, the recommended way is to use joins instead.
Have to use where to specify condition
This would generate a query which contains a LEFT OUTER JOIN whereas the joins method would generate one using the INNER JOIN function instead.
3.0.0 :043 > Employee.includes(:certifieds).where(employees: { salary: 30000})
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" WHERE "employees"."salary" = $1  [["salary", 30000]]
  Certified Load (0.3ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 1]]
 => 
[#<Employee:0x000055dfb8c4b858
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>] 

Using where like this will only work when you pass it a Hash. For SQL-fragments you need to use references to force joined tables

3.0.0 :044 > Employee.includes(:certifieds).where( "employees.salary= 30000").references(:certifieds)
  SQL (1.0ms)  SELECT "employees"."id" AS t0_r0, "employees"."name" AS t0_r1, "employees"."salary" AS t0_r2, "employees"."mobile_number" AS t0_r3, "employees"."DOB" AS t0_r4, "employees"."created_at" AS t0_r5, "employees"."updated_at" AS t0_r6, "employees"."count_of_pilots" AS t0_r7, "employees"."trainer_id" AS t0_r8, "certifieds"."id" AS t1_r0, "certifieds"."employee_id" AS t1_r1, "certifieds"."aircraft_id" AS t1_r2, "certifieds"."created_at" AS t1_r3, "certifieds"."updated_at" AS t1_r4 FROM "employees" LEFT OUTER JOIN "certifieds" ON "certifieds"."employee_id" = "employees"."id" WHERE (employees.salary= 30000)                                                                             
 =>                                                                                                                 
[#<Employee:0x000055dfb7d19c40                                                                                      
  id: 1,                                                                                                            
  name: "Ajay",                                                                                                     
  salary: 30000,                                                                                                    
  mobile_number: "123456789",                                                                                       
  DOB: nil,                                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>] 

If no refrences is given it fetches 2 queries instead of joins
3.0.0 :045 > Employee.includes(:certifieds).where( "employees.salary= 30000")
  Employee Load (0.7ms)  SELECT "employees".* FROM "employees" WHERE (employees.salary= 30000)
  Certified Load (0.4ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."employee_id" = $1  [["employee_id", 1]]                                                                                                           
 =>   


2 preload
Active Record loads each specified association using one query per association.
will execute just 2 queries, as opposed to the  n+1 queries
3.0.0 :048 > Employee.preload(:certifieds).limit 5
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" LIMIT $1  [["LIMIT", 5]]
  Certified Load (0.6ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."employee_id" IN ($1, $2, $3, $4, $5)  [["employee_id", 1], ["employee_id", 2], ["employee_id", 3], ["employee_id", 4], ["employee_id", 5]]
 => 
[#<Employee:0x000055dfb7cba8f8
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055dfb7cba830
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x000055dfb7cba718
  id: 3,
  name: "Arnab",
  salary: 50000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.973659000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x000055dfb7cba650
  id: 4,
  name: "Amar",
  salary: 45000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.975047000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055dfb7cba588
  id: 5,
  name: "Pritam",
  salary: 90000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.976349000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  3 eager_load

  eager_load, Active Record loads all specified associations using a LEFT OUTER JOIN.
  code will execute just 2 queries, as opposed to the 6

  3.0.0 :049 > Employee.eager_load(:certifieds).limit 5
  SQL (0.3ms)  SELECT DISTINCT "employees"."id" FROM "employees" LEFT OUTER JOIN "certifieds" ON "certifieds"."employee_id" = "employees"."id" LIMIT $1  [["LIMIT", 5]]             
  SQL (0.3ms)  SELECT "employees"."id" AS t0_r0, "employees"."name" AS t0_r1, "employees"."salary" AS t0_r2, "employees"."mobile_number" AS t0_r3, "employees"."DOB" AS t0_r4, "employees"."created_at" AS t0_r5, "employees"."updated_at" AS t0_r6, "employees"."count_of_pilots" AS t0_r7, "employees"."trainer_id" AS t0_r8, "certifieds"."id" AS t1_r0, "certifieds"."employee_id" AS t1_r1, "certifieds"."aircraft_id" AS t1_r2, "certifieds"."created_at" AS t1_r3, "certifieds"."updated_at" AS t1_r4 FROM "employees" LEFT OUTER JOIN "certifieds" ON "certifieds"."employee_id" = "employees"."id" WHERE "employees"."id" IN ($1, $2, $3, $4, $5)  [["id", 3], ["id", 8], ["id", 11], ["id", 9], ["id", 13]]
 =>                                                             
[#<Employee:0x000055dfb6fc6020                                  
  id: 3,                                                        
  name: "Arnab",                                                
  salary: 50000,                                                
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.973659000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x000055dfb6fb5e50
  id: 11,
  name: "Gustav",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055dfb6fb4758
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055dfb6fac940
  id: 8,
  name: "shubham",
  salary: 120000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.979496000 UTC +00:00,
  count_of_pilots: 0,
  trainer_id: nil>,
 #<Employee:0x000055dfb6fa76c0
  id: 9,
  name: "naman",
  salary: 123345,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.980433000 UTC +00:00,
  count_of_pilots: 0,
  trainer_id: nil>] 


  The eager_load method uses an array, hash, or a nested hash of array/hash in the same way as the includes method to load any number of associations with a single Model.find call.
  Also, like the includes method, you can specify conditions for eager loaded associations.

------------------------------------------------------------------------------------------------

## Method Chaining
The Active Record pattern implements Method Chaining, which allow us to use multiple Active Record methods together in a simple and straightforward way.

 chain methods works for  a statement when the previous method called returns an ActiveRecord::Relation, like all, where, and joins.
 Methods that return a single object (see Retrieving a Single Object Section) have to be at the end of the statement. 

 1 Retrieving filtered data from multiple tables
 3.0.0 :029 > Customr.select("customrs.name").joins(:wallet).where("wallets.amount > 0")
  Customr Load (0.6ms)  SELECT "customrs"."name" FROM "customrs" INNER JOIN "wallets" ON "wallets"."customr_id" = "customrs"."id" WHERE (wallets.amount > 0)                                                                            
 => [#<Customr:0x0000558562ec87a8 id: nil, name: "asdfsdf">]   

 2 Retrieving specific data from multiple tables


 3.0.0 :030 > Customr.select("customrs.name").joins(:wallet).find(1)
 Customr Load (0.3ms)  SELECT "customrs"."name" FROM "customrs" INNER JOIN "wallets" ON "wallets"."customr_id" = "customrs"."id" WHERE "customrs"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                        
=> #<Customr:0x00005585644853e8 id: nil, name: "asdfsdf">    
3.0.0 :031 > Customr.select("customrs.name").joins(:wallet).find_by(id: 1)
Customr Load (0.3ms)  SELECT "customrs"."name" FROM "customrs" INNER JOIN "wallets" ON "wallets"."customr_id" = "customrs"."id" WHERE "customrs"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                      
=> #<Customr:0x0000558562fd8c38 id: nil, name: "asdfsdf">    

-----------------------------------------------------------------------------------------
Enums

------------------------------------------------------------------------------------------
## Find or Build a New Object
It we need to find a record or create it if it doesnt exist. 
This can be done with the find_or_create_by and find_or_create_by! methods

1 find_or_create_by

The find_or_create_by method checks whether a record with the specified attributes exists. If it doesnt, then create is called

3.0.0 :050 > emp = Employee.find_or_create_by(name: "Amit")
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Amit"], ["LIMIT", 1]]                                                                         
  TRANSACTION (0.2ms)  BEGIN                                                                
  Employee Create (7.9ms)  INSERT INTO "employees" ("name", "salary", "mobile_number", "DOB", "created_at", "updated_at", "count_of_pilots", "trainer_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING "id"  [["name", "Amit"], ["salary", nil], ["mobile_number", nil], ["DOB", "1997-01-01"], ["created_at", "2022-06-13 14:30:18.657499"], ["updated_at", "2022-06-13 14:30:18.657499"], ["count_of_pilots", nil], ["trainer_id", nil]]        
  TRANSACTION (0.5ms)  COMMIT                                                               
 =>                                                                                         
#<Employee:0x000055dfb8d72a60                                                               
...       

IT is created as no Amit
but as it is created now if same is done it will onl;y select

3.0.0 :051 > emp = Employee.find_or_create_by(name: "Amit")
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Amit"], ["LIMIT", 1]]
 => 
#<Employee:0x000055dfb8e480e8
... 

If we want to want to set any attribute to false if we're creating a new record, but we don't want to include it in the query.
this can done as below

Customer.create_with(locked: false).find_or_create_by(first_name: 'Andy')
3.0.0 :052 > emp = Employee.create_with(salary:100000).find_or_create_by(name: "Amit")
  Employee Load (0.7ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Amit"], ["LIMIT", 1]]                                                                   
 =>                                                                                   
#<Employee:0x000055dfb8de25b8                                                         
...        
3.0.0 :053 > emp
 => 
#<Employee:0x000055dfb8de25b8                                                         
 id: 14,                                                                              
 name: "Amit",                                                                        
 salary: nil,                                                                         
 mobile_number: nil,                                                                  
 DOB: Wed, 01 Jan 1997,                                                               
 created_at: Mon, 13 Jun 2022 14:30:18.657499000 UTC +00:00,                          
 updated_at: Mon, 13 Jun 2022 14:30:18.657499000 UTC +00:00,
 count_of_pilots: nil,      
 trainer_id: nil> 

 but if it creates
 trainer_id: nil>           
 3.0.0 :054 > emp = Employee.create_with(salary:100000).find_or_create_by(name: "Amita")
   Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Amita"], ["LIMIT", 1]]        
   TRANSACTION (0.1ms)  BEGIN
   Employee Create (0.2ms)  INSERT INTO "employees" ("name", "salary", "mobile_number", "DOB", "created_at", "updated_at", "count_of_pilots", "trainer_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING "id"  [["name", "Amita"], ["salary", 100000], ["mobile_number", nil], ["DOB", "1997-01-01"], ["created_at", "2022-06-13 14:36:41.243159"], ["updated_at", "2022-06-13 14:36:41.243159"], ["count_of_pilots", nil], ["trainer_id", nil]]
   TRANSACTION (6.5ms)  COMMIT
  => 
 #<Employee:0x00007f3d04d00488
 ... 
 3.0.0 :055 > emp
  => 
 #<Employee:0x00007f3d04d00488
  id: 15,
  name: "Amita",
  salary: 100000,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Mon, 13 Jun 2022 14:36:41.243159000 UTC +00:00,
  updated_at: Mon, 13 Jun 2022 14:36:41.243159000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil> 
 3.0.0 :056 > 


another way is

3.0.0 :056 > emp = Employee.find_or_create_by(name: "Amitra") do |c|
  3.0.0 :057 >   c.salary = 123456
  3.0.0 :058 > end
    Employee Load (0.7ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Amitra"], ["LIMIT", 1]]                                                               
    TRANSACTION (0.3ms)  BEGIN                                                        
    Employee Create (0.2ms)  INSERT INTO "employees" ("name", "salary", "mobile_number", "DOB", "created_at", "updated_at", "count_of_pilots", "trainer_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING "id"  [["name", "Amitra"], ["salary", 123456], ["mobile_number", nil], ["DOB", "1997-01-01"], ["created_at", "2022-06-13 14:37:37.350959"], ["updated_at", "2022-06-13 14:37:37.350959"], ["count_of_pilots", nil], ["trainer_id", nil]]
    TRANSACTION (6.5ms)  COMMIT                                                      
   =>                                                                                
  #<Employee:0x000055dfb7d318b8                                                      
  ...                         
  3.0.0 :059 > emp
  => 
 #<Employee:0x000055dfb7d318b8
  id: 16,                    
  name: "Amitra",            
  salary: 123456,            
  mobile_number: nil,        
  DOB: Wed, 01 Jan 1997,     
  created_at: Mon, 13 Jun 2022 14:37:37.350959000 UTC +00:00,
  updated_at: Mon, 13 Jun 2022 14:37:37.350959000 UTC +00:00,
  count_of_pilots: nil,      
  trainer_id: nil> 

  but do not work if its not already there

  3.0.0 :063 > emp = Employee.find_or_create_by(name: "Amitra") do |c|
    3.0.0 :064 >   c.salary = 123
    3.0.0 :065 > end
      Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Amitra"], ["LIMIT", 1]]
     => 
    #<Employee:0x000055dfb4cd2730
    ... 
    3.0.0 :066 > emp
     => 
    #<Employee:0x000055dfb4cd2730
     id: 16,
     name: "Amitra",
     salary: 123456,
     mobile_number: nil,
     DOB: Wed, 01 Jan 1997,
     created_at: Mon, 13 Jun 2022 14:37:37.350959000 UTC +00:00,
     updated_at: Mon, 13 Jun 2022 14:37:37.350959000 UTC +00:00,
     count_of_pilots: nil,
     trainer_id: nil> 

The block will only be executed if the customer is being created. The second time we run this code, the block will be ignored.

2 find_or_create_by!
This do the same thing as above but give error if any validation fails ..

3 find_or_initialize_by
The find_or_initialize_by method will work just like find_or_create_by but it will call new instead of create

So same as new vs create 
3.0.0 :068 > emp = Employee.find_or_initialize_by(name: "Amita")
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Amita"], ["LIMIT", 1]]                                                  
 =>                                                                   
#<Employee:0x000055dfb8681030                                         
...  
3.0.0 :074 > emp1 = Employee.find_or_initialize_by(name: "Amitaq")
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Amitaq"], ["LIMIT", 1]]
 => 
#<Employee:0x000055dfb7bb1b50
... 
3.0.0 :075 > emp1.new_record?
 => true 


 ============================================================================
 ## Finding by SQL

The find_by_sql method will return an array of objects even if the underlying query returns just a single record.
It provides you with a simple way of making custom calls to the database and retrieving instantiated objects.

3.0.0 :001 > Employee.find_by_sql("select * from aircrafts")
  Employee Load (1.2ms)  select * from aircrafts
 =>                                                             
[#<Employee:0x000055c56bae6c40                                  
  id: 1,                                                        
  name: "Airbus320",                                            
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,   
  updated_at: Mon, 06 Jun 2022 13:40:48.895413000 UTC +00:00>,  
 #<Employee:0x000055c56bb48fa8                                  
  id: 2,                                                        
  name: "Boeing737",                                            
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,   
  updated_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00>]

  3.0.0 :005 > Employee.find_by_sql("select name from aircrafts where id <8").to_a
  Employee Load (0.6ms)  select name from aircrafts where id <8
 =>                                                                                                                 
[#<Employee:0x00007f4f44ab4ba0 id: nil, name: "Airbus320">,                                                         
 #<Employee:0x00007f4f44ab4ad8 id: nil, name: "Boeing737">,                             
 #<Employee:0x00007f4f44ab4a10 id: nil, name: "Jet01">,                                 
 #<Employee:0x00007f4f44ab4948 id: nil, name: "Airbus380">,
 #<Employee:0x00007f4f44ab4880 id: nil, name: "Boeing777">,
 #<Employee:0x00007f4f44ab47b8 id: nil, name: "PrivateCraft">,
 #<Employee:0x00007f4f44ab46f0 id: nil, name: "Aircraft200">] 


 1. select_all
 find_by_sql has a close relative called connection.select_all. 
 select_all will retrieve objects from the database using custom SQL just like find_by_sql but will not instantiate them.

 3.0.0 :011 > Employee.connection.select_one("select name from aircrafts where id <8").to_a
   (0.4ms)  select name from aircrafts where id <8
 => [["name", "Airbus320"]]                                                                       
3.0.0 :012 > Employee.connection.select_all("select name from aircrafts where id <8").to_a
   (0.7ms)  select name from aircrafts where id <8
 =>                                                                                               
[{"name"=>"Airbus320"},                                                                           
 {"name"=>"Boeing737"},                                                                           
 {"name"=>"Jet01"},                                                                               
 {"name"=>"Airbus380"},
 {"name"=>"Boeing777"},
 {"name"=>"PrivateCraft"},
 {"name"=>"Aircraft200"}]

 2 pluck

 pluck can be used to query single or multiple columns from the underlying table of a model. 
 It accepts a list of column names as an argument and returns an array of values of the specified columns with the corresponding data type.
 any model method overrides will not be available for pluck
 
 3.0.0 :015 > Employee.find_by_sql("select * from aircrafts where id <8").pluck(:name)
 Employee Load (0.4ms)  select * from aircrafts where id <8
=> ["Airbus320", "Boeing737", "Jet01", "Airbus380", "Boeing777", "PrivateCraft", "Aircraft200"]                    
3.0.0 :016 > 
3.0.0 :016 > Aircraft.all.pluck(:name)
  Aircraft Pluck (0.2ms)  SELECT "aircrafts"."name" FROM "aircrafts"
 => ["Airbus320", "Boeing737", "Jet01", "Airbus380", "Boeing777", "PrivateCraft", "Aircraft200", nil]               
3.0.0 :017 > 
3.0.0 :020 > Aircraft.pluck(:name, :cruising_range)
  Aircraft Pluck (0.6ms)  SELECT "aircrafts"."name", "aircrafts"."cruising_range" FROM "aircrafts"
 =>                                                
[["Airbus320", 1234566],                           
 ["Boeing737", 5000],                              
 ["Jet01", 5000],                                  
 ["Airbus380", 8000],                              
 ["Boeing777", 500],                               
 ["PrivateCraft", 800],                            
 ["Aircraft200", 1000],                            
 [nil, 1000]]  
 3.0.0 :021 > Aircraft.distinct.pluck( :cruising_range)
  Aircraft Pluck (0.8ms)  SELECT DISTINCT "aircrafts"."cruising_range" FROM "aircrafts"
 => [1234566, 500, 800, 8000, 1000, 5000]                                                       
3.0.0 :022 > 

Can query in multiple tables like joins
3.0.0 :025 > Employee.joins(:certifieds).pluck("employees.name, certifieds.aircraft_id")
  Employee Pluck (9.2ms)  SELECT employees.name, certifieds.aircraft_id FROM "employees" INNER JOIN "certifieds" ON "certifieds"."employee_id" = "employees"."id"                                                                       
 => 
[["Ajay", 3],
 ["Pritam", 3],
 ["Ram", 5],
 ["Ajay", 2],
 ["Ajith", 6],
 ["Ajith", 2],
 ["Amar", 3],
 ["Sam", 4],
 ["Arnab", 4],
 ["Pritam", 7],
 ["Sam", 7],
 ["Arnab", 5],
 ["Ram", 6],
 ["Ajay", 7],
 ["Amar", 2],

unlike select and other Relation scopes, pluck triggers an immediate query, and thus cannot be chained with any further scopes,
although it can work with scopes already constructed earlier
3.0.0 :028 > Aircraft.pluck( :cruising_range).limit(1)
  Aircraft Pluck (0.3ms)  SELECT "aircrafts"."cruising_range" FROM "aircrafts"
(irb):28:in '<main>': undefined method 'limit' for [1234566, 5000, 5000, 8000, 500, 800, 1000, 1000]:Array (NoMethodError)                                                                                  

3.0.0 :029 > Aircraft.limit(1).pluck( :cruising_range)
  Aircraft Pluck (0.5ms)  SELECT "aircrafts"."cruising_range" FROM "aircrafts" LIMIT $1  [["LIMIT", 1]]
 => [1234566] 
 3.0.0 :033 > employees = Employee.includes(:certifieds).limit 10
 Employee Load (0.3ms)  SELECT "employees".* FROM "employees" LIMIT $1  [["LIMIT", 10]]
 Certified Load (0.6ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."employee_id" IN ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)  [["employee_id", 1], ["employee_id", 2], ["employee_id", 3], ["employee_id", 4], ["employee_id", 5], ["employee_id", 6], ["employee_id", 7], ["employee_id", 8], ["employee_id", 9], ["employee_id", 11]]
=>                                                                                     
[#<Employee:0x000055c56cd799e8                                                          
...                                                                                     
3.0.0 :034 > employees.pluck(:name)
=> ["Ajay", "Ajith", "Arnab", "Amar", "Pritam", "Sam", "Ram", "shubham", "naman", "Gustav"] 

 3.0.0 :035 > employees.limit(1).pluck(:name)
  SQL (0.5ms)  SELECT DISTINCT "employees"."id" FROM "employees" LEFT OUTER JOIN "certifieds" ON "certifieds"."employee_id" = "employees"."id" LIMIT $1  [["LIMIT", 1]]                                      
  Employee Pluck (0.3ms)  SELECT "employees"."name" FROM "employees" LEFT OUTER JOIN "certifieds" ON "certifieds"."employee_id" = "employees"."id" WHERE "employees"."id" = $1  [["id", 1]]                  
 => ["Ajay", "Ajay", "Ajay"] 

We can avoid this using unscope to includes
 3.0.0 :036 > employees.unscope(:includes).limit(1).pluck(:name)
  Employee Pluck (0.1ms)  SELECT "employees"."name" FROM "employees" LIMIT $1  [["LIMIT", 1]]
 => ["Ajay"]                                                                              
3.0.0 :037 > 

3 ids

ids can be used to pluck all the IDs for the relation using the table's primary key.'


3.0.0 :023 > Aircraft.ids
  Aircraft Pluck (0.3ms)  SELECT "aircrafts"."id" FROM "aircrafts"
 => [1, 2, 3, 4, 5, 6, 7, 8] 
 ------------------------------------------------------------------------------------------
 extract_associated(association)
Extracts a named association from the relation. The named association is first preloaded, then the individual association records are collected from the relation.
3.0.0 :003 > Employee.extract_associated(:certifieds)
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees"
  Certified Load (0.2ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."employee_id" IN ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)  [["employee_id", 1], ["employee_id", 2], ["employee_id", 3], ["employee_id", 4], ["employee_id", 5], ["employee_id", 6], ["employee_id", 7], ["employee_id", 8], ["employee_id", 9], ["employee_id", 11], ["employee_id", 13], ["employee_id", 14], ["employee_id", 15], ["employee_id", 16]]          
 =>                                                                                                             
[[#<Certified:0x000055eec55e1e38                                                                                
   id: 3,                                                                                                       
   employee_id: 1,                                                                                              
   aircraft_id: 3,                                                                                              
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,  
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>, 
  #<Certified:0x000055eec55c29c0                                
   id: 6,                                                       
   employee_id: 1,
   aircraft_id: 2,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
  #<Certified:0x000055eec55937b0
   id: 16,
   employee_id: 1,
   aircraft_id: 7,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>],
 [#<Certified:0x000055eec55c21f0
   id: 7,
   employee_id: 2,
   aircraft_id: 6,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
  #<Certified:0x000055eec55c1610
   id: 8,
   employee_id: 2,
   aircraft_id: 2,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>],
 [#<Certified:0x000055eec55a3138
   id: 11,
   employee_id: 3,
   aircraft_id: 4,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
  #<Certified:0x000055eec5598cb0
   id: 14,
   employee_id: 3,
   aircraft_id: 5,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>],
 [#<Certified:0x000055eec55c0f58
   id: 9,
   employee_id: 4,
   aircraft_id: 3,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
  #<Certified:0x000055eec5591eb0
   id: 17,
   employee_id: 4,
   aircraft_id: 2,
   created_at: Tue, 31 May 2022 09:35:13.397631000 UTC +00:00,
   updated_at: Tue, 31 May 2022 09:35:13.397631000 UTC +00:00>,
  #<Certified:0x000055eec55910f0
   id: 2,
   employee_id: 4,
   aircraft_id: 1,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 06 Jun 2022 13:40:48.889935000 UTC +00:00>],
 [#<Certified:0x000055eec55c8de8
   id: 4,
   employee_id: 5,
   aircraft_id: 3,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
  #<Certified:0x000055eec55a0910
   id: 12,
   employee_id: 5,
   aircraft_id: 7,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>],
 [#<Certified:0x000055eec55b1530
   id: 10,
   employee_id: 6,
   aircraft_id: 4,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
  #<Certified:0x000055eec559aad8
   id: 13,
   employee_id: 6,
   aircraft_id: 7,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>],
 [#<Certified:0x000055eec55c2f38
   id: 5,
   employee_id: 7,
   aircraft_id: 5,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
  #<Certified:0x000055eec55981c0
   id: 15,
   employee_id: 7,
   aircraft_id: 6,
   created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
   updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>],
 [],
 [],
 [],
 [],
 [],
 [],
 []] 
------------------------------------------------------------------------------------------------
From -

from(value, subquery_name = nil)Link
Specifies the table from which the records will be fetched.
3.0.0 :015 > Certified.select('name').from('employees')
  Certified Load (0.3ms)  SELECT name FROM employees
 =>                                                                                   
[#<Certified:0x000055eec6daec50 id: nil>,                                             
 #<Certified:0x000055eec6daeb88 id: nil>,                                             
 #<Certified:0x000055eec6daeac0 id: nil>,                                             
 #<Certified:0x000055eec6dae9f8 id: nil>,              
 #<Certified:0x000055eec6dae930 id: nil>,              
 #<Certified:0x000055eec6dae868 id: nil>,              
 #<Certified:0x000055eec6dae7a0 id: nil>,              
 #<Certified:0x000055eec6dae6d8 id: nil>,              
 #<Certified:0x000055eec6dae610 id: nil>,              
 #<Certified:0x000055eec6dae548 id: nil>,              
 #<Certified:0x000055eec6dae480 id: nil>,              
 #<Certified:0x000055eec6dae3b8 id: nil>,              
 #<Certified:0x000055eec6dae2f0 id: nil>,
 #<Certified:0x000055eec6dae228 id: nil>] 

 3.0.0 :017 > emp = Certified.select('name').from('employees')
  Certified Load (0.5ms)  SELECT name FROM employees
 =>                                                    
[#<Certified:0x000055eec7775a90 id: nil>,              
...      
3.0.0 :018 > emp.first.name
 => "Ajay" 
------------------------------------------------------------------------------------------------
extending(*modules, &block)
Used to extend a scope with additional methods, either through a module or through a block provided.
3.0.0 :006 > wallet = Wallet.all.extending(Amount)
  Wallet Load (0.6ms)  SELECT "wallets".* FROM "wallets"
 =>                                                                    
[#<Wallet:0x00007f4258813520                                           
...                                                                    
3.0.0 :007 > wallet = Wallet.first.extend(Amount)
  Wallet Load (0.6ms)  SELECT "wallets".* FROM "wallets" ORDER BY "wallets"."id" ASC LIMIT $1  [["LIMIT", 1]]
 =>                                                                    
#<Wallet:0x00007f4258a61548                                            
...     

3.0.0 :001 > wallet = Wallet.all.extending(Amount)
  Wallet Load (0.1ms)  SELECT "wallets".* FROM "wallets"
 =>                         
[#<Wallet:0x0000563e7a750f58
...                         
3.0.0 :002 > wallet.debits(1)
debited amount1 => nil 
3.0.0 :003 > wallet = Wallet.first.extend(Amount)
  Wallet Load (0.5ms)  SELECT "wallets".* FROM "wallets" ORDER BY "wallets"."id" ASC LIMIT $1  [["LIMIT", 1]]
 =>                         
#<Wallet:0x0000563e7abf81a0 
... 
3.0.0 :004 > 
3.0.0 :005 > wallet.debits(1)
debited amount1 => nil 

extending using  a block
3.0.0 :011 > wallet = Wallet.all.extending do
  3.0.0 :012 >   def credits(amt)
  3.0.0 :013 >     print "amount credited", amt
  3.0.0 :014 >   end
  3.0.0 :015 > end
    Wallet Load (0.2ms)  SELECT "wallets".* FROM "wallets"
   =>                    "amount credited", amt                          
  [#<Wallet:0x0000563e793339d0                                           
  ...      

  3.0.0 :016 > wallet.credits(10)
amount credited10 => nil 
3.0.0 :017 > 


optimizer_hints(*args)

how to use this
Specify optimizer hints to be used in the SELECT statement.
Example (for PostgreSQL with pg_hint_plan):

Topic.optimizer_hints("SeqScan(topics)", "Parallel(topics 8)")
# SELECT /*+ SeqScan(topics) Parallel(topics 8) */ "topics".* FROM "topics"
-------------------------------------------------------------------------------------------------
## Scopes

Scopes are custom queries that you define inside your Rails models with the scope method.
Every scope takes two arguments:

A name, which you use to call this scope in your code.
A lambda, which implements the query.

And result of calling a scope, youll get an ActiveRecord::Relation object.
Which means we can combine methods and other scopes to it.
3.0.0 :007 >  Category.cat
  Category Load (0.5ms)  SELECT "categories".* FROM "categories" WHERE (name is not null )
 =>                                            
[#<Category:0x0000556bdb681db0 id: 2, name: "clothes", description: 0.0>,
 #<Category:0x0000556bdb681ce8 id: 3, name: "electronics", description: 0.0>]

 Usinjg Rails Scopes With Arguments
To introduce a variable into a scope so you can make it more flexible.

3.0.0 :001 >  Category.limit_num
  Category Load (0.1ms)  SELECT "categories".* FROM "categories" LIMIT $1  [["LIMIT", 1]]
 => [#<Category:0x0000558554f10f70 id: 1, name: nil, description: nil>]    
3.0.0 :002 >  Category.limit_num(3)
  Category Load (0.2ms)  SELECT "categories".* FROM "categories" LIMIT $1  [["LIMIT", 3]]
 =>                                                                        
[#<Category:0x0000558555071798 id: 1, name: nil, description: nil>,        
 #<Category:0x00005585550716d0 id: 2, name: "clothes", description: 0.0>,  
 #<Category:0x0000558555071608 id: 3, name: "electronics", description: 0.0>] 

 Scope vs Class Method
Theyre just methods same thing can be done using class methods.


But there are design advantages to using scopes over class methods.
Scopes result in cleaner code because of their syntax
Scopes are used for exactly one thing, so you know what you get the moment you see one
Scopes arent mixed with other methods, so theyre easier to spot
In terms of functionality, the only difference is that scopes guarantee an ActiveRecord::Relation, and class methods dont.



Default Scopes
scope to be applied across all queries to the model we can use the default_scope method within the model itself.
A default scope is one which is automatically applied to your model.
default_scope { where(description: true) }
So not recommended to be used
As beacuse of them progam run into strange errors, andthen will have to waste precious time debugging.
3.0.0 :001 > category = Category.create!(name: "clothes")
  TRANSACTION (0.1ms)  BEGIN
  Category Create (0.2ms)  INSERT INTO "categories" ("name", "description") VALUES ($1, $2) RETURNING "id"  [["name", "clothes"], ["description", 1.0]]                                        
  TRANSACTION (0.4ms)  COMMIT                                              
 => #<Category:0x00007efc7c801b58 id: 6, name: "clothes", description: 1.0> 
3.0.0 :002 > category = Category.create!(name: "electronics", description: "Mouse")
  TRANSACTION (0.1ms)  BEGIN
  Category Create (0.2ms)  INSERT INTO "categories" ("name", "description") VALUES ($1, $2) RETURNING "id"  [["name", "electronics"], ["description", 0.0]]            
  TRANSACTION (6.1ms)  COMMIT                      
 => #<Category:0x0000560d39b20d80 id: 7, name: "electronics", description: 0.0> 
 Loading development environment (Rails 7.0.3)                    
 3.0.0 :001 >  Category.limit_num(3)
   Category Load (0.1ms)  SELECT "categories".* FROM "categories" WHERE "categories"."description" = $1 LIMIT $2  [["description", 1.0], ["LIMIT", 3]]                                
  => [#<Category:0x00007f3a10877548 id: 6, name: "clothes", description: 1.0>] 



  Merging of scopes
  Just like where clauses, scopes are merged using AND conditions
  3.0.0 :001 >  Category.limit_num(3).cat
  Category Load (0.2ms)  SELECT "categories".* FROM "categories" WHERE (description is not null ) LIMIT $1  [["LIMIT", 3]]                                                                                       
 =>                                                                                          
[#<Category:0x0000560654270d70 id: 2, name: "clothes", description: 0.0>,                    
 #<Category:0x000056065423b2d8 id: 3, name: "electronics", description: 0.0>,                
 #<Category:0x000056065423b210 id: 6, name: "clothes", description: 1.0>] 
 (base) itsacheckmate@itsacheckmate:~/Training/Rails/ecommerce$ rails c
Loading development environment (Rails 7.0.3)                                                
3.0.0 :001 >  Category.limit_num(3).cat
  Category Load (0.4ms)  SELECT "categories".* FROM "categories" WHERE (description = 0.0 ) LIMIT $1  [["LIMIT", 3]]
 =>                                                                                          
[#<Category:0x000055a5a008e3c8 id: 2, name: "clothes", description: 0.0>,                    
 #<Category:0x00007fdf30c14988 id: 3, name: "electronics", description: 0.0>,                
 #<Category:0x00007fdf30c148c0 id: 7, name: "electronics", description: 0.0>] 
3.0.0 :002 > 

using scopes with where  condition
3.0.0 :002 >  Category.limit_num(3).cat.where(name: "clothes")
  Category Load (0.5ms)  SELECT "categories".* FROM "categories" WHERE (description = 0.0 ) AND "categories"."name" = $1 LIMIT $2  [["name", "clothes"], ["LIMIT", 3]]                                               
 => [#<Category:0x00007fdf309bc0f0 id: 2, name: "clothes", description: 0.0>]        

 One important caveat is that default_scope will be prepended in scope and where conditions.

 Removing All Scoping
 to remove scoping for any reason we can use the unscoped method. This is especially useful if a default_scope is specified in the model and should not be applied for this particular query.

 3.0.0 :001 > Category.unscoped.load
 Category Load (0.2ms)  SELECT "categories".* FROM "categories"
=>                                                                                              
[#<Category:0x00005580b0150398 id: 1, name: nil, description: nil>,                              
#<Category:0x00005580b011a900 id: 2, name: "clothes", description: 0.0>,                        
#<Category:0x00005580b011a838 id: 3, name: "electronics", description: 0.0>,                    
#<Category:0x00005580b011a770 id: 4, name: "clothes", description: nil>,                        
#<Category:0x00005580b011a6a8 id: 5, name: "clothes", description: nil>,               
#<Category:0x00005580b011a5e0 id: 6, name: "clothes", description: 1.0>,               
#<Category:0x00005580b011a518 id: 7, name: "electronics", description: 0.0>,           
#<Category:0x00005580b011a450 id: 8, name: "electronics", description: 0.0>,           
#<Category:0x00005580b011a388 id: 9, name: "electronics", description: 0.0>,           
#<Category:0x00005580b011a2c0 id: 10, name: "electronics", description: 0.0>]  

unscoped can also accept a block.
3.0.0 :003 > Category.unscoped.where(name: "clothes")
  Category Load (0.2ms)  SELECT "categories".* FROM "categories" WHERE "categories"."name" = $1  [["name", "clothes"]]                                                                                      
 =>                                                                                     
[#<Category:0x00007f9cf43b1d78 id: 2, name: "clothes", description: 0.0>,               
 #<Category:0x00007f9cf43b1cb0 id: 4, name: "clothes", description: nil>,               
 #<Category:0x00007f9cf43b1be8 id: 5, name: "clothes", description: nil>,               
 #<Category:0x00007f9cf43b1b20 id: 6, name: "clothes", description: 1.0>]   


============================================================================

Enums
An enum lets you define an Array of values for an attribute and refer to them by name. 
The actual value stored in the database is an integer that has been mapped to one of the values.

Declaring an enum will:

Create scopes that can be used to find all objects that have or do not have one of the enum values
Create an instance method that can be used to determine if an object has a particular value for the enum
Create an instance method that can be used to change the enum value of an object

These scopes are created automatically and can be used to find all objects with or without a particular value for attriibutes.  
3.0.0 :001 > Category.stock
  Category Load (0.1ms)  SELECT "categories".* FROM "categories" WHERE "categories"."description" = $1  [["description", 0.0]]                                                                              
 =>                                                             
[#<Category:0x00007f55e0b26758 id: 2, name: "clothes", description: "stock">,
 #<Category:0x00007f55e0b58c80 id: 3, name: "electronics", description: "stock">,
 #<Category:0x00007f55e0b58bb8 id: 7, name: "electronics", description: "stock">,
 #<Category:0x00007f55e0b58af0 id: 8, name: "electronics", description: "stock">,
 #<Category:0x00007f55e0b58a28 id: 9, name: "electronics", description: "stock">,
 #<Category:0x00007f55e0b58960 id: 10, name: "electronics", description: "stock">] 

 3.0.0 :002 > Category.not_stock
  Category Load (0.2ms)  SELECT "categories".* FROM "categories" WHERE "categories"."description" != $1  [["description", 0.0]]                                                     
 => [#<Category:0x000055677c817980 id: 6, name: "clothes", description: "cancelled">] 


 3.0.0 :003 > cat = Category.first
 Category Load (0.1ms)  SELECT "categories".* FROM "categories" ORDER BY "categories"."id" ASC LIMIT $1  [["LIMIT", 1]]                                                                  
=> #<Category:0x000055677c815220 id: 1, name: nil, description: nil> 
3.0.0 :005 > cat.stock?
 => false 
 3.0.0 :006 > cat.cancelled?
 => false 
 3.0.0 :008 > cat.name = "clothes"
 => "clothes" 
3.0.0 :009 > cat.cancelled!
  TRANSACTION (0.3ms)  BEGIN
  Category Update (1.0ms)  UPDATE "categories" SET "name" = $1, "description" = $2 WHERE "categories"."id" = $3  [["name", "clothes"], ["description", 1.0], ["id", 1]]        
  TRANSACTION (6.8ms)  COMMIT                              
 => true 

 3.0.0 :010 > cat.stock!
  TRANSACTION (0.2ms)  BEGIN
  Category Update (0.2ms)  UPDATE "categories" SET "description" = $1 WHERE "categories"."id" = $2  [["description", 0.0], ["id", 1]]                                          
  TRANSACTION (6.5ms)  COMMIT                              
 => true                                                   
3.0.0 :011 > cat.stock?
 => true 
 











 Practice

 3.0.0 :006 > Aircraft.joins(:certifieds)
  Aircraft Load (2.5ms)  SELECT "aircrafts".* FROM "aircrafts" INNER JOIN "certifieds" ON "certifieds"."aircraft_id" = "aircrafts"."id"                                                                                     
 =>                                                                                                     
[#<Aircraft:0x00007fa4684cb558                                                                          
  id: 5,                                                                                                
  name: "Airbus10",                                                                                     
  cruising_range: 12,                                                                                   
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,                                           
  updated_at: Fri, 29 Jul 2022 13:01:53.657511000 IST +05:30,                                           
  aircraft_updated_at: nil,                                                                             
  certifieds_count: 2,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x00007fa4684cb418
  id: 2,
  name: "Airbus",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Sun, 31 Jul 2022 18:55:01.251819000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 18:55:01.251355000 IST +05:30>,
 #<Aircraft:0x00007fa4684cb288
  id: 3,
  name: "Airbus20",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Fri, 29 Jul 2022 13:00:44.155286000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x00007fa4684cb170
  id: 4,
  name: "Airbus620",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Tue, 02 Aug 2022 19:57:39.750648000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "MUMBAI",
  availability: Tue, 02 Aug 2022 21:37:00.000000000 IST +05:30>,
 #<Aircraft:0x00007fa4684cb008
  id: 4,
  name: "Airbus620",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Tue, 02 Aug 2022 19:57:39.750648000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "MUMBAI",
  availability: Tue, 02 Aug 2022 21:37:00.000000000 IST +05:30>,
 #<Aircraft:0x00007fa4684caea0
  id: 7,
  name: "Airbus30",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Fri, 29 Jul 2022 13:01:36.008484000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x00007fa4684cad88
  id: 5,
  name: "Airbus10",
  cruising_range: 12,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Fri, 29 Jul 2022 13:01:53.657511000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x00007fa4684cac98
  id: 2,
  name: "Airbus",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Sun, 31 Jul 2022 18:55:01.251819000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 18:55:01.251355000 IST +05:30>,
 #<Aircraft:0x00007fa4684cabd0
  id: 1,
  name: "Airbus60",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Mon, 01 Aug 2022 14:20:44.250729000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 1,
  place: "PUNE",
  availability: Mon, 01 Aug 2022 17:19:00.000000000 IST +05:30>,
 #<Aircraft:0x00007fa4684ca950
  id: 6,
  name: "Airbus320",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Sun, 31 Jul 2022 19:14:48.998358000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "MUMBAI",
  availability: Sun, 31 Jul 2022 22:12:00.000000000 IST +05:30>,
 #<Aircraft:0x00007fa4684ca860
  id: 3,
  name: "Airbus20",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Fri, 29 Jul 2022 13:00:44.155286000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x00007fa4684ca770
  id: 7,
  name: "Airbus30",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Fri, 29 Jul 2022 13:01:36.008484000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x00007fa4684ca658
  id: 29,
  name: "Boeing777",
  cruising_range: 242434,
  created_at: Mon, 01 Aug 2022 18:12:55.864800000 IST +05:30,
  updated_at: Tue, 02 Aug 2022 19:27:24.378772000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 0,
  place: "Delhi",
  availability: Tue, 02 Aug 2022 19:27:24.374755000 IST +05:30>,
 #<Aircraft:0x00007fa4684ca590
  id: 36,
  name: "Boeing730",
  cruising_range: 242434,
  created_at: Tue, 02 Aug 2022 19:48:36.934103000 IST +05:30,
  updated_at: Tue, 02 Aug 2022 19:48:36.934103000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 0,
  place: "Delhi",
  availability: Tue, 02 Aug 2022 19:48:36.934372000 IST +05:30>,
3.0.0 :014 > Aircraft.joins(certifieds: :pilots)
  Aircraft Load (0.4ms)  SELECT "aircrafts".* FROM "aircrafts" INNER JOIN "certifieds" ON "certifieds"."aircraft_id" = "aircrafts"."id" INNER JOIN "employees" ON "employees"."id" = "certifieds"."employee_id"                         
 =>                                                                                                                 
[#<Aircraft:0x000055c79ce50128                                                                                      
  id: 5,                                                                                                            
  name: "Airbus10",                                                                                                 
  cruising_range: 12,                                                                                               
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,                                                       
  updated_at: Fri, 29 Jul 2022 13:01:53.657511000 IST +05:30,                                                       
  aircraft_updated_at: nil,                                                                                         
  certifieds_count: 2,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x000055c79ce4bc68
  id: 2,
  name: "Airbus",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Sun, 31 Jul 2022 18:55:01.251819000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 18:55:01.251355000 IST +05:30>,
 #<Aircraft:0x000055c79ce4b650
  id: 3,
  name: "Airbus20",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Fri, 29 Jul 2022 13:00:44.155286000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x000055c79ce4b218
  id: 4,
  name: "Airbus620",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Tue, 02 Aug 2022 19:57:39.750648000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "MUMBAI",
  availability: Tue, 02 Aug 2022 21:37:00.000000000 IST +05:30>,
 #<Aircraft:0x000055c79ce4b150
  id: 4,
  name: "Airbus620",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Tue, 02 Aug 2022 19:57:39.750648000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "MUMBAI",
  availability: Tue, 02 Aug 2022 21:37:00.000000000 IST +05:30>,
 #<Aircraft:0x000055c79ce4af70
  id: 7,
  name: "Airbus30",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Fri, 29 Jul 2022 13:01:36.008484000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x000055c79ce4ad90
  id: 5,
  name: "Airbus10",
  cruising_range: 12,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Fri, 29 Jul 2022 13:01:53.657511000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x000055c79ce4abd8
  id: 2,
  name: "Airbus",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Sun, 31 Jul 2022 18:55:01.251819000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 18:55:01.251355000 IST +05:30>,
 #<Aircraft:0x000055c79ce4a9f8
  id: 1,
  name: "Airbus60",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Mon, 01 Aug 2022 14:20:44.250729000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 1,
  place: "PUNE",
  availability: Mon, 01 Aug 2022 17:19:00.000000000 IST +05:30>,
 #<Aircraft:0x000055c79ce4a868
  id: 6,
  name: "Airbus320",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Sun, 31 Jul 2022 19:14:48.998358000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "MUMBAI",
  availability: Sun, 31 Jul 2022 22:12:00.000000000 IST +05:30>,
 #<Aircraft:0x000055c79ce4a610
  id: 3,
  name: "Airbus20",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Fri, 29 Jul 2022 13:00:44.155286000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x000055c79ce4a4d0
  id: 7,
  name: "Airbus30",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Fri, 29 Jul 2022 13:01:36.008484000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 3,
  place: "DELHI",
  availability: Sun, 31 Jul 2022 05:53:16.260032000 IST +05:30>,
 #<Aircraft:0x000055c79ce4a390
  id: 29,
  name: "Boeing777",
  cruising_range: 242434,
  created_at: Mon, 01 Aug 2022 18:12:55.864800000 IST +05:30,
  updated_at: Tue, 02 Aug 2022 19:27:24.378772000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 0,
  place: "Delhi",
  availability: Tue, 02 Aug 2022 19:27:24.374755000 IST +05:30>,
 #<Aircraft:0x000055c79ce4a2a0
  id: 36,
  name: "Boeing730",
  cruising_range: 242434,
  created_at: Tue, 02 Aug 2022 19:48:36.934103000 IST +05:30,
  updated_at: Tue, 02 Aug 2022 19:48:36.934103000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 0,
  place: "Delhi",
  availability: Tue, 02 Aug 2022 19:48:36.934372000 IST +05:30>,
3.0.0 :017 > Aircraft.joins( :schedule)
(Object doesn't support #inspect)
 =>                                                                                                                 
3.0.0 :018 > Aircraft.joins( :schedules)
  Aircraft Load (1.4ms)  SELECT "aircrafts".* FROM "aircrafts" INNER JOIN "schedules" ON "schedules"."aircraft_id" = "aircrafts"."id"                                                                                                   
 =>                                                                                                                 
[#<Aircraft:0x000055c79f08a900                                                                                      
  id: 6,                                                                                                            
  name: "Airbus320",                                                                                                
  cruising_range: 1234566,                                                                                          
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Sun, 31 Jul 2022 19:14:48.998358000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "MUMBAI",
  availability: Sun, 31 Jul 2022 22:12:00.000000000 IST +05:30>,
 #<Aircraft:0x000055c79f08a838
  id: 1,
  name: "Airbus60",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Mon, 01 Aug 2022 14:20:44.250729000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 1,
  place: "PUNE",
  availability: Mon, 01 Aug 2022 17:19:00.000000000 IST +05:30>,
3.0.0 :019 > Aircraft.joins( :schedules, certifieds: :pilots)
  Aircraft Load (1.7ms)  SELECT "aircrafts".* FROM "aircrafts" INNER JOIN "schedules" ON "schedules"."aircraft_id" = "aircrafts"."id" INNER JOIN "certifieds" ON "certifieds"."aircraft_id" = "aircrafts"."id" INNER JOIN "employees" ON "employees"."id" = "certifieds"."employee_id"                                                                      
 =>                                                                                                                 
[#<Aircraft:0x000055c79fa6b780                                                                                      
  id: 4,                                                                                                            
  name: "Airbus620",                                                                                                
  cruising_range: 1234566,                                                                                          
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,                                                       
  updated_at: Tue, 02 Aug 2022 19:57:39.750648000 IST +05:30,                                                       
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "MUMBAI",
  availability: Tue, 02 Aug 2022 21:37:00.000000000 IST +05:30>,
 #<Aircraft:0x000055c79fa6b6b8
  id: 4,
  name: "Airbus620",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Tue, 02 Aug 2022 19:57:39.750648000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "MUMBAI",
  availability: Tue, 02 Aug 2022 21:37:00.000000000 IST +05:30>,
 #<Aircraft:0x000055c79fa6b5f0
  id: 1,
  name: "Airbus60",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Mon, 01 Aug 2022 14:20:44.250729000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 1,
  place: "PUNE",
  availability: Mon, 01 Aug 2022 17:19:00.000000000 IST +05:30>,
3.0.0 :020 > Aircraft.joins( :schedules, certifieds: :pilots).where("aircraft.name like ?","%Air%" )
  Aircraft Load (0.5ms)  SELECT "aircrafts".* FROM "aircrafts" INNER JOIN "schedules" ON "schedules"."aircraft_id" = "aircrafts"."id" INNER JOIN "certifieds" ON "certifieds"."aircraft_id" = "aircrafts"."id" INNER JOIN "employees" ON "employees"."id" = "certifieds"."employee_id" WHERE (aircraft.name like '%Air%')                                   
(Object doesn't support #inspect)                                                                                   
 =>                                                                                                                 
3.0.0 :021 > Aircraft.joins( :schedules, certifieds: :pilots).where("aircrafts.name like ?","%Air%" )
  Aircraft Load (0.8ms)  SELECT "aircrafts".* FROM "aircrafts" INNER JOIN "schedules" ON "schedules"."aircraft_id" = "aircrafts"."id" INNER JOIN "certifieds" ON "certifieds"."aircraft_id" = "aircrafts"."id" INNER JOIN "employees" ON "employees"."id" = "certifieds"."employee_id" WHERE (aircrafts.name like '%Air%')                                  
 =>                                                                                                                 
[#<Aircraft:0x000055c7a0097d20
  id: 4,
  name: "Airbus620",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Tue, 02 Aug 2022 19:57:39.750648000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "MUMBAI",
  availability: Tue, 02 Aug 2022 21:37:00.000000000 IST +05:30>,
 #<Aircraft:0x000055c7a0097be0
  id: 4,
  name: "Airbus620",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Tue, 02 Aug 2022 19:57:39.750648000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 2,
  place: "MUMBAI",
  availability: Tue, 02 Aug 2022 21:37:00.000000000 IST +05:30>,
 #<Aircraft:0x000055c7a0097a50
  id: 1,
  name: "Airbus60",
  cruising_range: 1234566,
  created_at: Mon, 23 May 2022 19:45:56.466482000 IST +05:30,
  updated_at: Mon, 01 Aug 2022 14:20:44.250729000 IST +05:30,
  aircraft_updated_at: nil,
  certifieds_count: 1,
  place: "PUNE",
  availability: Mon, 01 Aug 2022 17:19:00.000000000 IST +05:30>,
3.0.0 :022 > Aircraft.joins( :schedules, certifieds: [pilots:{:trainee }]).where("aircrafts.name like ?","%Air%" )
 => []                                                                                                              
3.0.0 :024 > Aircraft.joins( :schedules, certifieds: [pilots: :trainer ]).where("aircrafts.name like ?","%Air%" )
  Aircraft Load (1.7ms)  SELECT "aircrafts".* FROM "aircrafts" INNER JOIN "schedules" ON "schedules"."aircraft_id" = "aircrafts"."id" INNER JOIN "certifieds" ON "certifieds"."aircraft_id" = "aircrafts"."id" INNER JOIN "employees" ON "employees"."id" = "certifieds"."employee_id" INNER JOIN "employees" "trainers_employees" ON "trainers_employees"."id" = "employees"."trainer_id" WHERE (aircrafts.name like '%Air%')                        
 => []        

 3.0.0 :035 > Aircraft.order(cruising_range: :desc).limit(1).offset(2).pluck(:cruising_range)
  Aircraft Pluck (0.4ms)  SELECT "aircrafts"."cruising_range" FROM "aircrafts" ORDER BY "aircrafts"."cruising_range" DESC LIMIT $1 OFFSET $2  [["LIMIT", 1], ["OFFSET", 2]]                                                             
 => [1234566]                                                                                                       
3.0.0 :036 > Aircraft.order(cruising_range: :asc).limit(1).offset(2).pluck(:cruising_range)
  Aircraft Pluck (0.6ms)  SELECT "aircrafts"."cruising_range" FROM "aircrafts" ORDER BY "aircrafts"."cruising_range" ASC LIMIT $1 OFFSET $2  [["LIMIT", 1], ["OFFSET", 2]]                                                              
 => [242434] 