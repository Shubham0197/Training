Active Record Query Interface

It is the different ways to retrieve data from the database using Active Record. 
Instead of using the sql queries can use use to same things via Active record methods

## Retrieving Objects from the Database
To retrieve objects from the database, Active Record provides several finder methods.
The methods are:

annotate
find
create_with
distinct
eager_load
extending
extract_associated
from
group
having
includes
joins
left_outer_joins
limit
lock
none
offset
optimizer_hints
order
preload
readonly
references
reorder
reselect
reverse_order
select
where

Finder methods that return a collection, such as where and group, return an instance of ActiveRecord::Relation.
3.0.0 :004 > aircrafts = Aircraft.where("id > 4" )
  Aircraft Load (7.2ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE (id > 4)
 =>                                                                                          
[#<Aircraft:0x000055fd7b227c38                                                               
... 
3.0.0 :005 > aircrafts.class
 => Aircraft::ActiveRecord_Relation 


Methods that find a single entity, such as find and first, return a single instance of the model.
3.0.0 :006 > air = Aircraft.find(4)
  Aircraft Load (0.2ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE "aircrafts"."id" = $1 LIMIT $2  [["id", 4], ["LIMIT", 1]]                                                            
 =>                                                                   
#<Aircraft:0x000055fd7b1dfde8                                         
...  
3.0.0 :007 > air.class
 => Aircraft(id: integer, name: text, cruising_range: integer, created_at: datetime, updated_at: datetime, aircraft_updated_at: datetime, certifieds_count: integer)  

 So the operation steps are as followed
 The primary operation of Model.find(options) can be summarized as:

1 Convert the supplied options to an equivalent SQL query.
2 Fire the SQL query and retrieve the corresponding results from the database.
3 Instantiate the equivalent Ruby object of the appropriate model for every resulting row.
4 Run after_find and then after_initialize callbacks, if any.

1. annotate
Adds an SQL comment to queries generated from this relation.
3.0.0 :008 > Aircraft.annotate("selecting aircraft names").select(:name)
  Aircraft Load (0.6ms)  SELECT "aircrafts"."name" FROM "aircrafts" /* selecting aircraft names */
 =>                                                         
[#<Aircraft:0x00007f2744d63090 id: nil, name: "Airbus320">, 
 #<Aircraft:0x00007f2744d62fa0 id: nil, name: "Boeing737">, 
 #<Aircraft:0x00007f2744d62eb0 id: nil, name: "Jet01">,     
 #<Aircraft:0x00007f2744d62de8 id: nil, name: "Airbus380">, 
 #<Aircraft:0x00007f2744d62d20 id: nil, name: "Boeing777">, 
 #<Aircraft:0x00007f2744d62c08 id: nil, name: "PrivateCraft">,
 #<Aircraft:0x00007f2744d62af0 id: nil, name: "Aircraft200">,
 #<Aircraft:0x00007f2744d62a28 id: nil, name: nil>] 


 ## Retrieving a Single Object
  
  
  1. find
  Using the find method, it retrieve the object corresponding to the specified primary key that matches any supplied options
  The find method will raise an ActiveRecord::RecordNotFound exception unless a matching record is found for all of the supplied primary keys.
  3.0.0 :011 > Aircraft.find(1)
  Aircraft Load (0.7ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE "aircrafts"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                                      
 =>                                                             
#<Aircraft:0x00007f2744ab9470                                   
 id: 1,                                                         
 name: "Airbus320",                                             
 cruising_range: 1234566,                                       
 created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,    
 updated_at: Mon, 06 Jun 2022 13:40:48.895413000 UTC +00:00,    
 aircraft_updated_at: nil,                                      
 certifieds_count: 1>  

 can also use this method to query for multiple objects. Call the find method and pass in an array of primary keys. 
 The return will be an array containing all of the matching records for the supplied primary keys.
 3.0.0 :012 > keys = [1,2,3,4]
 => [1, 2, 3, 4] 
3.0.0 :013 > Aircraft.find(keys)
  Aircraft Load (0.8ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE "aircrafts"."id" IN ($1, $2, $3, $4)  [["id", 1], ["id", 2], ["id", 3], ["id", 4]]                                                  
 =>                                                             
[#<Aircraft:0x00007f27444bc180                                  
  id: 1,                                                        
  name: "Airbus320",                                            
  cruising_range: 1234566,                                      
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,   
  updated_at: Mon, 06 Jun 2022 13:40:48.895413000 UTC +00:00,   
  aircraft_updated_at: nil,                                     
  certifieds_count: 1>,                                         
 #<Aircraft:0x00007f27444bc068
  id: 2,
  name: "Boeing737",
  cruising_range: 5000,
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  aircraft_updated_at: nil,
  certifieds_count: 3>,
 #<Aircraft:0x000055fd7aa55e88
  id: 3,
  name: "Jet01",
  cruising_range: 5000,
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  aircraft_updated_at: nil,
  certifieds_count: 3>,
 #<Aircraft:0x00007f2744740be0
  id: 4,
  name: "Airbus380",
  cruising_range: 8000,
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  aircraft_updated_at: nil,
  certifieds_count: 2>

2 take
The take method retrieves a record without any implicit ordering
The take method returns nil if no record is found and no exception will be raised.

3.0.0 :035 > Certified.take
  Certified Load (0.4ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 1]]
 =>                           
#<Certified:0x00007f2744bb0ec8
 id: 3,                       
 aircraft_id: 3,              
 created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
 updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00> 
3.0.0 :036 > Certified.take(1)
  Certified Load (0.4ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 1]]
 =>                         
[#<Certified:0x00007f2744d122f8
  id: 3,                  
  employee_id: 1,
  aircraft_id: 3,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>] 
3.0.0 :037 > Certified.take(2)
  Certified Load (0.6ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 2]]
 => 

You can pass in a numerical argument to the take method to return up to that number of results
3.0.0 :037 > Certified.take(2)
  Certified Load (0.6ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 2]]
 => 
[#<Certified:0x00007f274411fd38
  id: 3,
  employee_id: 1,
  aircraft_id: 3,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
 #<Certified:0x00007f274411fc48
  id: 4,
  employee_id: 5,
  aircraft_id: 3,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>] 
3.0.0 :038 > 
The take! method behaves exactly like take, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.


3 first
The first method finds the first record ordered by primary key (default) but if any order method is defined in scope the it will order according to that.
The first method returns nil if no matching record is found and no exception will be raised.
3.0.0 :038 > Employee.first
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 1]]
 =>                                                              
#<Employee:0x00007f2744356840                                    
 id: 1,                                                          
 name: "Ajay",                                                   
 salary: 30000,                                                  
 mobile_number: "123456789",                                     
 DOB: nil,                                                       
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,     
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,     
 count_of_pilots: 3,                                             
 trainer_id: nil>  

can pass in a numerical argument to the first method to return up to that number of results.
3.0.0 :039 > Employee.first(2)
  Employee Load (0.7ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 2]]
 =>                                      
[#<Employee:0x000055fd7b348a18           
  id: 1,                                 
  name: "Ajay",                          
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055fd7b348950
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  collection that is ordered using order, first will return the first record ordered by the specified attribute for order.

  3.0.0 :044 > Employee.order(name: :desc).first
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."name" DESC LIMIT $1  [["LIMIT", 1]]
 =>                                                    
#<Employee:0x000055fd7b9397b0                          
 id: 13,                                               
 name: "Tesh",                                         
 salary: nil,                                          
 mobile_number: nil,                                   
 DOB: Wed, 01 Jan 1997,                                
 created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
 updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
 count_of_pilots: nil,                                 
 trainer_id: nil>  
 The first! method behaves exactly like first, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.

 4 last
 The last method finds the last record ordered by primary key (default).
 It function same as  first but in opposite order. Like if fisrt is ascending then last is descending.

3.0.0 :045 > Employee.last(2)
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" DESC LIMIT $1  [["LIMIT", 2]]
 =>                                                             
[#<Employee:0x00007f2744d4eb90                                  
  id: 11,                                                       
  name: "Gustav",                                               
  salary: nil,                                                  
  mobile_number: nil,                                           
  DOB: Wed, 01 Jan 1997,                                        
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,   
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,   
  count_of_pilots: nil,                                         
  trainer_id: nil>,                                             
 #<Employee:0x00007f2744d4ec58                                  
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>] 

  3.0.0 :046 > Employee.order(name: :desc).last
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."name" ASC LIMIT $1  [["LIMIT", 1]]
 =>                                                                      
#<Employee:0x000055fd7baab648                                            
 id: 1,                                                                  
 name: "Ajay",                                                           
 salary: 30000,                                                          
 mobile_number: "123456789",                                             
 DOB: nil,                                                               
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,             
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,             
 count_of_pilots: 3,                                                     
 trainer_id: nil> 

 5 find_by    
 The find_by method finds the first record matching some conditions.
 Here as find only see primary key here have to specify the column to match
As there e is no ORDER BY so  find_by conditions can match multiple records, have apply an order to guarantee a deterministic result.
The find_by! method behaves exactly like find_by, except that it will raise ActiveRecord::RecordNotFound if no matching record is found
3.0.0 :049 > Employee.find_by name: "Ajit"
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Ajit"], ["LIMIT", 1]]
 => nil 
3.0.0 :050 > Employee.find_by name: "Ajith"
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Ajith"], ["LIMIT", 1]]
 => 
#<Employee:0x000055fd7b20cd20
 id: 2,
 name: "Ajith",
 salary: 85000,
 mobile_number: "123456789",
 DOB: nil,
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
 updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
 count_of_pilots: 2,
 trainer_id: nil> 

 3.0.0 :052 > Employee.find_by! name: "Ajit"
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Ajit"], ["LIMIT", 1]]
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/relation/finder_methods.rb:378:in raise_record_not_found_exception!': Couldn't find Employee with [WHERE "employees"."name" = $1] (ActiveRecord::RecordNotFound)


## Retrieving Multiple Objects in Batches






---------------------------------------------------------------

##  Ordering
To retrieve records from the database in a specific order, you can use the order method.
can give both asc and desc but by default is asc
3.0.0 :054 > Employee.order(name: :desc).limit 4
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."name" DESC LIMIT $1  [["LIMIT", 4]]
 =>                                                                          
[#<Employee:0x00007f2744b0b7e8                                               
  id: 13,                                                                    
  name: "Tesh",                                                              
  salary: nil,                                                               
  mobile_number: nil,                                                        
  DOB: Wed, 01 Jan 1997,                                                     
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                
  count_of_pilots: nil,                                                      
  trainer_id: nil>,                                                          
 #<Employee:0x00007f2744b0b720                                               
  id: 8,
  name: "shubham",
  salary: 120000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.979496000 UTC +00:00,
  count_of_pilots: 0,
  trainer_id: nil>,
 #<Employee:0x00007f2744b0b658
  id: 6,
  name: "Sam",
  salary: 75000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.977471000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f2744b0b590
  id: 7,
  name: "Ram",
  salary: 150000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.978501000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  can order by multiple columns
  3.0.0 :057 > Employee.order(mobile_number: :desc, id: :asc).limit 4
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."mobile_number" DESC, "employees"."id" ASC LIMIT $1  [["LIMIT", 4]]                            
 =>                                       
[#<Employee:0x000055fd7be20a08            
  id: 11,                                 
  name: "Gustav",                      
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055fd7be20940
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055fd7be20878
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055fd7be207b0
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  Can call order multiple times 
  If you want to call order multiple times, subsequent orders will be appended to the first
  but that will work like above.
  3.0.0 :058 > Employee.order(mobile_number: :desc).order( id: :asc).limit 4
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."mobile_number" DESC, "employees"."id" ASC LIMIT $1  [["LIMIT", 4]]                                                                    
 =>                                                                               
[#<Employee:0x000055fd7b414e10                                                    
  id: 11,                                                                         
  name: "Gustav",                                                                 
  salary: nil,                                                                    
  mobile_number: nil,                                                             
  DOB: Wed, 01 Jan 1997,                                                          
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                     
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                     
  count_of_pilots: nil,                                                           
  trainer_id: nil>,                                                               
 #<Employee:0x000055fd7b414d48
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055fd7b414c80
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055fd7b414bb8
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 
3.0.0 :059 > 
-------------------------------------------------------------------------------
## Selecting Specific Fields

Model.find selects all the fields from the result set using select *
To select only a subset of fields from the result set, you can specify the subset via the select method.
3.0.0 :001 > Employee.select(:name, :mobile_number)
  Employee Load (1.0ms)  SELECT "employees"."name", "employees"."mobile_number" FROM "employees"
 =>                                                                                            
[#<Employee:0x0000557b04d08fe8 id: nil, name: "Ajay", mobile_number: "123456789">,             
 #<Employee:0x0000557b04dc32a8 id: nil, name: "Ajith", mobile_number: "123456789">,            
 #<Employee:0x0000557b04dc31e0 id: nil, name: "Arnab", mobile_number: "123456789">,            
 #<Employee:0x0000557b04dc3118 id: nil, name: "Amar", mobile_number: "123456789">,             
 #<Employee:0x0000557b04dc3050 id: nil, name: "Pritam", mobile_number: "123456789">,           
 #<Employee:0x0000557b04dc2f88 id: nil, name: "Sam", mobile_number: "123456789">,              
 #<Employee:0x0000557b04dc2ec0 id: nil, name: "Ram", mobile_number: "123456789">,              
 #<Employee:0x0000557b04dc2df8 id: nil, name: "shubham", mobile_number: "123456789">,          
 #<Employee:0x0000557b04dc2d30 id: nil, name: "naman", mobile_number: "123456789">,            
 #<Employee:0x0000557b04dc2c68 id: nil, name: "Gustav", mobile_number: nil>,                   
 #<Employee:0x0000557b04dc2ba0 id: nil, name: "Tesh", mobile_number: nil>] 

 So this also means you're initializing a model object with only the fields that you've selected.
  If you attempt to access a field that is not in the initialized record you'll receive'
  3.0.0 :002 > emp = Employee.select(:name, :mobile_number).first
  Employee Load (0.6ms)  SELECT "employees"."name", "employees"."mobile_number" FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 1]]                                                 
 => #<Employee:0x0000557b0511bcc0 id: nil, name: "Ajay", mobile_number: "123456789"> 
 3.0.0 :004 > emp.salary
 /home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activemodel-7.0.3/lib/active_model/attribute.rb:226:in value': 'missing attribute: salary (ActiveModel::MissingAttributeError)    

 But The id method will not raise the ActiveRecord::MissingAttributeError, so have to be careful when working with associations because they need the id method to function properly.
 
 
 If you would like to only grab a single record per unique value in a certain field, you can use distinct
 3.0.0 :006 > emp = Employee.select( :mobile_number).distinct
 Employee Load (1.2ms)  SELECT DISTINCT "employees"."mobile_number" FROM "employees"
=>                                                                                           
[#<Employee:0x0000557b0588af88 id: nil, mobile_number: "123456789">,                          
...                                                     
    
Can also remove distinct constraint
3.0.0 :008 > emp.distinct(false)
  Employee Load (0.2ms)  SELECT "employees"."mobile_number" FROM "employees"
 =>                                                                                 
[#<Employee:0x0000557b05c93aa8 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c93990 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c938a0 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c93788 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c93670 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93580 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93468 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93350 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93260 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93148 id: nil, mobile_number: nil>,
 #<Employee:0x0000557b05c93030 id: nil, mobile_number: nil>] 
3.0.0 :009 > 


-------------------------------------------------------------------------------
## Limit and Offset