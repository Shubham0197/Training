Active Record Query Interface

It is the different ways to retrieve data from the database using Active Record. 
Instead of using the sql queries can use use to same things via Active record methods

## Retrieving Objects from the Database
To retrieve objects from the database, Active Record provides several finder methods.
The methods are:

annotate
find
create_with
distinct
eager_load
extending
extract_associated
from
group
having
includes
joins
left_outer_joins
limit
lock
none
offset
optimizer_hints
order
preload
readonly
references
reorder
reselect
reverse_order
select
where

Finder methods that return a collection, such as where and group, return an instance of ActiveRecord::Relation.
3.0.0 :004 > aircrafts = Aircraft.where("id > 4" )
  Aircraft Load (7.2ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE (id > 4)
 =>                                                                                          
[#<Aircraft:0x000055fd7b227c38                                                               
... 
3.0.0 :005 > aircrafts.class
 => Aircraft::ActiveRecord_Relation 


Methods that find a single entity, such as find and first, return a single instance of the model.
3.0.0 :006 > air = Aircraft.find(4)
  Aircraft Load (0.2ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE "aircrafts"."id" = $1 LIMIT $2  [["id", 4], ["LIMIT", 1]]                                                            
 =>                                                                   
#<Aircraft:0x000055fd7b1dfde8                                         
...  
3.0.0 :007 > air.class
 => Aircraft(id: integer, name: text, cruising_range: integer, created_at: datetime, updated_at: datetime, aircraft_updated_at: datetime, certifieds_count: integer)  

 So the operation steps are as followed
 The primary operation of Model.find(options) can be summarized as:

1 Convert the supplied options to an equivalent SQL query.
2 Fire the SQL query and retrieve the corresponding results from the database.
3 Instantiate the equivalent Ruby object of the appropriate model for every resulting row.
4 Run after_find and then after_initialize callbacks, if any.

1. annotate
Adds an SQL comment to queries generated from this relation.
3.0.0 :008 > Aircraft.annotate("selecting aircraft names").select(:name)
  Aircraft Load (0.6ms)  SELECT "aircrafts"."name" FROM "aircrafts" /* selecting aircraft names */
 =>                                                         
[#<Aircraft:0x00007f2744d63090 id: nil, name: "Airbus320">, 
 #<Aircraft:0x00007f2744d62fa0 id: nil, name: "Boeing737">, 
 #<Aircraft:0x00007f2744d62eb0 id: nil, name: "Jet01">,     
 #<Aircraft:0x00007f2744d62de8 id: nil, name: "Airbus380">, 
 #<Aircraft:0x00007f2744d62d20 id: nil, name: "Boeing777">, 
 #<Aircraft:0x00007f2744d62c08 id: nil, name: "PrivateCraft">,
 #<Aircraft:0x00007f2744d62af0 id: nil, name: "Aircraft200">,
 #<Aircraft:0x00007f2744d62a28 id: nil, name: nil>] 


 ## Retrieving a Single Object
  
  
  1. find
  Using the find method, it retrieve the object corresponding to the specified primary key that matches any supplied options
  The find method will raise an ActiveRecord::RecordNotFound exception unless a matching record is found for all of the supplied primary keys.
  3.0.0 :011 > Aircraft.find(1)
  Aircraft Load (0.7ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE "aircrafts"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                                      
 =>                                                             
#<Aircraft:0x00007f2744ab9470                                   
 id: 1,                                                         
 name: "Airbus320",                                             
 cruising_range: 1234566,                                       
 created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,    
 updated_at: Mon, 06 Jun 2022 13:40:48.895413000 UTC +00:00,    
 aircraft_updated_at: nil,                                      
 certifieds_count: 1>  

 can also use this method to query for multiple objects. Call the find method and pass in an array of primary keys. 
 The return will be an array containing all of the matching records for the supplied primary keys.
 3.0.0 :012 > keys = [1,2,3,4]
 => [1, 2, 3, 4] 
3.0.0 :013 > Aircraft.find(keys)
  Aircraft Load (0.8ms)  SELECT "aircrafts".* FROM "aircrafts" WHERE "aircrafts"."id" IN ($1, $2, $3, $4)  [["id", 1], ["id", 2], ["id", 3], ["id", 4]]                                                  
 =>                                                             
[#<Aircraft:0x00007f27444bc180                                  
  id: 1,                                                        
  name: "Airbus320",                                            
  cruising_range: 1234566,                                      
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,   
  updated_at: Mon, 06 Jun 2022 13:40:48.895413000 UTC +00:00,   
  aircraft_updated_at: nil,                                     
  certifieds_count: 1>,                                         
 #<Aircraft:0x00007f27444bc068
  id: 2,
  name: "Boeing737",
  cruising_range: 5000,
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  aircraft_updated_at: nil,
  certifieds_count: 3>,
 #<Aircraft:0x000055fd7aa55e88
  id: 3,
  name: "Jet01",
  cruising_range: 5000,
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  aircraft_updated_at: nil,
  certifieds_count: 3>,
 #<Aircraft:0x00007f2744740be0
  id: 4,
  name: "Airbus380",
  cruising_range: 8000,
  created_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:45:56.466482000 UTC +00:00,
  aircraft_updated_at: nil,
  certifieds_count: 2>

2 take
The take method retrieves a record without any implicit ordering
The take method returns nil if no record is found and no exception will be raised.

3.0.0 :035 > Certified.take
  Certified Load (0.4ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 1]]
 =>                           
#<Certified:0x00007f2744bb0ec8
 id: 3,                       
 aircraft_id: 3,              
 created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
 updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00> 
3.0.0 :036 > Certified.take(1)
  Certified Load (0.4ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 1]]
 =>                         
[#<Certified:0x00007f2744d122f8
  id: 3,                  
  employee_id: 1,
  aircraft_id: 3,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>] 
3.0.0 :037 > Certified.take(2)
  Certified Load (0.6ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 2]]
 => 

You can pass in a numerical argument to the take method to return up to that number of results
3.0.0 :037 > Certified.take(2)
  Certified Load (0.6ms)  SELECT "certifieds".* FROM "certifieds" LIMIT $1  [["LIMIT", 2]]
 => 
[#<Certified:0x00007f274411fd38
  id: 3,
  employee_id: 1,
  aircraft_id: 3,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
 #<Certified:0x00007f274411fc48
  id: 4,
  employee_id: 5,
  aircraft_id: 3,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>] 
3.0.0 :038 > 
The take! method behaves exactly like take, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.


3 first
The first method finds the first record ordered by primary key (default) but if any order method is defined in scope the it will order according to that.
The first method returns nil if no matching record is found and no exception will be raised.
3.0.0 :038 > Employee.first
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 1]]
 =>                                                              
#<Employee:0x00007f2744356840                                    
 id: 1,                                                          
 name: "Ajay",                                                   
 salary: 30000,                                                  
 mobile_number: "123456789",                                     
 DOB: nil,                                                       
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,     
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,     
 count_of_pilots: 3,                                             
 trainer_id: nil>  

can pass in a numerical argument to the first method to return up to that number of results.
3.0.0 :039 > Employee.first(2)
  Employee Load (0.7ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 2]]
 =>                                      
[#<Employee:0x000055fd7b348a18           
  id: 1,                                 
  name: "Ajay",                          
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055fd7b348950
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  collection that is ordered using order, first will return the first record ordered by the specified attribute for order.

  3.0.0 :044 > Employee.order(name: :desc).first
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."name" DESC LIMIT $1  [["LIMIT", 1]]
 =>                                                    
#<Employee:0x000055fd7b9397b0                          
 id: 13,                                               
 name: "Tesh",                                         
 salary: nil,                                          
 mobile_number: nil,                                   
 DOB: Wed, 01 Jan 1997,                                
 created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
 updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
 count_of_pilots: nil,                                 
 trainer_id: nil>  
 The first! method behaves exactly like first, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.

 4 last
 The last method finds the last record ordered by primary key (default).
 It function same as  first but in opposite order. Like if fisrt is ascending then last is descending.

3.0.0 :045 > Employee.last(2)
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" DESC LIMIT $1  [["LIMIT", 2]]
 =>                                                             
[#<Employee:0x00007f2744d4eb90                                  
  id: 11,                                                       
  name: "Gustav",                                               
  salary: nil,                                                  
  mobile_number: nil,                                           
  DOB: Wed, 01 Jan 1997,                                        
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,   
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,   
  count_of_pilots: nil,                                         
  trainer_id: nil>,                                             
 #<Employee:0x00007f2744d4ec58                                  
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>] 

  3.0.0 :046 > Employee.order(name: :desc).last
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."name" ASC LIMIT $1  [["LIMIT", 1]]
 =>                                                                      
#<Employee:0x000055fd7baab648                                            
 id: 1,                                                                  
 name: "Ajay",                                                           
 salary: 30000,                                                          
 mobile_number: "123456789",                                             
 DOB: nil,                                                               
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,             
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,             
 count_of_pilots: 3,                                                     
 trainer_id: nil> 

 5 find_by    
 The find_by method finds the first record matching some conditions.
 Here as find only see primary key here have to specify the column to match
As there e is no ORDER BY so  find_by conditions can match multiple records, have apply an order to guarantee a deterministic result.
The find_by! method behaves exactly like find_by, except that it will raise ActiveRecord::RecordNotFound if no matching record is found
3.0.0 :049 > Employee.find_by name: "Ajit"
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Ajit"], ["LIMIT", 1]]
 => nil 
3.0.0 :050 > Employee.find_by name: "Ajith"
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Ajith"], ["LIMIT", 1]]
 => 
#<Employee:0x000055fd7b20cd20
 id: 2,
 name: "Ajith",
 salary: 85000,
 mobile_number: "123456789",
 DOB: nil,
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
 updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
 count_of_pilots: 2,
 trainer_id: nil> 

 3.0.0 :052 > Employee.find_by! name: "Ajit"
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1 LIMIT $2  [["name", "Ajit"], ["LIMIT", 1]]
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/relation/finder_methods.rb:378:in raise_record_not_found_exception!': Couldn't find Employee with [WHERE "employees"."name" = $1] (ActiveRecord::RecordNotFound)


## Retrieving Multiple Objects in Batches






---------------------------------------------------------------

##  Ordering
To retrieve records from the database in a specific order, you can use the order method.
can give both asc and desc but by default is asc
3.0.0 :054 > Employee.order(name: :desc).limit 4
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."name" DESC LIMIT $1  [["LIMIT", 4]]
 =>                                                                          
[#<Employee:0x00007f2744b0b7e8                                               
  id: 13,                                                                    
  name: "Tesh",                                                              
  salary: nil,                                                               
  mobile_number: nil,                                                        
  DOB: Wed, 01 Jan 1997,                                                     
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                
  count_of_pilots: nil,                                                      
  trainer_id: nil>,                                                          
 #<Employee:0x00007f2744b0b720                                               
  id: 8,
  name: "shubham",
  salary: 120000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.979496000 UTC +00:00,
  count_of_pilots: 0,
  trainer_id: nil>,
 #<Employee:0x00007f2744b0b658
  id: 6,
  name: "Sam",
  salary: 75000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.977471000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x00007f2744b0b590
  id: 7,
  name: "Ram",
  salary: 150000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.978501000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  can order by multiple columns
  3.0.0 :057 > Employee.order(mobile_number: :desc, id: :asc).limit 4
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."mobile_number" DESC, "employees"."id" ASC LIMIT $1  [["LIMIT", 4]]                            
 =>                                       
[#<Employee:0x000055fd7be20a08            
  id: 11,                                 
  name: "Gustav",                      
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055fd7be20940
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055fd7be20878
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055fd7be207b0
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  Can call order multiple times 
  If you want to call order multiple times, subsequent orders will be appended to the first
  but that will work like above.
  3.0.0 :058 > Employee.order(mobile_number: :desc).order( id: :asc).limit 4
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."mobile_number" DESC, "employees"."id" ASC LIMIT $1  [["LIMIT", 4]]                                                                    
 =>                                                                               
[#<Employee:0x000055fd7b414e10                                                    
  id: 11,                                                                         
  name: "Gustav",                                                                 
  salary: nil,                                                                    
  mobile_number: nil,                                                             
  DOB: Wed, 01 Jan 1997,                                                          
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                     
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                     
  count_of_pilots: nil,                                                           
  trainer_id: nil>,                                                               
 #<Employee:0x000055fd7b414d48
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055fd7b414c80
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055fd7b414bb8
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 
3.0.0 :059 > 
-------------------------------------------------------------------------------
## Selecting Specific Fields

Model.find selects all the fields from the result set using select *
To select only a subset of fields from the result set, you can specify the subset via the select method.
3.0.0 :001 > Employee.select(:name, :mobile_number)
  Employee Load (1.0ms)  SELECT "employees"."name", "employees"."mobile_number" FROM "employees"
 =>                                                                                            
[#<Employee:0x0000557b04d08fe8 id: nil, name: "Ajay", mobile_number: "123456789">,             
 #<Employee:0x0000557b04dc32a8 id: nil, name: "Ajith", mobile_number: "123456789">,            
 #<Employee:0x0000557b04dc31e0 id: nil, name: "Arnab", mobile_number: "123456789">,            
 #<Employee:0x0000557b04dc3118 id: nil, name: "Amar", mobile_number: "123456789">,             
 #<Employee:0x0000557b04dc3050 id: nil, name: "Pritam", mobile_number: "123456789">,           
 #<Employee:0x0000557b04dc2f88 id: nil, name: "Sam", mobile_number: "123456789">,              
 #<Employee:0x0000557b04dc2ec0 id: nil, name: "Ram", mobile_number: "123456789">,              
 #<Employee:0x0000557b04dc2df8 id: nil, name: "shubham", mobile_number: "123456789">,          
 #<Employee:0x0000557b04dc2d30 id: nil, name: "naman", mobile_number: "123456789">,            
 #<Employee:0x0000557b04dc2c68 id: nil, name: "Gustav", mobile_number: nil>,                   
 #<Employee:0x0000557b04dc2ba0 id: nil, name: "Tesh", mobile_number: nil>] 

 So this also means you're initializing a model object with only the fields that you've selected.
  If you attempt to access a field that is not in the initialized record you'll receive'
  3.0.0 :002 > emp = Employee.select(:name, :mobile_number).first
  Employee Load (0.6ms)  SELECT "employees"."name", "employees"."mobile_number" FROM "employees" ORDER BY "employees"."id" ASC LIMIT $1  [["LIMIT", 1]]                                                 
 => #<Employee:0x0000557b0511bcc0 id: nil, name: "Ajay", mobile_number: "123456789"> 
 3.0.0 :004 > emp.salary
 /home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activemodel-7.0.3/lib/active_model/attribute.rb:226:in value': 'missing attribute: salary (ActiveModel::MissingAttributeError)    

 But The id method will not raise the ActiveRecord::MissingAttributeError, so have to be careful when working with associations because they need the id method to function properly.
 
 
 If you would like to only grab a single record per unique value in a certain field, you can use distinct
 3.0.0 :006 > emp = Employee.select( :mobile_number).distinct
 Employee Load (1.2ms)  SELECT DISTINCT "employees"."mobile_number" FROM "employees"
=>                                                                                           
[#<Employee:0x0000557b0588af88 id: nil, mobile_number: "123456789">,                          
...                                                     
    
Can also remove distinct constraint
3.0.0 :008 > emp.distinct(false)
  Employee Load (0.2ms)  SELECT "employees"."mobile_number" FROM "employees"
 =>                                                                                 
[#<Employee:0x0000557b05c93aa8 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c93990 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c938a0 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c93788 id: nil, mobile_number: "123456789">,                
 #<Employee:0x0000557b05c93670 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93580 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93468 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93350 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93260 id: nil, mobile_number: "123456789">,
 #<Employee:0x0000557b05c93148 id: nil, mobile_number: nil>,
 #<Employee:0x0000557b05c93030 id: nil, mobile_number: nil>] 
3.0.0 :009 > 


-------------------------------------------------------------------------------
## Limit and Offset
To apply LIMIT to the SQL fired by the Model.find, you can specify the LIMIT using limit and offset methods on the relation.
Limit constraints the no of rows it has to return and offset constrsaints will tell limit to start from that row.

3.0.0 :010 > Employee.limit 2
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" LIMIT $1  [["LIMIT", 2]]
 =>                                                             
[#<Employee:0x0000557b06068570                                  
  id: 1,                                                        
  name: "Ajay",                                                 
  salary: 30000,                                                
  mobile_number: "123456789",                                   
  DOB: nil,                                                     
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,   
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,   
  count_of_pilots: 3,                                           
  trainer_id: nil>,                                             
 #<Employee:0x0000557b060684a8                                  
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 


  3.0.0 :012 > Employee.limit(2).offset 3
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" LIMIT $1 OFFSET $2  [["LIMIT", 2], ["OFFSET", 3]]
 =>                                                           
[#<Employee:0x0000557b05202418                                
  id: 4,                                                      
  name: "Amar",                                               
  salary: 45000,                                              
  mobile_number: "123456789",                                 
  DOB: nil,                                                   
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00, 
  updated_at: Thu, 26 May 2022 09:47:38.975047000 UTC +00:00, 
  count_of_pilots: 3,                                         
  trainer_id: nil>,
 #<Employee:0x0000557b05202350
  id: 5,
  name: "Pritam",
  salary: 90000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.976349000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>]

  ----------------------------------------------------------------------------
  ## Group
  To apply a GROUP BY clause to the SQL fired by the finder, have to  use the group method.
  Certified Load (6.8ms)  SELECT "certifieds"."employee_id" FROM "certifieds" GROUP BY "certifieds"."employee_id"
 =>                                                                                                          
[#<Certified:0x0000557b05870bb0 id: nil, employee_id: 3>,                                                    
 #<Certified:0x0000557b0589b450 id: nil, employee_id: 5>,                                                    
 #<Certified:0x0000557b0589b388 id: nil, employee_id: 4>,                                                    
 #<Certified:0x0000557b0589b2c0 id: nil, employee_id: 6>,                                                    
 #<Certified:0x0000557b0589b1f8 id: nil, employee_id: 2>,                                                    
 #<Certified:0x0000557b0589b130 id: nil, employee_id: 7>,                                                    
 #<Certified:0x0000557b0589b068 id: nil, employee_id: 1>] 
 3.0.0 :016 > Certified.select(:employee_id, :aircraft_id).group(:employee_id, :aircraft_id)
  Certified Load (0.3ms)  SELECT "certifieds"."employee_id", "certifieds"."aircraft_id" FROM "certifieds" GROUP BY "certifieds"."employee_id", "certifieds"."aircraft_id"                                                               
 =>                                                                                                                 
[#<Certified:0x0000557b060b3098 id: nil, employee_id: 4, aircraft_id: 1>,                                           
 #<Certified:0x0000557b060b2e68 id: nil, employee_id: 1, aircraft_id: 3>,                                           
 #<Certified:0x0000557b060b2c88 id: nil, employee_id: 4, aircraft_id: 2>,                                           
 #<Certified:0x0000557b060b2aa8 id: nil, employee_id: 2, aircraft_id: 2>,                                           
 #<Certified:0x0000557b060b2828 id: nil, employee_id: 7, aircraft_id: 6>,                                           
 #<Certified:0x0000557b060b2648 id: nil, employee_id: 3, aircraft_id: 4>,                                           
 #<Certified:0x0000557b060b2468 id: nil, employee_id: 6, aircraft_id: 7>,                                           
 #<Certified:0x0000557b060b21e8 id: nil, employee_id: 4, aircraft_id: 3>,                                           
 #<Certified:0x0000557b060b1ec8 id: nil, employee_id: 2, aircraft_id: 6>,                                           
 #<Certified:0x0000557b060b1ba8 id: nil, employee_id: 1, aircraft_id: 2>,                                           
 #<Certified:0x0000557b060b1888 id: nil, employee_id: 3, aircraft_id: 5>,
 #<Certified:0x0000557b060b1608 id: nil, employee_id: 5, aircraft_id: 3>,
 #<Certified:0x0000557b060b1428 id: nil, employee_id: 1, aircraft_id: 7>,
 #<Certified:0x0000557b060b11a8 id: nil, employee_id: 7, aircraft_id: 5>,
 #<Certified:0x0000557b060b0f50 id: nil, employee_id: 6, aircraft_id: 4>,
 #<Certified:0x0000557b060b0dc0 id: nil, employee_id: 5, aircraft_id: 7>]

Total of the grouped items
HAve to call count after the group.
3.0.0 :018 > Certified.select(:employee_id).group(:employee_id).count
  Certified Count (7.6ms)  SELECT COUNT("certifieds"."employee_id") AS "count_employee_id", "certifieds"."employee_id" AS "certifieds_employee_id" FROM "certifieds" GROUP BY "certifieds"."employee_id"                                
 => {3=>2, 5=>2, 4=>3, 6=>2, 2=>2, 7=>2, 1=>3}

 --------------------------------------------------------------------------------------

 ## Readonly Objects

 It is to create object which is as name suggests read only 
 Active Record provides the readonly method on a relation to explicitly disallow modification of any of the returned objects. 
 Any attempt to alter a readonly record will not succeed, raising an ActiveRecord::ReadOnlyRecord exception.

 3.0.0 :022 > emp = Employee.readonly.find(2)
 Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]                                                                                    
=>                                                                                           
#<Employee:0x0000557b048db0b0                                                                 
... 
3.0.0 :025 > emp.name = "changin"
 => "changin" 
3.0.0 :026 > emp.save!
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/persistence.rb:1123:in '_raise_readonly_record_error': Employee is marked as readonly (ActiveRecord::ReadOnlyRecord)

Functions to check read only


----------------------------------------------------------------------------------------------------
## Null Relation

 ???? when to use null realtion

 The none method returns a chainable relation with no records.

 3.0.0 :030 > emp = Employee.none
 => [] 
3.0.0 :031 > emp.class
 => Employee::ActiveRecord_Relation 
  
 3.0.0 :032 > emp.name = "shubham"
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/relation/delegation.rb:110:in `method_missing': undefined method `name=' for #<ActiveRecord::Relation []> (NoMethodError)
3.0.0 :033 > '


--------------------------------------------------------------------------------
## Running EXPLAIN

You can run explain on a relation. EXPLAIN output varies for each database.
3.0.0 :034 > Certified.select(:employee_id).group(:employee_id).explain
  Certified Load (0.3ms)  SELECT "certifieds"."employee_id" FROM "certifieds" GROUP BY "certifieds"."employee_id"
 =>                                                                                             
EXPLAIN for: SELECT "certifieds"."employee_id" FROM "certifieds" GROUP BY "certifieds"."employee_id"
                             QUERY PLAN                                                         
--------------------------------------------------------------------                            
 HashAggregate  (cost=27.00..29.00 rows=200 width=4)                                            
   Group Key: employee_id                                                                       
   ->  Seq Scan on certifieds  (cost=0.00..23.60 rows=1360 width=4)                             
(3 rows)                                                                                        
           

------------------------------------------------------------------------------

## Calculations

1. Count
to see how many records are in your models table
This section uses count as an example method in this preamble, but the options described apply to all sub-sections.
3.0.0 :035 > Employee.count
  Employee Count (0.8ms)  SELECT COUNT(*) FROM "employees"
 => 11  

2.average
If you want to see the average of a certain number in one of your tables you can call the average method on the class that relates to the table.

3.0.0 :044 > Certified.select(:id).average("id")
  Certified Average (0.4ms)  SELECT AVG("certifieds"."id") FROM "certifieds"
 => 0.95e1                                                                                                   
3.0.0 :045 > Certified.select(:id).average("id").class
  Certified Average (0.7ms)  SELECT AVG("certifieds"."id") FROM "certifieds"
 => BigDecimal  


 3 Minimum
 If you want to find the minimum value of a field in your table you can call the minimum method on the class that relates to the table.
 3.0.0 :049 > Employee.minimum(:salary)
 Employee Minimum (0.8ms)  SELECT MIN("employees"."salary") FROM "employees"
=> 30000 

 4 Maximum
 If you want to find the maximum value of a field in your table you can call the maximum method on the class that relates to the table.

 3.0.0 :048 > Employee.maximum(:salary)
 Employee Maximum (0.7ms)  SELECT MAX("employees"."salary") FROM "employees"
=> 150000

 5 Sum
 If you want to find the sum of a field for all records in your table you can call the sum method on the class that relates to the table.
 3.0.0 :047 > Employee.sum(:salary)
 Employee Sum (0.9ms)  SELECT SUM("employees"."salary") FROM "employees"
=> 768345 


-------------------------------------------------------------------------------

## Array Conditions
To use condition to get specific result can use where 
Here for eg.
1 Pure String Conditions 
Active Record will take the first argument as the conditions string and any additional arguments will replace the question marks (?) in it.

3.0.0 :001 > Employee.where("salary > ?", 100000) 
  Employee Load (1.8ms)  SELECT "employees".* FROM "employees" WHERE (salary > 100000)
 =>                                                                                                  
[#<Employee:0x000055d38c10c678                                                                       
  id: 7,                                                                                             
  name: "Ram",                                                                                       
  salary: 150000,                                                                                    
  mobile_number: "123456789",                                                                        
  DOB: nil,                                                                                          
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                        
  updated_at: Thu, 26 May 2022 09:47:38.978501000 UTC +00:00,                                        
  count_of_pilots: 2,                                                                                
  trainer_id: nil>,                                                                                  

So based on above condition can also give multiple condition
3.0.0 :004 > Employee.where("salary < ? or name = ? ", 100000, "Ajith") 
  Employee Load (0.8ms)  SELECT "employees".* FROM "employees" WHERE (salary < 100000 or name = 'Ajith' )
 => 
[#<Employee:0x000055d38c6860b8
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055d38c685ff0
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,

  The method below used should not be used in project as it makes system vunerable to sql injection.
  As Putting the variable directly into the conditions string will pass the variable to the database as-is.
  3.0.0 :005 > salary = 10000 
 => 10000 
 Putting the variable directly into the conditions string will pass the variable to the database as-is.
 3.0.0 :006 > Employee.where("salary < #{salary}") 
 Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE (salary < 10000)
=> []                                                             
3.0.0 :007 > Employee.where("salary > #{salary}") 
 Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE (salary > 10000)
=>                                                                
[#<Employee:0x00007f64e07d9258                                     
 id: 1,                                                           
 name: "Ajay",                                                    
 salary: 30000,                                                   
 mobile_number: "123456789",                                      
 DOB: nil,                                                        
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,      
 updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,      
 count_of_pilots: 3,
 trainer_id: nil>,
#<Employee:0x00007f64e07d8f60
 id: 2,
 name: "Ajith",
 salary: 85000,
 mobile_number: "123456789",
 DOB: nil,
 created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
 updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
 count_of_pilots: 2,
 trainer_id: nil>,
#<Employee:0x00007f64e07d8df8

1 Placeholder Conditions
The above method used is the (?) replacement style of params .
This can also be done using specifing keys in condition string along with corresponding key value pair.
This makes for clearer readability if you have a large number of variable conditions.

created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
3.0.0 :008 > Employee.where("salary > :salary_min", salary_min: salary) 
  Employee Load (0.7ms)  SELECT "employees".* FROM "employees" WHERE (salary > 10000)
 =>                                                                                              
[#<Employee:0x000055d38bf9c1d0                                                                   
  id: 1,                                                                                         
  name: "Ajay",                                                                                  
  salary: 30000,                                                                                 
  mobile_number: "123456789",                                                                    
  DOB: nil,                                                                                      
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                    
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,                                    
  count_of_pilots: 3,                                                                            
  trainer_id: nil>

  2 Conditions That Use LIKE
  Using the like condition as in used in sql statement. 
  Although condition arguments are automatically escaped to prevent SQL injection, SQL LIKE wildcards (i.e., % and _) are not escaped.

  3.0.0 :010 > Employee.where("name like ?","A"+ "%") 
  Employee Load (0.8ms)  SELECT "employees".* FROM "employees" WHERE (name like 'A%')
 => 
[#<Employee:0x000055d38c406f90
  id: 1,
  name: "Ajay",
  salary: 30000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055d38c406ec8
  id: 2,
  name: "Ajith",
  salary: 85000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x000055d38c406e00
  id: 3,
  name: "Arnab",
  salary: 50000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>,
 #<Employee:0x000055d38c406d38
  id: 4,
  name: "Amar",
  salary: 45000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.975047000 UTC +00:00,
  count_of_pilots: 3,
  trainer_id: nil>] 
3.0.0 :011 > Employee.where("name like ?","A") 
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE (name like 'A')
 => [] 

 it treaks % and _ as wild cards evenif the that is not their intended use in ruby but that is in sql 
 so there is need to sanitize that in ruby before the are passed to like condition.

 sanitize_sql_like(string, escape_character = "\\")
Sanitizes a string so that it is safe to use within an SQL LIKE statement.
This method uses escape_character to escape all occurrences of itself, “_” and "%".
3.0.0 :017 > sanitize_sql_like("100% true!")
 => "100\\% true!" 
 3.0.0 :018 > sanitize_sql_like("100%", "!")
 => "100!%" 

 3.0.0 :020 > Employee.where("name like ?",Employee.sanitize_sql_like("A%")) 
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE (name like 'A\%')
 => []

 3 Hash Conditions
 Active Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax. 
 With hash conditions, you pass in a hash with keys of the fields you want qualified and the values of how you want to qualify them

 But only equality, range, and subset checking are possible with Hash conditions.

 1 Equality Conditions
 3.0.0 :023 > Employee.where(id: true) 
 =>                                                                                                         
[#<Employee:0x000055d38bffca08                            
  id: 1,                                                  
  name: "Ajay",                                           
  salary: 30000,                                          
  mobile_number: "123456789",                             
  DOB: nil,                                               
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,
  count_of_pilots: 3,                                     
  trainer_id: nil>]                                       
3.0.0 :024 > Employee.where(name: true) 
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1  [["name", "t"]]
 => [] 
Other way of writing this is field within string
3.0.0 :025 > Employee.where("name" => true) 
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."name" = $1  [["name", "t"]]
 => []  
 In the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. 
  This method works with polymorphic relationships as well.
  3.0.0 :026 > emp = Employee.where(id: true) 
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1  [["id", 1]]
 =>                                                              
[#<Employee:0x000055d38c21c810                                   
...   
3.0.0 :027 > Certified.where(employee: emp)
  Certified Load (0.5ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."employee" IN (SELECT "employees"."id" FROM "employees" WHERE "employees"."id" = $1)  [["id", 1]]
(Object doesnt support #inspect)                                
 =>                                                              
3.0.0 :028 > Certified.where(employee_id: emp)
  Certified Load (8.0ms)  SELECT "certifieds".* FROM "certifieds" WHERE "certifieds"."employee_id" IN (SELECT "employees"."id" FROM "employees" WHERE "employees"."id" = $1)  [["id", 1]]
 =>                                                              
[#<Certified:0x000055d38c44e458                                  
  id: 3,                                                         
  employee_id: 1,                                                
  aircraft_id: 3,                                                
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
 #<Certified:0x000055d38c47c010
  id: 6,
  employee_id: 1,
  aircraft_id: 2,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>,
 #<Certified:0x000055d38c477e98
  id: 16,
  employee_id: 1,
  aircraft_id: 7,
  created_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00,
  updated_at: Mon, 23 May 2022 19:53:00.270890000 UTC +00:00>]

 2 Range Conditions
It is done by using a BETWEEN SQL statement
3.0.0 :029 > Employee.where(salary: 10000..30000) 
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" WHERE "employees"."salary" BETWEEN $1 AND $2  [["salary", 10000], ["salary", 30000]]                                                                     
 =>                                                                                                 
[#<Employee:0x000055d38c4de468                                                                      
  id: 1,                                                                                            
  name: "Ajay",                                                                                     
  salary: 30000,                                                                                    
  mobile_number: "123456789",                                                                       
  DOB: nil,                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                       
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,                                       
  count_of_pilots: 3,                                                                               
  trainer_id: nil>] 
  3.0.0 :030 > Employee.where(salary: 10000...30000) 
  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE "employees"."salary" >= $1 AND "employees"."salary" < $2  [["salary", 10000], ["salary", 30000]]                                                    
 => [] 
 
 3 Subset Conditions
 find records using the IN expression
 3.0.0 :031 > Employee.where(salary: [30000, 40000, 50000]) 
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."salary" IN ($1, $2, $3)  [["salary", 30000], ["salary", 40000], ["salary", 50000]]                                                     
 =>                                                                                                  
[#<Employee:0x000055d38d1070f0                                                                       
  id: 1,                                                                                             
  name: "Ajay",                                                                                      
  salary: 30000,                                                                                     
  mobile_number: "123456789",                                                                        
  DOB: nil,                                                                                          
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                        
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,                                        
  count_of_pilots: 3,                                                                                
  trainer_id: nil>,
 #<Employee:0x000055d38d107000
  id: 3,
  name: "Arnab",
  salary: 50000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.973659000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>] 

  4 NOT Conditions
  NOT SQL queries can be built by where.not
  3.0.0 :032 > Employee.where.not(salary: [30000, 40000, 50000]).limit(1) 
  Employee Load (0.8ms)  SELECT "employees".* FROM "employees" WHERE "employees"."salary" NOT IN ($1, $2, $3) LIMIT $4  [["salary", 30000], ["salary", 40000], ["salary", 50000], ["LIMIT", 1]]                                         
 =>                                                                                                                 
[#<Employee:0x000055d38cfb49f0                                                                                      
  id: 2,                                                                                                            
  name: "Ajith",                                                                                                    
  salary: 85000,                                                                                                    
  mobile_number: "123456789",                                                                                       
  DOB: nil,                                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                                       
  updated_at: Thu, 26 May 2022 09:47:38.971275000 UTC +00:00,                                                       
  count_of_pilots: 2,                                                                                               
  trainer_id: nil>] 
 
  This will not show any value which is nil after not condition has been fullfilled
  3.0.0 :033 > Employee.where.not(mobile_number: "123456789") 
  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" != $1  [["mobile_number", "123456789"]]                                                                                                
 => []
 3.0.0 :034 > Employee.where(mobile_number: nil) 
  Employee Load (0.5ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL
 =>                                                                                                                 
[#<Employee:0x000055d38c7167a8                                                                                      
  id: 11,                                                                                                           
  name: "Gustav",                                                                                                   
  salary: nil,                                                                       
  mobile_number: nil,                                                                
  DOB: Wed, 01 Jan 1997,                                                             
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                        
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                        
  count_of_pilots: nil,                                                              
  trainer_id: nil>,    

  
  5 OR Conditions
  Employee.where(id: 1) or (Employee.where(mobile_number: nil))
  OR conditions between two relations can be built by calling or on the first relation, 
  and passing the second one as an argument.
  3.0.0 :039 > Employee.where(id: 1).or(Employee.where(mobile_number: nil))
  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE ("employees"."id" = $1 OR "employees"."mobile_number" IS NULL)  [["id", 1]]                                        
 =>                                                                 
[#<Employee:0x000055d38cceeba8                                      
  id: 1,                                                            
  name: "Ajay",                                                     
  salary: 30000,                                                    
  mobile_number: "123456789",                                       
  DOB: nil,                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,       
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,       
  count_of_pilots: 3,
  trainer_id: nil>,
 #<Employee:0x000055d38cceeae0
  id: 11,
  name: "Gustav",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055d38cceea18
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>]

  6 AND Conditions
  AND conditions can be built by chaining where conditions.
  3.0.0 :042 > Employee.where(id: 11).where(mobile_number: nil)
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1 AND "employees"."mobile_number" IS NULL  [["id", 11]]                                                                 
 =>                                                                                          
[#<Employee:0x000055d38c2d4028                                                               
  id: 11,                                                                                    
  name: "Gustav",                                                                            
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>] 

  another way of doing same is AND conditions for the logical intersection between relations can be built by calling and on the first relation, and passing the second one as an argument.
3.0.0 :040 > Employee.where(id: 11).and(Employee.where(mobile_number: nil))
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1 AND "employees"."mobile_number" IS NULL  [["id", 11]]                                                                
 =>                                                                                         
[#<Employee:0x000055d38d09c2f0                                                              
  id: 11,                                                                                   
  name: "Gustav",                                                                           
  salary: nil,                                                                              
  mobile_number: nil,                                                                       
  DOB: Wed, 01 Jan 1997,                                                                    
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                               
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                               
  count_of_pilots: nil,
  trainer_id: nil>] 

  ---------------------------------------------------------------------------------------------
  8 Having
  It is just like having clause in sql that is used to specify the condition on the group by fields
  3.0.0 :046 >           having("count(*) > ?", 2) 
  Certified Load (0.3ms)  SELECT Employee_id, count(*) as Total_certified_airplane FROM "certifieds" GROUP BY Employee_id HAVING (count(*) > 2)                                                     
 => [#<Certified:0x000055d38cedc848 id: nil, employee_id: 4>, #<Certified:0x000055d38cedc780 id: nil, employee_id: 1>]   

 3.0.0 :047 > emp = Certified.select("Employee_id, count(*) as Total_certified_airplane").
 3.0.0 :048 > group("Employee_id").
 3.0.0 :049 >           having("count(*) > ?", 1) 
   Certified Load (0.3ms)  SELECT Employee_id, count(*) as Total_certified_airplane FROM "certifieds" GROUP BY Employee_id HAVING (count(*) > 1)
  => 
 [#<Certified:0x000055d38d15cde8 id: nil, employee_id: 3>,
  #<Certified:0x000055d38d15cd20 id: nil, employee_id: 5>,
  #<Certified:0x000055d38d15cc58 id: nil, employee_id: 4>,
  #<Certified:0x000055d38d15cb40 id: nil, employee_id: 6>,
  #<Certified:0x000055d38d15ca50 id: nil, employee_id: 2>,
  #<Certified:0x000055d38d15c960 id: nil, employee_id: 7>,
  #<Certified:0x000055d38d15c870 id: nil, employee_id: 1>] 

  3.0.0 :055 > emp.class
  => Certified::ActiveRecord_Relation 

  3.0.0 :061 > emp[0].total_certified_airplane
 => 2 


--------------------------------------------------------------------------------------------
## 9 Overriding Conditions

It overrides different conditions written in the query
1 unscope

specify certain conditions to be removed using the unscope method
3.0.0 :064 > emp = Certified.select("employee_id, count(*) as total_certified_airplane").
3.0.0 :065 > group("Employee_id").
3.0.0 :066 >           having("count(*) > ?", 1) .unscope(:having)
  Certified Load (0.5ms)  SELECT employee_id, count(*) as total_certified_airplane FROM "certifieds" GROUP BY Employee_id                                                                                                               
 =>                                                                                                                 
[#<Certified:0x000055d38cf3cf68 id: nil, employee_id: 3>,                                                           
...             

Here the unscope work to remove conditoion applied by having clause so no having clause in sql query.
Can also unscope specific where clauses
3.0.0 :073 > Employee.where(id: 11, mobile_number: nil).unscope(where: :id)
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL
 =>                                                                                                                 
[#<Employee:0x000055d38c1aea68                                                                                      
  id: 11,                                                                                                           
  name: "Gustav",                                                                                                   
  salary: nil,                                                                                                      
  mobile_number: nil,                                                                                               
  DOB: Wed, 01 Jan 1997,                                                                                            
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                                                       
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                                                       
  count_of_pilots: nil,                                                                                             
  trainer_id: nil>,
 #<Employee:0x000055d38c1ae9a0
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>] 
3.0.0 :074 > 

2. only

You can also override conditions using the only method
3.0.0 :077 > Employee.where(id: 11, mobile_number: nil).unscope(where: :id).limit(1).only(:where)
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL
 => 
[#<Employee:0x000055d38ce5dea8
  id: 11,
  name: "Gustav",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>,
 #<Employee:0x000055d38ce5dde0
  id: 13,
  name: "Tesh",
  salary: nil,
  mobile_number: nil,
  DOB: Wed, 01 Jan 1997,
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
  count_of_pilots: nil,
  trainer_id: nil>] 

  3 reselect
  The reselect method overrides an existing select statement.
  3.0.0 :078 > emp = Certified.select("employee_id").reselect("aircraft_id")
  Certified Load (0.3ms)  SELECT "certifieds"."aircraft_id" FROM "certifieds"
 =>                                                                                                                 
[#<Certified:0x000055d38bcc5d30 id: nil, aircraft_id: 3>,                                                           
...                                                                                                                 
3.0.0 :079 > 

We can also use select twice to select more columns
3.0.0 :079 > emp = Certified.select("employee_id").select("aircraft_id")
  Certified Load (0.6ms)  SELECT "certifieds"."employee_id", "certifieds"."aircraft_id" FROM "certifieds"
 =>                                                                                                                 
[#<Certified:0x000055d38c29da50 id: nil, employee_id: 1, aircraft_id: 3>,                                           
...                                                                        

4 reorder
The reorder method overrides the default scope order. 
3.0.0 :081 > Employee.where.not(mobile_number: nil).order(name: :asc)
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NOT NULL ORDER BY "employees"."name" ASC                                                                                            
 =>                                                                                                                 
[#<Employee:0x000055d38d379888                                                                                      
  id: 1,                                                                                                            
  name: "Ajay",                                                                                                     
  salary: 30000,                                                                                                    
  mobile_number: "123456789",                                                                                       
  DOB: nil,                                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                                       
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,                                                       
  count_of_pilots: 3,
  trainer_id: nil>,

  3.0.0 :082 > Employee.where.not(mobile_number: nil).order(name: :asc).reorder(name: :desc)
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NOT NULL ORDER BY "employees"."name" DESC                                                                                           
 =>                                                                                                                 
[#<Employee:0x000055d38d4102b0                                                                                      
  id: 8,                                                                                                            
  name: "shubham",                                                                                                  
  salary: 120000,                                                                                                   
  mobile_number: "123456789",                                                                                       
  DOB: nil,                                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                                       
  updated_at: Thu, 26 May 2022 09:47:38.979496000 UTC +00:00,                                                       
  count_of_pilots: 0,
  trainer_id: nil>,
 #<Employee:0x000055d38d4101e8
  id: 6,
  name: "Sam",
  salary: 75000,
  mobile_number: "123456789",
  DOB: nil,
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,
  updated_at: Thu, 26 May 2022 09:47:38.977471000 UTC +00:00,
  count_of_pilots: 2,
  trainer_id: nil>

  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NOT NULL ORDER BY "employees"."salary" DESC                                                                              
  =>                                                                                                      
 [#<Employee:0x000055d38cfa4668                                                                           
   id: 7,                                                                                                 
   name: "Ram",                                                                                           
   salary: 150000,                                                                                        
   mobile_number: "123456789",                                                                            
   DOB: nil,                                                                                              
   created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                            
   updated_at: Thu, 26 May 2022 09:47:38.978501000 UTC +00:00,                                            
   count_of_pilots: 2,
   trainer_id: nil>,

   5 reverse_order
   The reverse_order method reverses the ordering clause if specified.
   3.0.0 :084 > Employee.where.not(mobile_number: nil).order(name: :asc).reverse_order
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NOT NULL ORDER BY "employees"."name" DESC                                                                                           
 =>                                                                                                                 
[#<Employee:0x000055d38cd05240                                                                                      
  id: 8,                                                                                                            
  name: "shubham",                                                                                                  
  salary: 120000,                                                                                                   
  mobile_number: "123456789",                                                                                       
  DOB: nil,                                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                                       
  updated_at: Thu, 26 May 2022 09:47:38.979496000 UTC +00:00,                                                       
  count_of_pilots: 0,
  trainer_id: nil>,
 #<Employee:0x000055d38cd05178

 3.0.0 :085 > Employee.where.not(mobile_number: nil).order(name: :asc).reorder(salary: :desc).reverse_order
  Employee Load (0.6ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NOT NULL ORDER BY "employees"."salary" ASC                                                                                          
 =>                                                                                                                 
[#<Employee:0x000055d38cdae4f8                                                                                      
  id: 1,                                                                                                            
  name: "Ajay",                                                                                                     
  salary: 30000,                                                                                                    
  mobile_number: "123456789",                                                                                       
  DOB: nil,                                                                                                         
  created_at: Mon, 23 May 2022 19:47:10.970648000 UTC +00:00,                                                       
  updated_at: Thu, 26 May 2022 09:47:38.964898000 UTC +00:00,                                                       
  count_of_pilots: 3,
  trainer_id: nil>,

  6 rewhere
  This rewhere method overrides an existing, named where condition.
  3.0.0 :086 > Employee.where.not(mobile_number: nil).order(name: :asc).reorder(salary: :desc).reverse_order.rewhere(m
    obile_number: nil)
      Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL ORDER BY "employees"."salary" ASC                                                                                              
     =>                                                                                                                 
    [#<Employee:0x000055d38cbc42a0                                                                                      
      id: 11,                
      name: "Gustav",
      salary: nil,
      mobile_number: nil,
      DOB: Wed, 01 Jan 1997,
      created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
      updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,
      count_of_pilots: nil,
      trainer_id: nil>,
     #<Employee:0x000055d38cbc41d8
      id: 13,
      name: "Tesh",
      salary: nil,
      mobile_number: nil,
      DOB: Wed, 01 Jan 1997,
      created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
      updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
      count_of_pilots: nil,
      trainer_id: nil>] 
    
      If the rewhere clause is not used, the where clauses are ANDed together
      Different case when rewhere is used multiple times.

      3.0.0 :088 > Employee.where(id: 11).where.not(mobile_number: nil).rewhere(mobile_number: nil)
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = $1 AND "employees"."mobile_number" IS NULL  [["id", 11]]                                                                                        
 =>                                                                                                                 
[#<Employee:0x000055d38c63fc80                                                                                      
  id: 11,                                                                                                           
  name: "Gustav",                                                                                                   
  salary: nil,                                                                                                      
  mobile_number: nil,                                                                                               
  DOB: Wed, 01 Jan 1997,                                                                                            
  created_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                                                       
  updated_at: Wed, 08 Jun 2022 08:30:36.537466000 UTC +00:00,                                                       
  count_of_pilots: nil,
  trainer_id: nil>]

  3.0.0 :089 > Employee.where(id: 11).where.not(mobile_number: nil).rewhere(mobile_number: nil).rewhere(id: 13)
  Employee Load (0.1ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL AND "employees"."id" = $1  [["id", 13]]                                                                                        
 =>                                                                                                                 
[#<Employee:0x000055d389697438                                                                                      
  id: 13,                                                                                                           
  name: "Tesh",                                                                                                     
  salary: nil,                                                                                                      
  mobile_number: nil,                                                                                               
  DOB: Wed, 01 Jan 1997,                                                                                            
  created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                                                       
  updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                                                       
  count_of_pilots: nil,
  trainer_id: nil>] 

  3.0.0 :091 > Employee.where(id: 11).and(Employee.where.not(mobile_number: nil)).rewhere(mobile_number: nil).rewhere(
    id: 13)
      Employee Load (0.3ms)  SELECT "employees".* FROM "employees" WHERE "employees"."mobile_number" IS NULL AND "employees"."id" = $1  [["id", 13]]                                                                     
     =>                                                                                              
    [#<Employee:0x000055d38d04ec58                                                             
      id: 13,                                                                                  
      name: "Tesh",                                                                            
      salary: nil,                                                                             
      mobile_number: nil,                                                                      
      DOB: Wed, 01 Jan 1997,                                                                   
      created_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,                              
      updated_at: Wed, 08 Jun 2022 08:31:29.169877000 UTC +00:00,
      count_of_pilots: nil,
      trainer_id: nil>] 

      ---------------------------------------------------------------------------

## Locking Records for Update

Locking is helpful for preventing race conditions when updating records in the database and ensuring atomic updates.

What is a race condition?
A race condition is an undesirable situation that occurs when a device or system attempts to perform two or more operations at the same time, 
but because of the nature of the device or system, the operations must be done in the proper sequence to be done correctly.

Active Record provides two locking mechanisms:

Optimistic Locking
Pessimistic Locking

1 Optimistic Locking
Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data.
It does this by checking whether another process has made changes to a record since it was opened. 
An ActiveRecord::StaleObjectError exception is thrown if that has occurred and the update is ignored.
It is done by updating locking columns when record is updated and when it is updates the value of locking coolumn
is checked and if it is changed then then error is raised.

So here it needs a locking column
the table needs to have a column called lock_version of type integer.
 Each time the record is updated, Active Record increments the lock_version column. 
 If an update request is made with a lower value in the lock_version field than is currently in the lock_version column in the database,
  the update request will fail with an "ActiveRecord::StaleObjectError."

Responsibility for dealing with the conflict by rescuing the exception and either rolling back,
 merging, or otherwise apply the business logic needed to resolve the conflict.

 This behavior can be turned off by setting ActiveRecord::Base.lock_optimistically = false.

To override the name of the lock_version column, ActiveRecord::Base provides a class attribute called locking_column:
#<Wallet:0x00007fdfec1aaad0
3.0.0 :024 > wallet1
 => 
#<Wallet:0x00007fdfec1aaad0                                        
3.0.0 :029 > wallet1.save!
  TRANSACTION (0.1ms)  BEGIN
  Customr Load (0.2ms)  SELECT "customrs".* FROM "customrs" WHERE "customrs"."id" = $1 LIMIT $2  [["id", 1], ["LIMIT", 1]]                                                             
  Wallet Update (0.2ms)  UPDATE "wallets" SET "amount" = $1, "updated_at" = $2, "lock_version" = $3 WHERE "wallets"."id" = $4 AND "wallets"."lock_version" = $5  [["amount", 12345678.0], ["updated_at", "2022-06-10 12:52:58.877018"], ["lock_version", 3], ["id", 1], ["lock_version", 2]]               
  TRANSACTION (0.2ms)  ROLLBACK                                    
/home/itsacheckmate/.rvm/gems/ruby-3.0.0/gems/activerecord-7.0.3/lib/active_record/locking/optimistic.rb:108:in 'update_row': Attempted to update a stale object: Wallet. (ActiveRecord::StaleObjectError)
To override the name of the lock_version column, ActiveRecord::Base provides a class attribute called locking_column
inn class have to write .
after creating the columns 
self.locking_column = :lock_customer_column

2 Pessimistic Locking
Pessimistic locking uses a locking mechanism provided by the underlying database.
Using lock when building a relation obtains an exclusive lock on the selected rows. 
Relations using lock are usually wrapped inside a transaction for preventing deadlock conditions.
 

???? NOt able use Pessimistic locking